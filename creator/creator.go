//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
package creator ;import (_f "bytes";_a "encoding/xml";_d "errors";_e "fmt";_ge "github.com/gorilla/i18n/linebreak";_de "github.com/unidoc/unichart/render";
	_bd "github.com/magnus195/unipdf/v3/common";
	_bee "github.com/magnus195/unipdf/v3/contentstream";
	_gg "github.com/magnus195/unipdf/v3/contentstream/draw";
	_dc "github.com/magnus195/unipdf/v3/core";
	_bfg "github.com/magnus195/unipdf/v3/internal/graphic2d/svg";
	_ccg "github.com/magnus195/unipdf/v3/internal/integrations/unichart";
	_ggb "github.com/magnus195/unipdf/v3/internal/license";
	_ea "github.com/magnus195/unipdf/v3/internal/transform";
	_gec "github.com/magnus195/unipdf/v3/model";_da "golang.org/x/text/unicode/bidi";_cc "image";_ef "io";_be "log";_ag "math";_cg "os";_bf "regexp";_c "sort";_fa "strconv";_bea "strings";_b "text/template";_ee "unicode";);

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_gcec *TOC )SetLineSeparator (separator string ){_gcec ._cadb =separator };

// IsAbsolute checks if the positioning is absolute.
func (_ddc Positioning )IsAbsolute ()bool {return _ddc ==PositionAbsolute };

// SetBorderWidth sets the border width of the ellipse.
func (_bgde *Ellipse )SetBorderWidth (bw float64 ){_bgde ._eagd =bw };func (_ffded *templateProcessor )parseFloatArray (_dafab ,_accg string )[]float64 {_bd .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_dafab ,_accg );
_bgdec :=_bea .Fields (_accg );_gabgf :=make ([]float64 ,0,len (_bgdec ));for _ ,_fgcb :=range _bgdec {_gfba ,_ :=_fa .ParseFloat (_fgcb ,64);_gabgf =append (_gabgf ,_gfba );};return _gabgf ;};

// GeneratePageBlocks draws the chart onto a block.
func (_eedc *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_deg :=ctx ;_fbdc :=_eedc ._ege .IsRelative ();var _bef []*Block ;if _fbdc {_eda :=1.0;_eadbb :=_eedc ._fgb .Top ;if float64 (_eedc ._gegc .Height ())> ctx .Height -_eedc ._fgb .Top {_bef =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _eadg error ;if _ ,ctx ,_eadg =_fcbca ().GeneratePageBlocks (ctx );_eadg !=nil {return nil ,ctx ,_eadg ;};_eadbb =0;};ctx .X +=_eedc ._fgb .Left +_eda ;ctx .Y +=_eadbb ;ctx .Width -=_eedc ._fgb .Left +_eedc ._fgb .Right +2*_eda ;ctx .Height -=_eadbb ;
_eedc ._gegc .SetWidth (int (ctx .Width ));}else {ctx .X =_eedc ._gefb ;ctx .Y =_eedc ._afde ;};_fcca :=_bee .NewContentCreator ();_fcca .Translate (0,ctx .PageHeight );_fcca .Scale (1,-1);_fcca .Translate (ctx .X ,ctx .Y );_cgfa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
_eedc ._gegc .Render (_ccg .NewRenderer (_fcca ,_cgfa ._fb ),nil );if _gdde :=_cgfa .addContentsByString (_fcca .String ());_gdde !=nil {return nil ,ctx ,_gdde ;};if _fbdc {_caf :=_eedc .Height ()+_eedc ._fgb .Bottom ;ctx .Y +=_caf ;ctx .Height -=_caf ;
}else {ctx =_deg ;};_bef =append (_bef ,_cgfa );return _bef ,ctx ,nil ;};

// SetColorRight sets border color for right.
func (_fdd *border )SetColorRight (col Color ){_fdd ._eag =col };

// SetFontSize sets the font size in document units (points).
func (_gdec *Paragraph )SetFontSize (fontSize float64 ){_gdec ._dffb =fontSize };

// AddTotalLine adds a new line in the invoice totals table.
func (_adfcg *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_baeb :=&InvoiceCell {_adfcg ._dbga ,desc };_cbca :=&InvoiceCell {_adfcg ._dbga ,value };_adfcg ._dgfba =append (_adfcg ._dgfba ,[2]*InvoiceCell {_baeb ,_cbca });return _baeb ,_cbca ;
};func (_adfdb *templateProcessor )parseCellBorderStyleAttr (_agagc ,_dcba string )CellBorderStyle {_bd .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_agagc ,_dcba );
_dfbg :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_dcba ];return _dfbg ;};

// Angle returns the block rotation angle in degrees.
func (_ccee *Block )Angle ()float64 {return _ccee ._gd };

// Length calculates and returns the length of the line.
func (_daeg *Line )Length ()float64 {return _ag .Sqrt (_ag .Pow (_daeg ._ccfa -_daeg ._cfgae ,2.0)+_ag .Pow (_daeg ._cfcbb -_daeg ._ebf ,2.0));};

// GetIndent get the cell's left indent.
func (_cdbe *TableCell )GetIndent ()float64 {return _cdbe ._dbafb };

// GetOptimizer returns current PDF optimizer.
func (_badf *Creator )GetOptimizer ()_gec .Optimizer {return _badf ._cfbf };

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_cecg *Creator )MoveTo (x ,y float64 ){_cecg ._bdfae .X =x ;_cecg ._bdfae .Y =y };func (_gagfe *templateProcessor )run ()error {_bbeeb :=_a .NewDecoder (_f .NewReader (_gagfe ._dffeg ));var _agag *templateNode ;for {_cfdg ,_cebac :=_bbeeb .Token ();
if _cebac !=nil {if _cebac ==_ef .EOF {return nil ;};return _cebac ;};if _cfdg ==nil {break ;};_bgede ,_gcgd :=_bccbc (_bbeeb );_ebcf :=_bbeeb .InputOffset ();switch _ecfca :=_cfdg .(type ){case _a .StartElement :_bd .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_ecfca .Name .Local );
_bfged ,_acagf :=_fbbfc [_ecfca .Name .Local ];if !_acagf {if _gagfe ._fbbbf ==""{if _bgede !=0{_bd .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0064\u003a\u0025\u0064\u005d",_ecfca .Name .Local ,_bgede ,_gcgd );
}else {_bd .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070i\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u002e\u0020\u005b%\u0064\u005d",_ecfca .Name .Local ,_ebcf );
};}else {if _bgede !=0{_bd .Log .Debug ("\u0055\u006e\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0074e\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u003a\u0025d\u005d",_ecfca .Name .Local ,_gagfe ._fbbbf ,_bgede ,_gcgd );
}else {_bd .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u005d",_ecfca .Name .Local ,_gagfe ._fbbbf ,_ebcf );
};};continue ;};_agag =&templateNode {_cggg :_ecfca ,_cafd :_agag ,_caff :_bgede ,_ecfg :_gcgd ,_geafg :_ebcf };if _bcdg :=_bfged ._cfcg ;_bcdg !=nil {_agag ._cdegg ,_cebac =_bcdg (_gagfe ,_agag );if _cebac !=nil {return _cebac ;};};case _a .EndElement :_bd .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_ecfca .Name .Local );
if _agag !=nil {if _agag ._cdegg !=nil {if _dfaee :=_gagfe .renderNode (_agag );_dfaee !=nil {return _dfaee ;};};_agag =_agag ._cafd ;};case _a .CharData :if _agag !=nil &&_agag ._cdegg !=nil {if _feeda :=_gagfe .addNodeText (_agag ,string (_ecfca ));_feeda !=nil {return _feeda ;
};};case _a .Comment :_bd .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_ecfca ));};};return nil ;};func _ecdeb (_bcdb float64 ,_ddgfb float64 ,_caga float64 ,_ecaae float64 ,_fgcfc []*ColorPoint )*RadialShading {return &RadialShading {_ddggc :&shading {_edaa :ColorWhite ,_gdegc :false ,_babg :[]bool {false ,false },_cbgef :_fgcfc },_dbfa :_bcdb ,_edcd :_ddgfb ,_dfca :_caga ,_eegfe :_ecaae ,_cgbdg :AnchorCenter };
};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_fggb *Image )SetPos (x ,y float64 ){_fggb ._acde =PositionAbsolute ;_fggb ._gfbb =x ;_fggb ._gagce =y ;};func (_ceeb *Invoice )drawSection (_dcaf ,_beeg string )[]*StyledParagraph {var _cdbb []*StyledParagraph ;if _dcaf !=""{_dbebb :=_bffb (_ceeb ._fafa );
_dbebb .SetMargins (0,0,0,5);_dbebb .Append (_dcaf );_cdbb =append (_cdbb ,_dbebb );};if _beeg !=""{_fdcg :=_bffb (_ceeb ._gbff );_fdcg .Append (_beeg );_cdbb =append (_cdbb ,_fdcg );};return _cdbb ;};

// CreateFrontPage sets a function to generate a front Page.
func (_ffd *Creator )CreateFrontPage (genFrontPageFunc func (_bafg FrontpageFunctionArgs )){_ffd ._fgg =genFrontPageFunc ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);
func _ddgae (_dbcf ,_ffff ,_ded ,_daca ,_fegb ,_aab float64 )*Curve {_deag :=&Curve {};_deag ._gdfg =_dbcf ;_deag ._cggd =_ffff ;_deag ._faba =_ded ;_deag ._fbbb =_daca ;_deag ._beg =_fegb ;_deag ._gaga =_aab ;_deag ._aada =ColorBlack ;_deag ._ddgb =1.0;
return _deag ;};func (_bacff *Invoice )setCellBorder (_accag *TableCell ,_gebd *InvoiceCell ){for _ ,_acab :=range _gebd .BorderSides {_accag .SetBorder (_acab ,CellBorderStyleSingle ,_gebd .BorderWidth );};_accag .SetBorderColor (_gebd .BorderColor );
};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_fcbf []_gg .CubicBezierCurve ;FillEnabled bool ;_dggd Color ;BorderEnabled bool ;BorderWidth float64 ;_ffcgd Color ;};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_cgbg *Creator )Finalize ()error {if _cgbg ._bgd {return nil ;};_fbg :=len (_cgbg ._gage );_bffd :=0;if _cgbg ._fgg !=nil {_gbc :=*_cgbg ;_cgbg ._gage =nil ;_cgbg ._cgc =nil ;_cgbg .initContext ();_fbaf :=FrontpageFunctionArgs {PageNum :1,TotalPages :_fbg };
_cgbg ._fgg (_fbaf );_bffd +=len (_cgbg ._gage );_cgbg ._gage =_gbc ._gage ;_cgbg ._cgc =_gbc ._cgc ;};if _cgbg .AddTOC {_cgbg .initContext ();_cgbg ._bdfae .Page =_bffd +1;if _cgbg .CustomTOC &&_cgbg ._dfed !=nil {_fdf :=*_cgbg ;_cgbg ._gage =nil ;_cgbg ._cgc =nil ;
if _def :=_cgbg ._dfed (_cgbg ._fed );_def !=nil {return _def ;};_bffd +=len (_cgbg ._gage );_cgbg ._gage =_fdf ._gage ;_cgbg ._cgc =_fdf ._cgc ;}else {if _cgbg ._dfed !=nil {if _cdfa :=_cgbg ._dfed (_cgbg ._fed );_cdfa !=nil {return _cdfa ;};};_bbee ,_ ,_bdc :=_cgbg ._fed .GeneratePageBlocks (_cgbg ._bdfae );
if _bdc !=nil {_bd .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_bdc );return _bdc ;};_bffd +=len (_bbee );};_dcf :=_cgbg ._fed .Lines ();
for _ ,_gfg :=range _dcf {_gfe ,_aefe :=_fa .Atoi (_gfg .Page .Text );if _aefe !=nil {continue ;};_gfg .Page .Text =_fa .Itoa (_gfe +_bffd );_gfg ._ccbe +=int64 (_bffd );};};_fbfd :=false ;var _dfgff []*_gec .PdfPage ;if _cgbg ._fgg !=nil {_bfbf :=*_cgbg ;
_cgbg ._gage =nil ;_cgbg ._cgc =nil ;_faddg :=FrontpageFunctionArgs {PageNum :1,TotalPages :_fbg };_cgbg ._fgg (_faddg );_fbg +=len (_cgbg ._gage );_dfgff =_cgbg ._gage ;_cgbg ._gage =append (_cgbg ._gage ,_bfbf ._gage ...);_cgbg ._cgc =_bfbf ._cgc ;_fbfd =true ;
};var _dfcc []*_gec .PdfPage ;if _cgbg .AddTOC {_cgbg .initContext ();if _cgbg .CustomTOC &&_cgbg ._dfed !=nil {_eeee :=*_cgbg ;_cgbg ._gage =nil ;_cgbg ._cgc =nil ;if _dbgg :=_cgbg ._dfed (_cgbg ._fed );_dbgg !=nil {_bd .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_dbgg );
return _dbgg ;};_dfcc =_cgbg ._gage ;_fbg +=len (_dfcc );_cgbg ._gage =_eeee ._gage ;_cgbg ._cgc =_eeee ._cgc ;}else {if _cgbg ._dfed !=nil {if _bffa :=_cgbg ._dfed (_cgbg ._fed );_bffa !=nil {_bd .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_bffa );
return _bffa ;};};_aff ,_ ,_ :=_cgbg ._fed .GeneratePageBlocks (_cgbg ._bdfae );for _ ,_cde :=range _aff {_cde .SetPos (0,0);_fbg ++;_fgae :=_cgbg .newPage ();_dfcc =append (_dfcc ,_fgae );_cgbg .setActivePage (_fgae );_cgbg .Draw (_cde );};};if _fbfd {_aeff :=_dfgff ;
_fbefb :=_cgbg ._gage [len (_dfgff ):];_cgbg ._gage =append ([]*_gec .PdfPage {},_aeff ...);_cgbg ._gage =append (_cgbg ._gage ,_dfcc ...);_cgbg ._gage =append (_cgbg ._gage ,_fbefb ...);}else {_cgbg ._gage =append (_dfcc ,_cgbg ._gage ...);};};if _cgbg ._aggf !=nil &&_cgbg .AddOutlines {var _edba func (_bdbg *_gec .OutlineItem );
_edba =func (_dcag *_gec .OutlineItem ){_dcag .Dest .Page +=int64 (_bffd );if _dgfb :=int (_dcag .Dest .Page );_dgfb >=0&&_dgfb < len (_cgbg ._gage ){_dcag .Dest .PageObj =_cgbg ._gage [_dgfb ].GetPageAsIndirectObject ();}else {_bd .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_dgfb );
};_dcag .Dest .Y =_cgbg ._aae -_dcag .Dest .Y ;_bdbge :=_dcag .Items ();for _ ,_gaf :=range _bdbge {_edba (_gaf );};};_afeg :=_cgbg ._aggf .Items ();for _ ,_agfe :=range _afeg {_edba (_agfe );};if _cgbg .AddTOC {var _ccfb int ;if _fbfd {_ccfb =len (_dfgff );
};_ceca :=_gec .NewOutlineDest (int64 (_ccfb ),0,_cgbg ._aae );if _ccfb >=0&&_ccfb < len (_cgbg ._gage ){_ceca .PageObj =_cgbg ._gage [_ccfb ].GetPageAsIndirectObject ();}else {_bd .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_ccfb );
};_cgbg ._aggf .Insert (0,_gec .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_ceca ));};};for _ebgf ,_caba :=range _cgbg ._gage {_cgbg .setActivePage (_caba );if _cgbg ._ecgd !=nil {_dcbb ,_faaa ,_afadd :=_caba .Size ();
if _afadd !=nil {return _afadd ;};_ddga :=PageFinalizeFunctionArgs {PageNum :_ebgf +1,PageWidth :_dcbb ,PageHeight :_faaa ,TOCPages :len (_dfcc ),TotalPages :_fbg };if _fcdb :=_cgbg ._ecgd (_ddga );_fcdb !=nil {_bd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_fcdb );
return _fcdb ;};};if _cgbg ._acf !=nil {_abb :=NewBlock (_cgbg ._bfe ,_cgbg ._bag .Top );_ecaa :=HeaderFunctionArgs {PageNum :_ebgf +1,TotalPages :_fbg };_cgbg ._acf (_abb ,_ecaa );_abb .SetPos (0,0);if _fega :=_cgbg .Draw (_abb );_fega !=nil {_bd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_fega );
return _fega ;};};if _cgbg ._fgc !=nil {_gefd :=NewBlock (_cgbg ._bfe ,_cgbg ._bag .Bottom );_ffcd :=FooterFunctionArgs {PageNum :_ebgf +1,TotalPages :_fbg };_cgbg ._fgc (_gefd ,_ffcd );_gefd .SetPos (0,_cgbg ._aae -_gefd ._df );if _cddc :=_cgbg .Draw (_gefd );
_cddc !=nil {_bd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_cddc );return _cddc ;};};_dagf ,_bcad :=_cgbg ._eabc [_caba ];if _afge ,_eceg :=_cgbg ._gggc [_caba ];
_eceg {if _bcad {_dagf .transformBlock (_afge );};if _cgbgc :=_afge .drawToPage (_caba );_cgbgc !=nil {_bd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_ebgf +1,_cgbgc );
return _cgbgc ;};};if _bcad {if _eaf :=_dagf .transformPage (_caba );_eaf !=nil {_bd .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_eaf );
return _eaf ;};};};_cgbg ._bgd =true ;return nil ;};

// SetColPosition sets cell column position.
func (_gcab *TableCell )SetColPosition (col int ){_gcab ._dfdfe =col };func _fggf (_dbdda *_gec .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_dbdda ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// SetColor sets the color of the Paragraph text.
//
// Example:
//
//  1. p := NewParagraph("Red paragraph")
//     // Set to red color with a hex code:
//     p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
//  2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//     p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
//  3. Make Paragraph blue with arithmetic (0-1) rgb components.
//     p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
func (_dcgf *Paragraph )SetColor (col Color ){_dcgf ._fafd =col };func _addd (_ecdf ,_ebdf ,_agdef ,_ccc float64 )*Line {return &Line {_cfgae :_ecdf ,_ebf :_ebdf ,_ccfa :_agdef ,_cfcbb :_ccc ,_bddae :ColorBlack ,_bceg :1.0,_faaeb :1.0,_cgdgd :[]int64 {1,1},_gecec :PositionAbsolute };
};func (_dgdca *Rectangle )applyFitMode (_fccg float64 ){_fccg -=_dgdca ._ebfa .Left +_dgdca ._ebfa .Right +_dgdca ._dacd ;switch _dgdca ._ccef {case FitModeFillWidth :_dgdca .ScaleToWidth (_fccg );};};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_ebac *RadialShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};func (_dacdfe *templateProcessor )parseParagraph (_dbgdd *templateNode ,_fegbf *Paragraph )(interface{},error ){if _fegbf ==nil {_fegbf =_dacdfe .creator .NewParagraph ("");
};for _ ,_ddeeg :=range _dbgdd ._cggg .Attr {_eeeae :=_ddeeg .Value ;switch _dffeb :=_ddeeg .Name .Local ;_dffeb {case "\u0066\u006f\u006e\u0074":_fegbf .SetFont (_dacdfe .parseFontAttr (_dffeb ,_eeeae ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_fegbf .SetFontSize (_dacdfe .parseFloatAttr (_dffeb ,_eeeae ));
case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_fegbf .SetTextAlignment (_dacdfe .parseTextAlignmentAttr (_dffeb ,_eeeae ));case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_fegbf .SetLineHeight (_dacdfe .parseFloatAttr (_dffeb ,_eeeae ));
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_fegbf .SetEnableWrap (_dacdfe .parseBoolAttr (_dffeb ,_eeeae ));case "\u0063\u006f\u006co\u0072":_fegbf .SetColor (_dacdfe .parseColorAttr (_dffeb ,_eeeae ));case "\u0078":_fegbf .SetPos (_dacdfe .parseFloatAttr (_dffeb ,_eeeae ),_fegbf ._dbec );
case "\u0079":_fegbf .SetPos (_fegbf ._fbeab ,_dacdfe .parseFloatAttr (_dffeb ,_eeeae ));case "\u0061\u006e\u0067l\u0065":_fegbf .SetAngle (_dacdfe .parseFloatAttr (_dffeb ,_eeeae ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_ggfbcg :=_dacdfe .parseMarginAttr (_dffeb ,_eeeae );
_fegbf .SetMargins (_ggfbcg .Left ,_ggfbcg .Right ,_ggfbcg .Top ,_ggfbcg .Bottom );case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_fegbf .SetMaxLines (int (_dacdfe .parseInt64Attr (_dffeb ,_eeeae )));default:_dacdfe .nodeLogDebug (_dbgdd ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_dffeb );
};};return _fegbf ,nil ;};

// Margins returns the margins of the component.
func (_dedb *Division )Margins ()(_aefg ,_aaec ,_fabb ,_bdfe float64 ){return _dedb ._dedd .Left ,_dedb ._dedd .Right ,_dedb ._dedd .Top ,_dedb ._dedd .Bottom ;};

// SetAnnotation sets a annotation on a TextChunk.
func (_dedg *TextChunk )SetAnnotation (annotation *_gec .PdfAnnotation ){_dedg ._aacgc =annotation };

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_dfd :=&Block {};_dfd ._efc =&_bee .ContentStreamOperations {};_dfd ._fb =_gec .NewPdfPageResources ();_dfd ._bb =width ;_dfd ._df =height ;return _dfd ;};

// String implements error interface.
func (_egba UnsupportedRuneError )Error ()string {return _egba .Message };func _afdg (_bcabd *Block ,_aggbg *Paragraph ,_afca DrawContext )(DrawContext ,error ){_fecbd :=1;_dfbc :=_dc .PdfObjectName ("\u0046\u006f\u006e\u0074"+_fa .Itoa (_fecbd ));for _bcabd ._fb .HasFontByName (_dfbc ){_fecbd ++;
_dfbc =_dc .PdfObjectName ("\u0046\u006f\u006e\u0074"+_fa .Itoa (_fecbd ));};_eeaba :=_bcabd ._fb .SetFontByName (_dfbc ,_aggbg ._eged .ToPdfObject ());if _eeaba !=nil {return _afca ,_eeaba ;};_aggbg .wrapText ();_cfef :=_bee .NewContentCreator ();_cfef .Add_q ();
_bdbe :=_afca .PageHeight -_afca .Y -_aggbg ._dffb *_aggbg ._cdeb ;_cfef .Translate (_afca .X ,_bdbe );if _aggbg ._edef !=0{_cfef .RotateDeg (_aggbg ._edef );};_ccdd :=_dbceg (_aggbg ._fafd );_eeaba =_eecec (_bcabd ,_ccdd ,_aggbg ._fafd ,func ()Rectangle {return Rectangle {_edaf :_afca .X ,_dgedd :_bdbe ,_dgdba :_aggbg .getMaxLineWidth ()/1000.0,_gfef :_aggbg .Height ()};
});if _eeaba !=nil {return _afca ,_eeaba ;};_cfef .Add_BT ().SetNonStrokingColor (_ccdd ).Add_Tf (_dfbc ,_aggbg ._dffb ).Add_TL (_aggbg ._dffb *_aggbg ._cdeb );for _efdd ,_daccb :=range _aggbg ._bdad {if _efdd !=0{_cfef .Add_Tstar ();};_cdee :=[]rune (_daccb );
_acef :=0.0;_beafc :=0;for _gfca ,_ceba :=range _cdee {if _ceba ==' '{_beafc ++;continue ;};if _ceba =='\u000A'{continue ;};_gggab ,_bdaf :=_aggbg ._eged .GetRuneMetrics (_ceba );if !_bdaf {_bd .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_gfca ,_ceba ,_ceba ,_aggbg ._eged .BaseFont (),_aggbg ._eged .Subtype ());
return _afca ,_d .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_acef +=_aggbg ._dffb *_gggab .Wx ;};var _fffaf []_dc .PdfObject ;_acdf ,_gabb :=_aggbg ._eged .GetRuneMetrics (' ');
if !_gabb {return _afca ,_d .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_dgdb :=_acdf .Wx ;switch _aggbg ._abcc {case TextAlignmentJustify :if _beafc > 0&&_efdd < len (_aggbg ._bdad )-1{_dgdb =(_aggbg ._abcd *1000.0-_acef )/float64 (_beafc )/_aggbg ._dffb ;
};case TextAlignmentCenter :_cbgf :=_acef +float64 (_beafc )*_dgdb *_aggbg ._dffb ;_bfbc :=(_aggbg ._abcd *1000.0-_cbgf )/2/_aggbg ._dffb ;_fffaf =append (_fffaf ,_dc .MakeFloat (-_bfbc ));case TextAlignmentRight :_cffd :=_acef +float64 (_beafc )*_dgdb *_aggbg ._dffb ;
_aeda :=(_aggbg ._abcd *1000.0-_cffd )/_aggbg ._dffb ;_fffaf =append (_fffaf ,_dc .MakeFloat (-_aeda ));};_faee :=_aggbg ._eged .Encoder ();var _adbd []byte ;for _ ,_egde :=range _cdee {if _egde =='\u000A'{continue ;};if _egde ==' '{if len (_adbd )> 0{_fffaf =append (_fffaf ,_dc .MakeStringFromBytes (_adbd ));
_adbd =nil ;};_fffaf =append (_fffaf ,_dc .MakeFloat (-_dgdb ));}else {if _ ,_aefc :=_faee .RuneToCharcode (_egde );!_aefc {_eeaba =UnsupportedRuneError {Message :_e .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_egde ,_egde ),Rune :_egde };
_afca ._ddgg =append (_afca ._ddgg ,_eeaba );_bd .Log .Debug (_eeaba .Error ());if _afca ._baecf <=0{continue ;};_egde =_afca ._baecf ;};_adbd =append (_adbd ,_faee .Encode (string (_egde ))...);};};if len (_adbd )> 0{_fffaf =append (_fffaf ,_dc .MakeStringFromBytes (_adbd ));
};_cfef .Add_TJ (_fffaf ...);};_cfef .Add_ET ();_cfef .Add_Q ();_bdab :=_cfef .Operations ();_bdab .WrapIfNeeded ();_bcabd .addContents (_bdab );if _aggbg ._dfgb .IsRelative (){_dffbb :=_aggbg .Height ();_afca .Y +=_dffbb ;_afca .Height -=_dffbb ;if _afca .Inline {_afca .X +=_aggbg .Width ()+_aggbg ._bgcd .Right ;
};};return _afca ,nil ;};

// SetLineOpacity sets the line opacity.
func (_fbbbe *Polyline )SetLineOpacity (opacity float64 ){_fbbbe ._ccde =opacity };

// GetRowHeight returns the height of the specified row.
func (_ggee *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_ggee ._faga ){return 0,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _ggee ._faga [row -1],nil ;
};

// SetEnableWrap sets the line wrapping enabled flag.
func (_gadf *StyledParagraph )SetEnableWrap (enableWrap bool ){_gadf ._cafa =enableWrap ;_gadf ._cfdd =false ;};

// SetSideBorderStyle sets the cell's side border style.
func (_bceb *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_bceb ._defff =style ;_bceb ._bbefe =style ;_bceb ._afggg =style ;_bceb ._ccdgd =style ;case CellBorderSideTop :_bceb ._defff =style ;
case CellBorderSideBottom :_bceb ._bbefe =style ;case CellBorderSideLeft :_bceb ._afggg =style ;case CellBorderSideRight :_bceb ._ccdgd =style ;};};

// NewColorPoint creates a new color and point object for use in the gradient rendering process.
func NewColorPoint (color Color ,point float64 )*ColorPoint {return _egga (color ,point )};

// SetText replaces all the text of the paragraph with the specified one.
func (_cedbf *StyledParagraph )SetText (text string )*TextChunk {_cedbf .Reset ();return _cedbf .Append (text );};

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_gegc _de .ChartRenderable ;_ege Positioning ;_gefb float64 ;_afde float64 ;_fgb Margins ;};

// FitMode returns the fit mode of the ellipse.
func (_fbed *Ellipse )FitMode ()FitMode {return _fbed ._bbcaf };

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _de .ChartRenderable )*Chart {return _aeb (chart )};func _fgfa (_fcfc ,_gbad ,_abaa ,_ebcdg float64 )*Ellipse {return &Ellipse {_gac :_fcfc ,_dbcef :_gbad ,_eegf :_abaa ,_gaeb :_ebcdg ,_ggfe :PositionAbsolute ,_gaddb :1.0,_dgde :ColorBlack ,_eagd :1.0,_fda :1.0};
};

// NewImageFromData creates an Image from image data.
func (_daaa *Creator )NewImageFromData (data []byte )(*Image ,error ){return _afab (data )};func (_gaddbb *StyledParagraph )getMaxLineWidth ()float64 {if _gaddbb ._dbgba ==nil ||len (_gaddbb ._dbgba )==0{_gaddbb .wrapText ();};var _eecca float64 ;for _ ,_dfgcf :=range _gaddbb ._dbgba {_afcc :=_gaddbb .getTextLineWidth (_dfgcf );
if _afcc > _eecca {_eecca =_afcc ;};};return _eecca ;};func _afab (_abfeb []byte )(*Image ,error ){_fcaa :=_f .NewReader (_abfeb );_gadb ,_geca :=_gec .ImageHandling .Read (_fcaa );if _geca !=nil {_bd .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_geca );
return nil ,_geca ;};return _cged (_gadb );};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_efc *_bee .ContentStreamOperations ;_fb *_gec .PdfPageResources ;_eec Positioning ;_bg ,_fe float64 ;_bb float64 ;_df float64 ;_gd float64 ;_ae Margins ;_fc []*_gec .PdfAnnotation ;};

// SetStyleRight sets border style for right side.
func (_gaag *border )SetStyleRight (style CellBorderStyle ){_gaag ._ebcd =style };func (_ebaed *StyledParagraph )getTextLineWidth (_faegd []*TextChunk )float64 {var _gcfd float64 ;_gecfd :=len (_faegd );for _fabg ,_gaegb :=range _faegd {_bdgfcf :=&_gaegb .Style ;
_ebea :=len (_gaegb .Text );for _gcde ,_geafa :=range _gaegb .Text {if _geafa =='\u000A'{continue ;};_ggdda ,_eddaa :=_bdgfcf .Font .GetRuneMetrics (_geafa );if !_eddaa {_bd .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_geafa );
return -1;};_gcfd +=_bdgfcf .FontSize *_ggdda .Wx *_bdgfcf .horizontalScale ();if _geafa !=' '&&(_fabg !=_gecfd -1||_gcde !=_ebea -1){_gcfd +=_bdgfcf .CharSpacing *1000.0;};};};return _gcfd ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_ecgc *Table )SetMargins (left ,right ,top ,bottom float64 ){_ecgc ._degb .Left =left ;_ecgc ._degb .Right =right ;_ecgc ._degb .Top =top ;_ecgc ._degb .Bottom =bottom ;};

// MoveY moves the drawing context to absolute position y.
func (_bgee *Creator )MoveY (y float64 ){_bgee ._bdfae .Y =y };

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_ddad *Creator )SetOutlineTree (outlineTree *_gec .PdfOutlineTreeNode ){_ddad ._cdcc =outlineTree };

// SetBorderWidth sets the border width of the rectangle.
func (_faef *Rectangle )SetBorderWidth (bw float64 ){_faef ._dacd =bw };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_egbg *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _egbg ._dfcfg .Left ,_egbg ._dfcfg .Right ,_egbg ._dfcfg .Top ,_egbg ._dfcfg .Bottom ;};

// SetColorLeft sets border color for left.
func (_gdeg *border )SetColorLeft (col Color ){_gdeg ._dadc =col };

// SetPositioning sets the positioning of the line (absolute or relative).
func (_ceea *Line )SetPositioning (positioning Positioning ){_ceea ._gecec =positioning };func _daac (_befeg string ,_afce TextStyle )*Paragraph {_gaada :=&Paragraph {_adee :_befeg ,_eged :_afce .Font ,_dffb :_afce .FontSize ,_cdeb :1.0,_bcab :true ,_fffec :true ,_abcc :TextAlignmentLeft ,_edef :0,_aafbf :1,_dabbdf :1,_dfgb :PositionRelative };
_gaada .SetColor (_afce .Color );return _gaada ;};

// SetFillColor sets the fill color.
func (_fdadd *PolyBezierCurve )SetFillColor (color Color ){_fdadd ._adeaf =color ;_fdadd ._cdaad .FillColor =_dbceg (color );};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_debbd *TableCell )SetBorderLineStyle (style _gg .LineStyle ){_debbd ._dbgfb =style };

// Scale scales the rectangle dimensions by the specified factors.
func (_bdbc *Rectangle )Scale (xFactor ,yFactor float64 ){_bdbc ._dgdba =xFactor *_bdbc ._dgdba ;_bdbc ._gfef =yFactor *_bdbc ._gfef ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_aggb *Creator )RotateDeg (angleDeg int64 )error {_bdgf :=_aggb .getActivePage ();if _bdgf ==nil {_bd .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _d .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_bd .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _bcce int64 ;if _bdgf .Rotate !=nil {_bcce =*(_bdgf .Rotate );};_bcce +=angleDeg ;_bdgf .Rotate =&_bcce ;return nil ;};

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_bbgbg *Table )MultiRowCell (rowspan int )*TableCell {return _bbgbg .MultiCell (rowspan ,1)};

// FillColor returns the fill color of the rectangle.
func (_gacd *Rectangle )FillColor ()Color {return _gacd ._gbbce };

// SetText sets the text content of the Paragraph.
func (_cdeg *Paragraph )SetText (text string ){_cdeg ._adee =text };

// GetMargins returns the margins of the ellipse: left, right, top, bottom.
func (_added *Ellipse )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _added ._ddcf .Left ,_added ._ddcf .Right ,_added ._ddcf .Top ,_added ._ddcf .Bottom ;};

// Reset removes all the text chunks the paragraph contains.
func (_dfec *StyledParagraph )Reset (){_dfec ._acbg =[]*TextChunk {}};

// AddSection adds a new content section at the end of the invoice.
func (_egad *Invoice )AddSection (title ,content string ){_egad ._gede =append (_egad ._gede ,[2]string {title ,content });};

// RotatedSize returns the width and height of the rotated block.
func (_ff *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_cga ,_bdfa :=_gdag (_ff ._bb ,_ff ._df ,_ff ._gd );return _cga ,_bdfa ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_abcdd *LinearShading )SetExtends (start bool ,end bool ){_abcdd ._dece .SetExtends (start ,end )};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_ac *Block )AddAnnotation (annotation *_gec .PdfAnnotation ){for _ ,_dbg :=range _ac ._fc {if _dbg ==annotation {return ;};};_ac ._fc =append (_ac ._fc ,annotation );};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_fcagf *Invoice )TotalLines ()[][2]*InvoiceCell {_dgec :=[][2]*InvoiceCell {_fcagf ._aaaeg };_dgec =append (_dgec ,_fcagf ._dgfba ...);return append (_dgec ,_fcagf ._fedd );};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_bgea *Creator )NewImageFromGoImage (goimg _cc .Image )(*Image ,error ){return _gaade (goimg )};type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );};

// Scale scales the ellipse dimensions by the specified factors.
func (_eddag *Ellipse )Scale (xFactor ,yFactor float64 ){_eddag ._eegf =xFactor *_eddag ._eegf ;_eddag ._gaeb =yFactor *_eddag ._gaeb ;};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_efdg *StyledParagraph )Insert (index uint ,text string )*TextChunk {_fcgc :=uint (len (_efdg ._acbg ));if index > _fcgc {index =_fcgc ;};_fdefa :=NewTextChunk (text ,_efdg ._gfbba );_efdg ._acbg =append (_efdg ._acbg [:index ],append ([]*TextChunk {_fdefa },_efdg ._acbg [index :]...)...);
_efdg .wrapText ();return _fdefa ;};

// NewImageFromFile creates an Image from a file.
func (_babb *Creator )NewImageFromFile (path string )(*Image ,error ){return _dacc (path )};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_aggbd *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_aggbd ._acgc {_bd .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aggbd ._fgdb =widths ;return nil ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_afdd *Creator )DrawTemplate (r _ef .Reader ,data interface{},options *TemplateOptions )error {return _eaac (_afdd ,r ,data ,options ,_afdd );};func _aebee (_fgff int64 ,_fbde ,_ccead ,_afgd float64 )*_gec .PdfAnnotation {_cgcc :=_gec .NewPdfAnnotationLink ();
_gagceg :=_gec .NewBorderStyle ();_gagceg .SetBorderWidth (0);_cgcc .BS =_gagceg .ToPdfObject ();if _fgff < 0{_fgff =0;};_cgcc .Dest =_dc .MakeArray (_dc .MakeInteger (_fgff ),_dc .MakeName ("\u0058\u0059\u005a"),_dc .MakeFloat (_fbde ),_dc .MakeFloat (_ccead ),_dc .MakeFloat (_afgd ));
return _cgcc .PdfAnnotation ;};func (_bdbea *Table )wrapRow (_baefg int ,_gcdd DrawContext ,_bfbfd float64 )(bool ,error ){if !_bdbea ._bfec {return false ,nil ;};var (_cfde =_bdbea ._dabec [_baefg ];_ebeb =-1;_cfce []*TableCell ;_gcbea float64 ;_befc bool ;
_agfbg =make ([]float64 ,0,len (_bdbea ._fgdb )););_fbge :=func (_bgeec *TableCell ,_ebce VectorDrawable ,_bccb bool )*TableCell {_gfaef :=*_bgeec ;_gfaef ._cbbec =_ebce ;if _bccb {_gfaef ._eddfg ++;};return &_gfaef ;};_gbgf :=func (_dcfb int ,_dbgaa VectorDrawable ){var _ddfe float64 =-1;
if _dbgaa ==nil {if _ccae :=_agfbg [_dcfb -_baefg ];_ccae > _gcdd .Height {_dbgaa =_bdbea ._dabec [_dcfb ]._cbbec ;_bdbea ._dabec [_dcfb ]._cbbec =nil ;_agfbg [_dcfb -_baefg ]=0;_ddfe =_ccae ;};};_dddae :=_fbge (_bdbea ._dabec [_dcfb ],_dbgaa ,true );_cfce =append (_cfce ,_dddae );
if _ddfe < 0{_ddfe =_dddae .height (_gcdd .Width );};if _ddfe > _gcbea {_gcbea =_ddfe ;};};for _dege :=_baefg ;_dege < len (_bdbea ._dabec );_dege ++{_cbedb :=_bdbea ._dabec [_dege ];if _cfde ._eddfg !=_cbedb ._eddfg {_ebeb =_dege ;break ;};_gcdd .Width =_cbedb .width (_bdbea ._fgdb ,_bfbfd );
_becg :=_cbedb .height (_gcdd .Width );var _bdgad VectorDrawable ;switch _ageda :=_cbedb ._cbbec .(type ){case *StyledParagraph :if _becg > _gcdd .Height {_agcd :=_gcdd ;_agcd .Height =_ag .Floor (_gcdd .Height -_ageda ._dfcfg .Top -_ageda ._dfcfg .Bottom -0.5*_ageda .getTextHeight ());
_bggac ,_gfdc ,_dbcce :=_ageda .split (_agcd );if _dbcce !=nil {return false ,_dbcce ;};if _bggac !=nil &&_gfdc !=nil {_ageda =_bggac ;_cbedb =_fbge (_cbedb ,_bggac ,false );_bdbea ._dabec [_dege ]=_cbedb ;_bdgad =_gfdc ;_befc =true ;};_becg =_cbedb .height (_gcdd .Width );
};case *Division :if _becg > _gcdd .Height {_dgfbaa :=_gcdd ;_dgfbaa .Height =_ag .Floor (_gcdd .Height -_ageda ._dedd .Top -_ageda ._dedd .Bottom );_gfaca ,_dgdd :=_ageda .split (_dgfbaa );if _gfaca !=nil &&_dgdd !=nil {_ageda =_gfaca ;_cbedb =_fbge (_cbedb ,_gfaca ,false );
_bdbea ._dabec [_dege ]=_cbedb ;_bdgad =_dgdd ;_befc =true ;if _gfaca ._geaa !=nil {_gfaca ._geaa .BorderRadiusBottomLeft =0;_gfaca ._geaa .BorderRadiusBottomRight =0;};if _dgdd ._geaa !=nil {_dgdd ._geaa .BorderRadiusTopLeft =0;_dgdd ._geaa .BorderRadiusTopRight =0;
};_becg =_cbedb .height (_gcdd .Width );};};case *List :if _becg > _gcdd .Height {_cccc :=_gcdd ;_cccc .Height =_ag .Floor (_gcdd .Height -_ageda ._ebde .Vertical ());_bedbd ,_babdg :=_ageda .split (_cccc );if _bedbd !=nil {_ageda =_bedbd ;_cbedb =_fbge (_cbedb ,_bedbd ,false );
_bdbea ._dabec [_dege ]=_cbedb ;};if _babdg !=nil {_bdgad =_babdg ;_befc =true ;};_becg =_cbedb .height (_gcdd .Width );};};_agfbg =append (_agfbg ,_becg );if _befc {if _cfce ==nil {_cfce =make ([]*TableCell ,0,len (_bdbea ._fgdb ));for _agcc :=_baefg ;
_agcc < _dege ;_agcc ++{_gbgf (_agcc ,nil );};};_gbgf (_dege ,_bdgad );};};var _gadff float64 ;for _ ,_gcfdg :=range _agfbg {if _gcfdg > _gadff {_gadff =_gcfdg ;};};if _befc &&_gadff < _gcdd .Height {if _ebeb < 0{_ebeb =len (_bdbea ._dabec );};_caefd :=_bdbea ._dabec [_ebeb -1]._eddfg +_bdbea ._dabec [_ebeb -1]._bcgc -1;
for _ffbdc :=_ebeb ;_ffbdc < len (_bdbea ._dabec );_ffbdc ++{_bdbea ._dabec [_ffbdc ]._eddfg ++;};_bdbea ._dabec =append (_bdbea ._dabec [:_ebeb ],append (_cfce ,_bdbea ._dabec [_ebeb :]...)...);_bdbea ._faga =append (_bdbea ._faga [:_caefd ],append ([]float64 {_gcbea },_bdbea ._faga [_caefd :]...)...);
_bdbea ._faga [_cfde ._eddfg +_cfde ._bcgc -2]=_gadff ;};return _befc ,nil ;};func (_fdeb *Invoice )drawAddress (_fecb *InvoiceAddress )[]*StyledParagraph {var _fdebe []*StyledParagraph ;if _fecb .Heading !=""{_dfgdf :=_bffb (_fdeb ._cgfdg );_dfgdf .SetMargins (0,0,0,7);
_dfgdf .Append (_fecb .Heading );_fdebe =append (_fdebe ,_dfgdf );};_fedg :=_bffb (_fdeb ._accd );_fedg .SetLineHeight (1.2);_dgcd :=_fecb .Separator ;if _dgcd ==""{_dgcd =_fdeb ._adec ;};_ffacg :=_fecb .City ;if _fecb .State !=""{if _ffacg !=""{_ffacg +=_dgcd ;
};_ffacg +=_fecb .State ;};if _fecb .Zip !=""{if _ffacg !=""{_ffacg +=_dgcd ;};_ffacg +=_fecb .Zip ;};if _fecb .Name !=""{_fedg .Append (_fecb .Name +"\u000a");};if _fecb .Street !=""{_fedg .Append (_fecb .Street +"\u000a");};if _fecb .Street2 !=""{_fedg .Append (_fecb .Street2 +"\u000a");
};if _ffacg !=""{_fedg .Append (_ffacg +"\u000a");};if _fecb .Country !=""{_fedg .Append (_fecb .Country +"\u000a");};_fdbdf :=_bffb (_fdeb ._accd );_fdbdf .SetLineHeight (1.2);_fdbdf .SetMargins (0,0,7,0);if _fecb .Phone !=""{_fdbdf .Append (_fecb .fmtLine (_fecb .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_fecb .HidePhoneLabel ));
};if _fecb .Email !=""{_fdbdf .Append (_fecb .fmtLine (_fecb .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_fecb .HideEmailLabel ));};_fdebe =append (_fdebe ,_fedg ,_fdbdf );return _fdebe ;};

// SetAngle sets the rotation angle of the text.
func (_bggae *Paragraph )SetAngle (angle float64 ){_bggae ._edef =angle };

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_bdd *Chapter )Add (d Drawable )error {if Drawable (_bdd )==d {_bd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _gcg :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_bdd ._dcea =append (_bdd ._dcea ,d );case containerDrawable :_edg ,_adg :=_gcg .ContainerComponent (_bdd );
if _adg !=nil {return _adg ;};_bdd ._dcea =append (_bdd ._dcea ,_edg );default:_bd .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};

// SetBorderColor sets the border color.
func (_fgfc *CurvePolygon )SetBorderColor (color Color ){_fgfc ._cecf .BorderColor =_dbceg (color )};func (_ggaga *StyledParagraph )wrapChunks (_bdga bool )error {if !_ggaga ._cafa ||int (_ggaga ._dabc )<=0{_ggaga ._dbgba =[][]*TextChunk {_ggaga ._acbg };
return nil ;};if _ggaga ._gedfe {_ggaga .wrapWordChunks ();};_ggaga ._dbgba =[][]*TextChunk {};var _effd []*TextChunk ;var _bffda float64 ;_cfaea :=_ee .IsSpace ;if !_bdga {_cfaea =func (rune )bool {return false };};_bcagc :=_fabd (_ggaga ._dabc *1000.0,0.000001);
for _ ,_bgbda :=range _ggaga ._acbg {_bafa :=_bgbda .Style ;_caef :=_bgbda ._aacgc ;_dgfg :=_bgbda .VerticalAlignment ;var (_cddf []rune ;_fgabg []float64 ;);_cdbg :=_bacfb (_bgbda .Text );for _ ,_acaf :=range _bgbda .Text {if _acaf =='\u000A'{if !_bdga {_cddf =append (_cddf ,_acaf );
};_effd =append (_effd ,&TextChunk {Text :_bea .TrimRightFunc (string (_cddf ),_cfaea ),Style :_bafa ,_aacgc :_edaac (_caef ),VerticalAlignment :_dgfg });_ggaga ._dbgba =append (_ggaga ._dbgba ,_effd );_effd =nil ;_bffda =0;_cddf =nil ;_fgabg =nil ;continue ;
};_bgcc :=_acaf ==' ';_ebgc ,_afabc :=_bafa .Font .GetRuneMetrics (_acaf );if _ebgc .Wx ==0&&_bafa .MultiFont !=nil ||_bafa .MultiFont !=nil &&!_afabc {_ebgc ,_afabc =_bafa .MultiFont .GetRuneMetrics (_acaf );};if !_afabc {_bd .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_acaf );
return _d .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_gbdg :=_bafa .FontSize *_ebgc .Wx *_bafa .horizontalScale ();_adaef :=_gbdg ;if !_bgcc {_adaef =_gbdg +_bafa .CharSpacing *1000.0;
};if _bffda +_gbdg > _bcagc {_bgeeb :=-1;if !_bgcc {for _aegg :=len (_cddf )-1;_aegg >=0;_aegg --{if _cddf [_aegg ]==' '{_bgeeb =_aegg ;break ;};};};if _ggaga ._gedfe {_egfb :=len (_effd );if _egfb > 0{_effd [_egfb -1].Text =_bea .TrimRightFunc (_effd [_egfb -1].Text ,_cfaea );
_ggaga ._dbgba =append (_ggaga ._dbgba ,_effd );_effd =[]*TextChunk {};};_cddf =append (_cddf ,_acaf );_fgabg =append (_fgabg ,_adaef );if _bgeeb >=0{_cddf =_cddf [_bgeeb +1:];_fgabg =_fgabg [_bgeeb +1:];};_bffda =0;for _ ,_bbad :=range _fgabg {_bffda +=_bbad ;
};if _bffda > _bcagc {_dgebg :=string (_cddf [:len (_cddf )-1]);_dgebg =_gadg (_dgebg ,_cdbg );if !_bdga &&_bgcc {_dgebg +="\u0020";};_effd =append (_effd ,&TextChunk {Text :_bea .TrimRightFunc (_dgebg ,_cfaea ),Style :_bafa ,_aacgc :_edaac (_caef ),VerticalAlignment :_dgfg });
_ggaga ._dbgba =append (_ggaga ._dbgba ,_effd );_effd =[]*TextChunk {};_cddf =[]rune {_acaf };_fgabg =[]float64 {_adaef };_bffda =_adaef ;};continue ;};_gfaed :=string (_cddf );if _bgeeb >=0{_gfaed =string (_cddf [0:_bgeeb +1]);_cddf =_cddf [_bgeeb +1:];
_cddf =append (_cddf ,_acaf );_fgabg =_fgabg [_bgeeb +1:];_fgabg =append (_fgabg ,_adaef );_bffda =0;for _ ,_dcgeg :=range _fgabg {_bffda +=_dcgeg ;};}else {if _bgcc {_bffda =0;_cddf =[]rune {};_fgabg =[]float64 {};}else {_bffda =_adaef ;_cddf =[]rune {_acaf };
_fgabg =[]float64 {_adaef };};};_gfaed =_gadg (_gfaed ,_cdbg );if !_bdga &&_bgcc {_gfaed +="\u0020";};_effd =append (_effd ,&TextChunk {Text :_bea .TrimRightFunc (_gfaed ,_cfaea ),Style :_bafa ,_aacgc :_edaac (_caef ),VerticalAlignment :_dgfg });_ggaga ._dbgba =append (_ggaga ._dbgba ,_effd );
_effd =[]*TextChunk {};}else {_bffda +=_adaef ;_cddf =append (_cddf ,_acaf );_fgabg =append (_fgabg ,_adaef );};};if len (_cddf )> 0{_adfbf :=_gadg (string (_cddf ),_cdbg );_effd =append (_effd ,&TextChunk {Text :_adfbf ,Style :_bafa ,_aacgc :_edaac (_caef ),VerticalAlignment :_dgfg });
};};if len (_effd )> 0{_ggaga ._dbgba =append (_ggaga ._dbgba ,_effd );};return nil ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_dfdcc *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_dfdcc ._gbece =append (_dfdcc ._gbece ,line );return line ;};func (_dbggd *templateProcessor )parseListItem (_cgaa *templateNode )(interface{},error ){if _cgaa ._cafd ==nil {_dbggd .nodeLogError (_cgaa ,"\u004c\u0069\u0073t\u0020\u0069\u0074\u0065m\u0020\u0070\u0061\u0072\u0065\u006e\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_bged ;};_bebd ,_ebb :=_cgaa ._cafd ._cdegg .(*List );if !_ebb {_dbggd .nodeLogError (_cgaa ,"\u004c\u0069s\u0074\u0020\u0069\u0074\u0065\u006d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u004cis\u0074\u002e");
return nil ,_bged ;};_affag :=_dagd ();_affag ._fddae =_bebd ._egebb ;return _affag ,nil ;};

// SetAngle would set the angle at which the gradient is rendered.
//
// The default angle would be 0 where the gradient would be rendered from left to right side.
func (_gcae *LinearShading )SetAngle (angle float64 ){_gcae ._cfbb =angle };

// SetBorderRadius sets the radius of the rectangle corners.
func (_eccdf *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_eccdf ._dffbbb =topLeft ;_eccdf ._gegfb =topRight ;_eccdf ._gagf =bottomLeft ;_eccdf ._cdfe =bottomRight ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_fdge *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_fdec ,_ffed :=_fdge .Wrap (width );if _ffed !=nil {return nil ,_ffed ;};_geede :=int (height /_fdge .Style .FontSize );if _geede >=len (_fdec ){return nil ,nil ;};_cfadf :="\u000a";
_fdge .Text =_bea .Replace (_bea .Join (_fdec [:_geede ],"\u0020"),_cfadf +"\u0020",_cfadf ,-1);_cddg :=_bea .Replace (_bea .Join (_fdec [_geede :],"\u0020"),_cfadf +"\u0020",_cfadf ,-1);return NewTextChunk (_cddg ,_fdge .Style ),nil ;};

// BorderColor returns the border color of the rectangle.
func (_accac *Rectangle )BorderColor ()Color {return _accac ._afcfd };

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// NewFilledCurve returns a instance of filled curve.
func (_acca *Creator )NewFilledCurve ()*FilledCurve {return _efcg ()};

// SetIndent sets the cell's left indent.
func (_abfg *TableCell )SetIndent (indent float64 ){_abfg ._dbafb =indent };

// SetBorderRadius sets the radius of the background corners.
func (_eea *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_eea .BorderRadiusTopLeft =topLeft ;_eea .BorderRadiusTopRight =topRight ;_eea .BorderRadiusBottomLeft =bottomLeft ;_eea .BorderRadiusBottomRight =bottomRight ;
};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ccdbf *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dfcgb :=ctx ;_eaeb ,ctx ,_ddage :=_ccdbf ._ebebg .GeneratePageBlocks (ctx );if _ddage !=nil {return _eaeb ,ctx ,_ddage ;};if _ccdbf ._gefbe .IsRelative (){ctx .X =_dfcgb .X ;
};if _ccdbf ._gefbe .IsAbsolute (){return _eaeb ,_dfcgb ,nil ;};return _eaeb ,ctx ,nil ;};

// SetSubtotal sets the subtotal of the invoice.
func (_cace *Invoice )SetSubtotal (value string ){_cace ._aaaeg [1].Value =value };

// SetBorderColor sets the border color for the path.
func (_dbgc *FilledCurve )SetBorderColor (color Color ){_dbgc ._ffcgd =color };

// SetFillOpacity sets the fill opacity.
func (_egeef *Polygon )SetFillOpacity (opacity float64 ){_egeef ._bafb =opacity };

// NewCell returns a new invoice table cell.
func (_fecgd *Invoice )NewCell (value string )*InvoiceCell {return _fecgd .newCell (value ,_fecgd .NewCellProps ());};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_gdgbde *Table )NewCell ()*TableCell {return _gdgbde .MultiCell (1,1)};

// BorderOpacity returns the border opacity of the ellipse (0-1).
func (_gedb *Ellipse )BorderOpacity ()float64 {return _gedb ._fda };

// GeneratePageBlocks implements drawable interface.
func (_eedd *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_efg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eadb :=_eedd ._fgde ;_ecb :=ctx .PageHeight -_eedd ._dfge ;if _eedd ._aaf !=nil {_cfgf :=_gg .Rectangle {Opacity :1.0,X :_eedd ._fgde ,Y :ctx .PageHeight -_eedd ._dfge -_eedd ._ead ,Height :_eedd ._ead ,Width :_eedd ._cdf };
_cfgf .FillEnabled =true ;_bcg :=_dbceg (_eedd ._aaf );_fbce :=_eecec (_efg ,_bcg ,_eedd ._aaf ,func ()Rectangle {return Rectangle {_edaf :_cfgf .X ,_dgedd :_cfgf .Y ,_dgdba :_cfgf .Width ,_gfef :_cfgf .Height };});if _fbce !=nil {return nil ,ctx ,_fbce ;
};_cfgf .FillColor =_bcg ;_cfgf .BorderEnabled =false ;_aca ,_ ,_fbce :=_cfgf .Draw ("");if _fbce !=nil {return nil ,ctx ,_fbce ;};_fbce =_efg .addContentsByString (string (_aca ));if _fbce !=nil {return nil ,ctx ,_fbce ;};};_ced :=_eedd ._dga ;_cgbb :=_eedd ._fga ;
_cdcb :=_eedd ._afdc ;_gca :=_eedd ._aegf ;_abgc :=_eedd ._dga ;if _eedd ._eed ==CellBorderStyleDouble {_abgc +=2*_ced ;};_eeg :=_eedd ._fga ;if _eedd ._ffe ==CellBorderStyleDouble {_eeg +=2*_cgbb ;};_dcc :=_eedd ._afdc ;if _eedd ._ffcg ==CellBorderStyleDouble {_dcc +=2*_cdcb ;
};_aag :=_eedd ._aegf ;if _eedd ._ebcd ==CellBorderStyleDouble {_aag +=2*_gca ;};_bge :=(_abgc -_dcc )/2;_dged :=(_abgc -_aag )/2;_ggf :=(_eeg -_dcc )/2;_feef :=(_eeg -_aag )/2;if _eedd ._dga !=0{_bgag :=_eadb ;_deba :=_ecb ;if _eedd ._eed ==CellBorderStyleDouble {_deba -=_ced ;
_dgd :=_gg .BasicLine {LineColor :_dbceg (_eedd ._aegb ),Opacity :1.0,LineWidth :_eedd ._dga ,LineStyle :_eedd .LineStyle ,X1 :_bgag -_abgc /2+_bge ,Y1 :_deba +2*_ced ,X2 :_bgag +_abgc /2-_dged +_eedd ._cdf ,Y2 :_deba +2*_ced };_bbf ,_ ,_gggf :=_dgd .Draw ("");
if _gggf !=nil {return nil ,ctx ,_gggf ;};_gggf =_efg .addContentsByString (string (_bbf ));if _gggf !=nil {return nil ,ctx ,_gggf ;};};_gaafd :=_gg .BasicLine {LineWidth :_eedd ._dga ,Opacity :1.0,LineColor :_dbceg (_eedd ._aegb ),LineStyle :_eedd .LineStyle ,X1 :_bgag -_abgc /2+_bge +(_dcc -_eedd ._afdc ),Y1 :_deba ,X2 :_bgag +_abgc /2-_dged +_eedd ._cdf -(_aag -_eedd ._aegf ),Y2 :_deba };
_dca ,_ ,_ffg :=_gaafd .Draw ("");if _ffg !=nil {return nil ,ctx ,_ffg ;};_ffg =_efg .addContentsByString (string (_dca ));if _ffg !=nil {return nil ,ctx ,_ffg ;};};if _eedd ._fga !=0{_efb :=_eadb ;_dgdg :=_ecb -_eedd ._ead ;if _eedd ._ffe ==CellBorderStyleDouble {_dgdg +=_cgbb ;
_gfc :=_gg .BasicLine {LineWidth :_eedd ._fga ,Opacity :1.0,LineColor :_dbceg (_eedd ._febb ),LineStyle :_eedd .LineStyle ,X1 :_efb -_eeg /2+_ggf ,Y1 :_dgdg -2*_cgbb ,X2 :_efb +_eeg /2-_feef +_eedd ._cdf ,Y2 :_dgdg -2*_cgbb };_ffa ,_ ,_agfb :=_gfc .Draw ("");
if _agfb !=nil {return nil ,ctx ,_agfb ;};_agfb =_efg .addContentsByString (string (_ffa ));if _agfb !=nil {return nil ,ctx ,_agfb ;};};_beca :=_gg .BasicLine {LineWidth :_eedd ._fga ,Opacity :1.0,LineColor :_dbceg (_eedd ._febb ),LineStyle :_eedd .LineStyle ,X1 :_efb -_eeg /2+_ggf +(_dcc -_eedd ._afdc ),Y1 :_dgdg ,X2 :_efb +_eeg /2-_feef +_eedd ._cdf -(_aag -_eedd ._aegf ),Y2 :_dgdg };
_fafb ,_ ,_cdab :=_beca .Draw ("");if _cdab !=nil {return nil ,ctx ,_cdab ;};_cdab =_efg .addContentsByString (string (_fafb ));if _cdab !=nil {return nil ,ctx ,_cdab ;};};if _eedd ._afdc !=0{_gded :=_eadb ;_caa :=_ecb ;if _eedd ._ffcg ==CellBorderStyleDouble {_gded +=_cdcb ;
_fadf :=_gg .BasicLine {LineWidth :_eedd ._afdc ,Opacity :1.0,LineColor :_dbceg (_eedd ._dadc ),LineStyle :_eedd .LineStyle ,X1 :_gded -2*_cdcb ,Y1 :_caa +_dcc /2+_bge ,X2 :_gded -2*_cdcb ,Y2 :_caa -_dcc /2-_ggf -_eedd ._ead };_bcb ,_ ,_ddag :=_fadf .Draw ("");
if _ddag !=nil {return nil ,ctx ,_ddag ;};_ddag =_efg .addContentsByString (string (_bcb ));if _ddag !=nil {return nil ,ctx ,_ddag ;};};_bebbg :=_gg .BasicLine {LineWidth :_eedd ._afdc ,Opacity :1.0,LineColor :_dbceg (_eedd ._dadc ),LineStyle :_eedd .LineStyle ,X1 :_gded ,Y1 :_caa +_dcc /2+_bge -(_abgc -_eedd ._dga ),X2 :_gded ,Y2 :_caa -_dcc /2-_ggf -_eedd ._ead +(_eeg -_eedd ._fga )};
_gdad ,_ ,_efgf :=_bebbg .Draw ("");if _efgf !=nil {return nil ,ctx ,_efgf ;};_efgf =_efg .addContentsByString (string (_gdad ));if _efgf !=nil {return nil ,ctx ,_efgf ;};};if _eedd ._aegf !=0{_dccc :=_eadb +_eedd ._cdf ;_aaab :=_ecb ;if _eedd ._ebcd ==CellBorderStyleDouble {_dccc -=_gca ;
_cfb :=_gg .BasicLine {LineWidth :_eedd ._aegf ,Opacity :1.0,LineColor :_dbceg (_eedd ._eag ),LineStyle :_eedd .LineStyle ,X1 :_dccc +2*_gca ,Y1 :_aaab +_aag /2+_dged ,X2 :_dccc +2*_gca ,Y2 :_aaab -_aag /2-_feef -_eedd ._ead };_faeg ,_ ,_efcf :=_cfb .Draw ("");
if _efcf !=nil {return nil ,ctx ,_efcf ;};_efcf =_efg .addContentsByString (string (_faeg ));if _efcf !=nil {return nil ,ctx ,_efcf ;};};_fcd :=_gg .BasicLine {LineWidth :_eedd ._aegf ,Opacity :1.0,LineColor :_dbceg (_eedd ._eag ),LineStyle :_eedd .LineStyle ,X1 :_dccc ,Y1 :_aaab +_aag /2+_dged -(_abgc -_eedd ._dga ),X2 :_dccc ,Y2 :_aaab -_aag /2-_feef -_eedd ._ead +(_eeg -_eedd ._fga )};
_bac ,_ ,_fef :=_fcd .Draw ("");if _fef !=nil {return nil ,ctx ,_fef ;};_fef =_efg .addContentsByString (string (_bac ));if _fef !=nil {return nil ,ctx ,_fef ;};};return []*Block {_efg },ctx ,nil ;};

// SetCoords sets the center coordinates of the ellipse.
func (_dfcg *Ellipse )SetCoords (xc ,yc float64 ){_dfcg ._gac =xc ;_dfcg ._dbcef =yc };func (_cbdc *templateProcessor )parseEllipse (_egffe *templateNode )(interface{},error ){_ebaec :=_cbdc .creator .NewEllipse (0,0,0,0);for _ ,_ecca :=range _egffe ._cggg .Attr {_eebb :=_ecca .Value ;
switch _bcbc :=_ecca .Name .Local ;_bcbc {case "\u0063\u0078":_ebaec ._gac =_cbdc .parseFloatAttr (_bcbc ,_eebb );case "\u0063\u0079":_ebaec ._dbcef =_cbdc .parseFloatAttr (_bcbc ,_eebb );case "\u0077\u0069\u0064t\u0068":_ebaec .SetWidth (_cbdc .parseFloatAttr (_bcbc ,_eebb ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_ebaec .SetHeight (_cbdc .parseFloatAttr (_bcbc ,_eebb ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_ebaec .SetFillColor (_cbdc .parseColorAttr (_bcbc ,_eebb ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_ebaec .SetFillOpacity (_cbdc .parseFloatAttr (_bcbc ,_eebb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_ebaec .SetBorderColor (_cbdc .parseColorAttr (_bcbc ,_eebb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_ebaec .SetBorderOpacity (_cbdc .parseFloatAttr (_bcbc ,_eebb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_ebaec .SetBorderWidth (_cbdc .parseFloatAttr (_bcbc ,_eebb ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_ebaec .SetPositioning (_cbdc .parsePositioningAttr (_bcbc ,_eebb ));
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_ebaec .SetFitMode (_cbdc .parseFitModeAttr (_bcbc ,_eebb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_fdbc :=_cbdc .parseMarginAttr (_bcbc ,_eebb );_ebaec .SetMargins (_fdbc .Left ,_fdbc .Right ,_fdbc .Top ,_fdbc .Bottom );
default:_cbdc .nodeLogDebug (_egffe ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u006c\u0069\u0070\u0073\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_bcbc );
};};return _ebaec ,nil ;};

// SetStyleBottom sets border style for bottom side.
func (_gebg *border )SetStyleBottom (style CellBorderStyle ){_gebg ._ffe =style };

// Columns returns all the columns in the invoice line items table.
func (_cdbd *Invoice )Columns ()[]*InvoiceCell {return _cdbd ._bcdc };

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_face *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_bfbg :=[2]*InvoiceCell {_face .newCell (description ,_face ._daddb ),_face .newCell (value ,_face ._daddb )};_face ._effcg =append (_face ._effcg ,_bfbg );return _bfbg [0],_bfbg [1];
};func (_dgca *templateProcessor )parseChart (_gbef *templateNode )(interface{},error ){var _ceda string ;for _ ,_ddac :=range _gbef ._cggg .Attr {_aceff :=_ddac .Value ;switch _gcfef :=_ddac .Name .Local ;_gcfef {case "\u0073\u0072\u0063":_ceda =_aceff ;
};};if _ceda ==""{_dgca .nodeLogError (_gbef ,"\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_cgfe ;};_accaf ,_fbfba :=_dgca ._bcaf .ChartMap [_ceda ];if !_fbfba {_dgca .nodeLogError (_gbef ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_ceda );
return nil ,_cgfe ;};_cfaf :=NewChart (_accaf );for _ ,_ebagb :=range _gbef ._cggg .Attr {_gfgg :=_ebagb .Value ;switch _fgdac :=_ebagb .Name .Local ;_fgdac {case "\u0078":_cfaf .SetPos (_dgca .parseFloatAttr (_fgdac ,_gfgg ),_cfaf ._afde );case "\u0079":_cfaf .SetPos (_cfaf ._gefb ,_dgca .parseFloatAttr (_fgdac ,_gfgg ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_bgca :=_dgca .parseMarginAttr (_fgdac ,_gfgg );_cfaf .SetMargins (_bgca .Left ,_bgca .Right ,_bgca .Top ,_bgca .Bottom );case "\u0077\u0069\u0064t\u0068":_cfaf ._gegc .SetWidth (int (_dgca .parseFloatAttr (_fgdac ,_gfgg )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_cfaf ._gegc .SetHeight (int (_dgca .parseFloatAttr (_fgdac ,_gfgg )));case "\u0073\u0072\u0063":break ;default:_dgca .nodeLogDebug (_gbef ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_fgdac );
};};return _cfaf ,nil ;};func (_efa rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _efa ._dfgea ,_efa ._eee ,_efa ._ddab };var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };
PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// LineWidth returns the width of the line.
func (_gadbc *Line )LineWidth ()float64 {return _gadbc ._faaeb };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_cbbg *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cbbg ._bgcd .Left ,_cbbg ._bgcd .Right ,_cbbg ._bgcd .Top ,_cbbg ._bgcd .Bottom ;};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_dbgf *Creator )EnableFontSubsetting (font *_gec .PdfFont ){_dbgf ._gff =append (_dbgf ._gff ,font )};type templateProcessor struct{creator *Creator ;_dffeg []byte ;_bcaf *TemplateOptions ;_degea componentRenderer ;_fbbbf string ;};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_dbgb *Creator )SetOptimizer (optimizer _gec .Optimizer ){_dbgb ._cfbf =optimizer };func (_gfec *InvoiceAddress )fmtLine (_ecegg ,_geada string ,_fdfd bool )string {if _fdfd {_geada ="";};return _e .Sprintf ("\u0025\u0073\u0025s\u000a",_geada ,_ecegg );
};

// MoveX moves the drawing context to absolute position x.
func (_abdc *Creator )MoveX (x float64 ){_abdc ._bdfae .X =x };func _daedb (_baaef *templateProcessor ,_acdeg *templateNode )(interface{},error ){return _baaef .parseChapter (_acdeg );};func (_caec *templateProcessor )getNodeErrorLocation (_fdgcfb *templateNode ,_afgef string ,_cfad ...interface{})string {_dedc :=_e .Sprintf (_afgef ,_cfad ...);
_geeb :=_e .Sprintf ("\u0025\u0064",_fdgcfb ._geafg );if _fdgcfb ._caff !=0{_geeb =_e .Sprintf ("\u0025\u0064\u003a%\u0064",_fdgcfb ._caff ,_fdgcfb ._ecfg );};if _caec ._fbbbf !=""{return _e .Sprintf ("\u0025\u0073\u0020\u005b\u0025\u0073\u003a\u0025\u0073\u005d",_dedc ,_caec ._fbbbf ,_geeb );
};return _e .Sprintf ("\u0025s\u0020\u005b\u0025\u0073\u005d",_dedc ,_geeb );};func (_bffbf *templateProcessor )parsePositioningAttr (_gdeba ,_fgdbg string )Positioning {_bd .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gdeba ,_fgdbg );
_dgadb :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_fgdbg ];return _dgadb ;};

// SetAngle sets Image rotation angle in degrees.
func (_gdaa *Image )SetAngle (angle float64 ){_gdaa ._afcf =angle };func (_dbc *Block )addContents (_gcc *_bee .ContentStreamOperations ){_dbc ._efc .WrapIfNeeded ();_gcc .WrapIfNeeded ();*_dbc ._efc =append (*_dbc ._efc ,*_gcc ...);};

// SetLogo sets the logo of the invoice.
func (_cfgc *Invoice )SetLogo (logo *Image ){_cfgc ._ega =logo };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_cfcf *StyledParagraph )SetTextAlignment (align TextAlignment ){_cfcf ._ebcg =align };

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_gcbe *Table )EnablePageWrap (enable bool ){_gcbe ._eddeg =enable };func (_eg *Block )addContentsByString (_gga string )error {_gda :=_bee .NewContentStreamParser (_gga );_dfg ,_fcf :=_gda .Parse ();if _fcf !=nil {return _fcf ;};_eg ._efc .WrapIfNeeded ();
_dfg .WrapIfNeeded ();*_eg ._efc =append (*_eg ._efc ,*_dfg ...);return nil ;};

// Height returns the height of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_gfga *Rectangle )Height ()float64 {return _gfga ._gfef };

// SetFont sets the Paragraph's font.
func (_gdfd *Paragraph )SetFont (font *_gec .PdfFont ){_gdfd ._eged =font };func _dagd ()*listItem {return &listItem {}};

// SetBorderColor sets the border color.
func (_fcga *PolyBezierCurve )SetBorderColor (color Color ){_fcga ._cdaad .BorderColor =_dbceg (color )};

// TitleStyle returns the style properties used to render the invoice title.
func (_efgd *Invoice )TitleStyle ()TextStyle {return _efgd ._baca };type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_bcca Drawable )(Drawable ,error );};func _dbceg (_fdc Color )_gec .PdfColor {if _fdc ==nil {_fdc =ColorBlack ;};switch _effc :=_fdc .(type ){case cmykColor :return _gec .NewPdfColorDeviceCMYK (_effc ._cbe ,_effc ._aacg ,_effc ._cbb ,_effc ._fbcg );
case *LinearShading :return _gec .NewPdfColorPatternType2 ();case *RadialShading :return _gec .NewPdfColorPatternType3 ();};return _gec .NewPdfColorDeviceRGB (_fdc .ToRGB ());};func _fdag (_bgacb ...interface{})(map[string ]interface{},error ){_gbfg :=len (_bgacb );
if _gbfg %2!=0{_bd .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_gbfg );
return nil ,_dc .ErrRangeError ;};_dfbgb :=map[string ]interface{}{};for _afdgf :=0;_afdgf < _gbfg ;_afdgf +=2{_ggcgg ,_cdcf :=_bgacb [_afdgf ].(string );if !_cdcf {_bd .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_bgacb [_afdgf ]);
return nil ,_dc .ErrTypeError ;};_dfbgb [_ggcgg ]=_bgacb [_afdgf +1];};return _dfbgb ,nil ;};

// RadialShading holds information that will be used to render a radial shading.
type RadialShading struct{_ddggc *shading ;_edbfe *_gec .PdfRectangle ;_cgbdg AnchorPoint ;_dbfa float64 ;_edcd float64 ;_dfca float64 ;_eegfe float64 ;};

// SetAnchor set gradient position anchor.
// Default to center.
func (_gdgb *RadialShading )SetAnchor (anchor AnchorPoint ){_gdgb ._cgbdg =anchor };

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_bcc int ;_ccf string ;_aec *Paragraph ;_dcea []Drawable ;_bcbe int ;_dcd bool ;_ggbf bool ;_ggfa Positioning ;_gbbc ,_dfa float64 ;_gebe Margins ;_fbea *Chapter ;_egfa *TOC ;_aed *_gec .Outline ;_geg *_gec .OutlineItem ;_gdd uint ;
};

// SetBorder sets the cell's border style.
func (_fecfd *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_fecfd ._afggg =CellBorderStyleSingle ;_fecfd ._dceac =width ;_fecfd ._bbefe =CellBorderStyleSingle ;
_fecfd ._ecba =width ;_fecfd ._ccdgd =CellBorderStyleSingle ;_fecfd ._degae =width ;_fecfd ._defff =CellBorderStyleSingle ;_fecfd ._bbeee =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_fecfd ._afggg =CellBorderStyleDouble ;
_fecfd ._dceac =width ;_fecfd ._bbefe =CellBorderStyleDouble ;_fecfd ._ecba =width ;_fecfd ._ccdgd =CellBorderStyleDouble ;_fecfd ._degae =width ;_fecfd ._defff =CellBorderStyleDouble ;_fecfd ._bbeee =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_fecfd ._afggg =style ;
_fecfd ._dceac =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_fecfd ._bbefe =style ;_fecfd ._ecba =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_fecfd ._ccdgd =style ;
_fecfd ._degae =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_fecfd ._defff =style ;_fecfd ._bbeee =width ;};};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fbag *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _fbag ._aaaeg [0],_fbag ._aaaeg [1];};

// Positioning returns the type of positioning the line is set to use.
func (_fecc *Line )Positioning ()Positioning {return _fecc ._gecec };

// SetBorderOpacity sets the border opacity of the ellipse.
func (_edcf *Ellipse )SetBorderOpacity (opacity float64 ){_edcf ._fda =opacity };func (_acgd *TableCell )height (_cebf float64 )float64 {var _dadg float64 ;switch _edfg :=_acgd ._cbbec .(type ){case *Paragraph :if _edfg ._bcab {_edfg .SetWidth (_cebf -_acgd ._dbafb -_edfg ._bgcd .Left -_edfg ._bgcd .Right );
};_dadg =_edfg .Height ()+_edfg ._bgcd .Top +_edfg ._bgcd .Bottom ;if !_acgd ._cedbg ._bbef {_dadg +=(0.5*_edfg ._dffb *_edfg ._cdeb );};case *StyledParagraph :if _edfg ._cafa {_edfg .SetWidth (_cebf -_acgd ._dbafb -_edfg ._dfcfg .Left -_edfg ._dfcfg .Right );
};_dadg =_edfg .Height ()+_edfg ._dfcfg .Top +_edfg ._dfcfg .Bottom ;if !_acgd ._cedbg ._bbef {_dadg +=(0.5*_edfg .getTextHeight ());};case *Image :_edfg .applyFitMode (_cebf -_acgd ._dbafb );_dadg =_edfg .Height ()+_edfg ._afgf .Top +_edfg ._afgf .Bottom ;
case *Table :_edfg .updateRowHeights (_cebf -_acgd ._dbafb -_edfg ._degb .Left -_edfg ._degb .Right );_dadg =_edfg .Height ()+_edfg ._degb .Top +_edfg ._degb .Bottom ;case *List :_dadg =_edfg .ctxHeight (_cebf -_acgd ._dbafb )+_edfg ._ebde .Top +_edfg ._ebde .Bottom ;
case *Division :_dadg =_edfg .ctxHeight (_cebf -_acgd ._dbafb )+_edfg ._dedd .Top +_edfg ._dedd .Bottom +_edfg ._gcag .Top +_edfg ._gcag .Bottom ;case *Chart :_dadg =_edfg .Height ()+_edfg ._fgb .Top +_edfg ._fgb .Bottom ;case *Rectangle :_edfg .applyFitMode (_cebf -_acgd ._dbafb );
_dadg =_edfg .Height ()+_edfg ._ebfa .Top +_edfg ._ebfa .Bottom +_edfg ._dacd ;case *Ellipse :_edfg .applyFitMode (_cebf -_acgd ._dbafb );_dadg =_edfg .Height ()+_edfg ._ddcf .Top +_edfg ._ddcf .Bottom ;case *Line :_dadg =_edfg .Height ()+_edfg ._egbc .Top +_edfg ._egbc .Bottom ;
};return _dadg ;};

// Lazy gets the lazy mode for the image.
func (_dddfb *Image )Lazy ()bool {return _dddfb ._aeef };

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_daed *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_daed ._ebaeg =alignment };

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_bgeef *Invoice )SetColumns (cols []*InvoiceCell ){_bgeef ._bcdc =cols };

// SetTitleStyle sets the style properties of the invoice title.
func (_gbee *Invoice )SetTitleStyle (style TextStyle ){_gbee ._baca =style };

// Write output of creator to io.Writer interface.
func (_eddf *Creator )Write (ws _ef .Writer )error {if _ebab :=_eddf .Finalize ();_ebab !=nil {return _ebab ;};_aecbg :=_gec .NewPdfWriter ();_aecbg .SetOptimizer (_eddf ._cfbf );if _eddf ._eeea !=nil {_bed :=_aecbg .SetForms (_eddf ._eeea );if _bed !=nil {_bd .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_bed );
return _bed ;};};if _eddf ._cdcc !=nil {_aecbg .AddOutlineTree (_eddf ._cdcc );}else if _eddf ._aggf !=nil &&_eddf .AddOutlines {_aecbg .AddOutlineTree (&_eddf ._aggf .ToPdfOutline ().PdfOutlineTreeNode );};if _eddf ._babd !=nil {if _ebec :=_aecbg .SetPageLabels (_eddf ._babd );
_ebec !=nil {_bd .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_ebec );return _ebec ;};};if _eddf ._gff !=nil {for _ ,_gcgc :=range _eddf ._gff {_ecbe :=_gcgc .SubsetRegistered ();
if _ecbe !=nil {_bd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_ecbe );return _ecbe ;};};};if _eddf ._dbbd !=nil {_acd :=_eddf ._dbbd (&_aecbg );
if _acd !=nil {_bd .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_acd );return _acd ;};};for _ ,_ffea :=range _eddf ._gage {_aafc :=_aecbg .AddPage (_ffea );if _aafc !=nil {_bd .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_aafc );
return _aafc ;};};_agea :=_aecbg .Write (ws );if _agea !=nil {return _agea ;};return nil ;};

// Scale sets the scale ratio with `X` factor and `Y` factor for the graphic svg.
func (_agbc *GraphicSVG )Scale (xFactor ,yFactor float64 ){_agbc ._bbce .Width =xFactor *_agbc ._bbce .Width ;_agbc ._bbce .Height =yFactor *_agbc ._bbce .Height ;_agbc ._bbce .SetScaling (xFactor ,yFactor );};

// Height returns the height of the line.
func (_geec *Line )Height ()float64 {_fege :=_geec ._faaeb ;if _geec ._cfgae ==_geec ._ccfa {_fege /=2;};return _ag .Abs (_geec ._cfcbb -_geec ._ebf )+_fege ;};

// Lines returns all the lines the table of contents has.
func (_aafgg *TOC )Lines ()[]*TOCLine {return _aafgg ._gbece };func (_aefde *Invoice )generateInformationBlocks (_edec DrawContext )([]*Block ,DrawContext ,error ){_ada :=_bffb (_aefde ._bebbc );_ada .SetMargins (0,0,0,20);_feae :=_aefde .drawAddress (_aefde ._bega );
_feae =append (_feae ,_ada );_feae =append (_feae ,_aefde .drawAddress (_aefde ._egaf )...);_feec :=_gaddc ();for _ ,_fffgd :=range _feae {_feec .Add (_fffgd );};_ecdba :=_aefde .drawInformation ();_eaggd :=_gegcdg (2);_eaggd .SetMargins (0,0,25,0);_ebafg :=_eaggd .NewCell ();
_ebafg .SetIndent (0);_ebafg .SetContent (_feec );_ebafg =_eaggd .NewCell ();_ebafg .SetContent (_ecdba );return _eaggd .GeneratePageBlocks (_edec );};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_bacgg *_gg .Polyline ;_ccde float64 ;};

// Height returns the height of the chart.
func (_ceg *Chart )Height ()float64 {return float64 (_ceg ._gegc .Height ())};func (_gfb cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_bdde :=_gfb ._fbcg ;return 1-(_gfb ._cbe *(1-_bdde )+_bdde ),1-(_gfb ._aacg *(1-_bdde )+_bdde ),1-(_gfb ._cbb *(1-_bdde )+_bdde );
};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// NewList creates a new list.
func (_gdg *Creator )NewList ()*List {return _dedbf (_gdg .NewTextStyle ())};func (_fcffg *TableCell )width (_edbbf []float64 ,_fgfef float64 )float64 {_aacfe :=float64 (0.0);for _gdba :=0;_gdba < _fcffg ._cebg ;_gdba ++{_aacfe +=_edbbf [_fcffg ._dfdfe +_gdba -1];
};return _aacfe *_fgfef ;};

// GeneratePageBlocks draw graphic svg into block.
func (_gaeg *GraphicSVG )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eede :=ctx ;_adb :=_gaeg ._aeag .IsRelative ();var _efec []*Block ;if _adb {_cabd :=1.0;_befe :=_gaeg ._fggef .Top ;if _gaeg ._bbce .Height > ctx .Height -_gaeg ._fggef .Top {_efec =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _gaad error ;if _ ,ctx ,_gaad =_fcbca ().GeneratePageBlocks (ctx );_gaad !=nil {return nil ,ctx ,_gaad ;};_befe =0;};ctx .X +=_gaeg ._fggef .Left +_cabd ;ctx .Y +=_befe ;ctx .Width -=_gaeg ._fggef .Left +_gaeg ._fggef .Right +2*_cabd ;ctx .Height -=_befe ;
}else {ctx .X =_gaeg ._geaaa ;ctx .Y =_gaeg ._gge ;};_eaba :=_bee .NewContentCreator ();_eaba .Translate (0,ctx .PageHeight );_eaba .Scale (1,-1);_eaba .Translate (ctx .X ,ctx .Y );_fddb :=_gaeg ._bbce .Width /_gaeg ._bbce .ViewBox .W ;_fabc :=_gaeg ._bbce .Height /_gaeg ._bbce .ViewBox .H ;
_agff :=0.0;_bce :=0.0;if _adb {_agff =_gaeg ._geaaa -(_gaeg ._bbce .ViewBox .X *_ag .Max (_fddb ,_fabc ));_bce =_gaeg ._gge -(_gaeg ._bbce .ViewBox .Y *_ag .Max (_fddb ,_fabc ));};_gaeg ._bbce .ToContentCreator (_eaba ,_fddb ,_fabc ,_agff ,_bce );_cdb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _bfge :=_cdb .addContentsByString (_eaba .String ());_bfge !=nil {return nil ,ctx ,_bfge ;};if _adb {_dffd :=_gaeg .Height ()+_gaeg ._fggef .Bottom ;ctx .Y +=_dffd ;ctx .Height -=_dffd ;}else {ctx =_eede ;};_efec =append (_efec ,_cdb );return _efec ,ctx ,nil ;
};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_abacg *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_decb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dcccg ,_abga :=_decb .setOpacity (_abacg ._bafb ,_abacg ._cggc );if _abga !=nil {return nil ,ctx ,_abga ;};
_afebg :=_abacg ._efae ;_afebg .FillEnabled =_afebg .FillColor !=nil ;_afebg .BorderEnabled =_afebg .BorderColor !=nil &&_afebg .BorderWidth > 0;_bdeca :=_afebg .Points ;_fcee :=_gec .PdfRectangle {};_edegg :=false ;for _gdgg :=range _bdeca {for _fcgab :=range _bdeca [_gdgg ]{_eafc :=&_bdeca [_gdgg ][_fcgab ];
_eafc .Y =ctx .PageHeight -_eafc .Y ;if !_edegg {_fcee .Llx =_eafc .X ;_fcee .Lly =_eafc .Y ;_fcee .Urx =_eafc .X ;_fcee .Ury =_eafc .Y ;_edegg =true ;}else {_fcee .Llx =_ag .Min (_fcee .Llx ,_eafc .X );_fcee .Lly =_ag .Min (_fcee .Lly ,_eafc .Y );_fcee .Urx =_ag .Max (_fcee .Urx ,_eafc .X );
_fcee .Ury =_ag .Max (_fcee .Ury ,_eafc .Y );};};};if _afebg .FillEnabled {_bbgdb :=_eecec (_decb ,_abacg ._efae .FillColor ,_abacg ._eeed ,func ()Rectangle {return Rectangle {_edaf :_fcee .Llx ,_dgedd :_fcee .Lly ,_dgdba :_fcee .Width (),_gfef :_fcee .Height ()};
});if _bbgdb !=nil {return nil ,ctx ,_bbgdb ;};};_acfc ,_ ,_abga :=_afebg .Draw (_dcccg );if _abga !=nil {return nil ,ctx ,_abga ;};if _abga =_decb .addContentsByString (string (_acfc ));_abga !=nil {return nil ,ctx ,_abga ;};return []*Block {_decb },ctx ,nil ;
};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_dgfbg *LinearShading )AddPatternResource (block *Block )(_bcacb _dc .PdfObjectName ,_ffbd error ){_fbdba :=1;_dcbd :=_dc .PdfObjectName ("\u0050"+_fa .Itoa (_fbdba ));for block ._fb .HasPatternByName (_dcbd ){_fbdba ++;_dcbd =_dc .PdfObjectName ("\u0050"+_fa .Itoa (_fbdba ));
};if _dbea :=block ._fb .SetPatternByName (_dcbd ,_dgfbg .ToPdfShadingPattern ().ToPdfObject ());_dbea !=nil {return "",_dbea ;};return _dcbd ,nil ;};

// SetLineHeight sets the line height (1.0 default).
func (_dbdfd *Paragraph )SetLineHeight (lineheight float64 ){_dbdfd ._cdeb =lineheight };

// NewTOC creates a new table of contents.
func (_bcge *Creator )NewTOC (title string )*TOC {_ace :=_bcge .NewTextStyle ();_ace .Font =_bcge ._bccg ;return _ggfeb (title ,_bcge .NewTextStyle (),_ace );};func (_gafc *Ellipse )applyFitMode (_bgfgb float64 ){_bgfgb -=_gafc ._ddcf .Left +_gafc ._ddcf .Right ;
switch _gafc ._bbcaf {case FitModeFillWidth :_gafc .ScaleToWidth (_bgfgb );};};func (_effdb *templateProcessor )parseListMarker (_bdced *templateNode )(interface{},error ){if _bdced ._cafd ==nil {_effdb .nodeLogError (_bdced ,"\u004c\u0069\u0073\u0074\u0020\u006da\u0072\u006b\u0065\u0072\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0063a\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_bged ;};var _fcaee *TextChunk ;switch _degeg :=_bdced ._cafd ._cdegg .(type ){case *List :_fcaee =&_degeg ._egebb ;case *listItem :_fcaee =&_degeg ._fddae ;default:_effdb .nodeLogError (_bdced ,"\u0025\u0076 \u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0066\u006f\u0072\u0020\u006c\u0069\u0073\u0074\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e",_degeg );
return nil ,_bged ;};if _ ,_gcdbd :=_effdb .parseTextChunk (_bdced ,_fcaee );_gcdbd !=nil {_effdb .nodeLogError (_bdced ,"\u0043\u006f\u0075ld\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072\u0073e\u0020l\u0069s\u0074 \u006d\u0061\u0072\u006b\u0065\u0072\u003a\u0020\u0060\u0025\u0076\u0060\u002e",_gcdbd );
return nil ,nil ;};return _fcaee ,nil ;};func (_dfbde *templateProcessor )parseInt64Array (_bffc ,_ffga string )[]int64 {_bd .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bffc ,_ffga );
_gbag :=_bea .Fields (_ffga );_aggc :=make ([]int64 ,0,len (_gbag ));for _ ,_egea :=range _gbag {_bafad ,_ :=_fa .ParseInt (_egea ,10,64);_aggc =append (_aggc ,_bafad );};return _aggc ;};

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_eddd *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_eddd ._affg =textOverflow };

// SetRowPosition sets cell row position.
func (_cadcbe *TableCell )SetRowPosition (row int ){_cadcbe ._eddfg =row };func _edaac (_feaeg *_gec .PdfAnnotation )*_gec .PdfAnnotation {if _feaeg ==nil {return nil ;};var _fbegg *_gec .PdfAnnotation ;switch _fbfa :=_feaeg .GetContext ().(type ){case *_gec .PdfAnnotationLink :if _gggda :=_eccbea (_fbfa );
_gggda !=nil {_fbegg =_gggda .PdfAnnotation ;};};return _fbegg ;};func _ecgga (_bcffd ,_bacgb ,_eabf string ,_dgfad uint ,_bdgd TextStyle )*TOCLine {return _cdgeb (TextChunk {Text :_bcffd ,Style :_bdgd },TextChunk {Text :_bacgb ,Style :_bdgd },TextChunk {Text :_eabf ,Style :_bdgd },_dgfad ,_bdgd );
};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_dggb *RadialShading )AddPatternResource (block *Block )(_edbe _dc .PdfObjectName ,_bbaf error ){_eaece :=1;_ccbbd :=_dc .PdfObjectName ("\u0050"+_fa .Itoa (_eaece ));for block ._fb .HasPatternByName (_ccbbd ){_eaece ++;_ccbbd =_dc .PdfObjectName ("\u0050"+_fa .Itoa (_eaece ));
};if _bgfa :=block ._fb .SetPatternByName (_ccbbd ,_dggb .ToPdfShadingPattern ().ToPdfObject ());_bgfa !=nil {return "",_bgfa ;};return _ccbbd ,nil ;};

// NewEllipse creates a new ellipse with the center at (`xc`, `yc`),
// having the specified width and height.
// NOTE: In relative positioning mode, `xc` and `yc` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the ellipse is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_fcdbg *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _fgfa (xc ,yc ,width ,height );};const (DefaultHorizontalScaling =100;);

// SetFillOpacity sets the fill opacity of the ellipse.
func (_fgdeb *Ellipse )SetFillOpacity (opacity float64 ){_fgdeb ._gaddb =opacity };

// Height returns the height of the ellipse.
func (_cacf *Ellipse )Height ()float64 {return _cacf ._gaeb };

// GetCoords returns the center coordinates of ellipse (`xc`, `yc`).
func (_cfd *Ellipse )GetCoords ()(float64 ,float64 ){return _cfd ._gac ,_cfd ._dbcef };

// Margins returns the margins of the list: left, right, top, bottom.
func (_adfg *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _adfg ._ebde .Left ,_adfg ._ebde .Right ,_adfg ._ebde .Top ,_adfg ._ebde .Bottom ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_edeg *Invoice )NoteStyle ()TextStyle {return _edeg ._gbff };

// SetRowHeight sets the height for a specified row.
func (_ggddd *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_ggddd ._faga ){return _d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ggddd ._faga [row -1]=h ;return nil ;
};

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_aeagf *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_fcaf []*Block ;_cefc =NewBlock (ctx .PageWidth ,ctx .PageHeight );_cfbd =ctx ;_dgda ,_dbdee =_aeagf ._cfgae ,ctx .PageHeight -_aeagf ._ebf ;_gaafg ,_fbca =_aeagf ._ccfa ,ctx .PageHeight -_aeagf ._cfcbb ;
);_gfff :=_aeagf ._gecec .IsRelative ();if _gfff {ctx .X +=_aeagf ._egbc .Left ;ctx .Y +=_aeagf ._egbc .Top ;ctx .Width -=_aeagf ._egbc .Left +_aeagf ._egbc .Right ;ctx .Height -=_aeagf ._egbc .Top +_aeagf ._egbc .Bottom ;_dgda ,_dbdee ,_gaafg ,_fbca =_aeagf .computeCoords (ctx );
if _aeagf .Height ()> ctx .Height {_fcaf =append (_fcaf ,_cefc );_cefc =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_cedg :=ctx ;_cedg .Y =ctx .Margins .Top +_aeagf ._egbc .Top ;_cedg .X =ctx .Margins .Left +_aeagf ._egbc .Left ;_cedg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_aeagf ._egbc .Top -_aeagf ._egbc .Bottom ;
_cedg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_aeagf ._egbc .Left -_aeagf ._egbc .Right ;ctx =_cedg ;_dgda ,_dbdee ,_gaafg ,_fbca =_aeagf .computeCoords (ctx );};};_ggeb :=_gg .BasicLine {X1 :_dgda ,Y1 :_dbdee ,X2 :_gaafg ,Y2 :_fbca ,LineColor :_dbceg (_aeagf ._bddae ),Opacity :_aeagf ._bceg ,LineWidth :_aeagf ._faaeb ,LineStyle :_aeagf ._ddde ,DashArray :_aeagf ._cgdgd ,DashPhase :_aeagf ._cggede };
_egdb ,_gfbbd :=_cefc .setOpacity (1.0,_aeagf ._bceg );if _gfbbd !=nil {return nil ,ctx ,_gfbbd ;};_efea ,_ ,_gfbbd :=_ggeb .Draw (_egdb );if _gfbbd !=nil {return nil ,ctx ,_gfbbd ;};if _gfbbd =_cefc .addContentsByString (string (_efea ));_gfbbd !=nil {return nil ,ctx ,_gfbbd ;
};if _gfff {ctx .X =_cfbd .X ;ctx .Width =_cfbd .Width ;_adae :=_aeagf .Height ();ctx .Y +=_adae +_aeagf ._egbc .Bottom ;ctx .Height -=_adae ;}else {ctx =_cfbd ;};_fcaf =append (_fcaf ,_cefc );return _fcaf ,ctx ,nil ;};func _dcaef (_fgcfg *templateProcessor ,_cgbag *templateNode )(interface{},error ){return _fgcfg .parseImage (_cgbag );
};

// Opacity returns the opacity of the line.
func (_gdgc *Line )Opacity ()float64 {return _gdgc ._bceg };

// SkipCells skips over a specified number of cells in the table.
func (_gdegg *Table )SkipCells (num int ){if num < 0{_bd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _abef :=0;_abef < num ;_abef ++{_gdegg .NewCell ();};};

// SetSideBorderColor sets the cell's side border color.
func (_ecge *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_ecge ._ageeb =col ;_ecge ._dgbdg =col ;_ecge ._aeab =col ;_ecge ._ceff =col ;case CellBorderSideTop :_ecge ._ageeb =col ;case CellBorderSideBottom :_ecge ._dgbdg =col ;
case CellBorderSideLeft :_ecge ._aeab =col ;case CellBorderSideRight :_ecge ._ceff =col ;};};func _efcg ()*FilledCurve {_eecee :=FilledCurve {};_eecee ._fcbf =[]_gg .CubicBezierCurve {};return &_eecee ;};

// BorderColor returns the border color of the ellipse.
func (_ffgf *Ellipse )BorderColor ()Color {return _ffgf ._dgde };func (_eadbd *templateProcessor )loadImageFromSrc (_egecb string )(*Image ,error ){if _egecb ==""{_bd .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_cgfe ;};_bdgcg :=_bea .Split (_egecb ,"\u002c");for _ ,_ebdad :=range _bdgcg {_ebdad =_bea .TrimSpace (_ebdad );if _ebdad ==""{continue ;};_gdbag ,_gfcga :=_eadbd ._bcaf .ImageMap [_ebdad ];if _gfcga {return _cged (_gdbag );};if _gdceab :=_eadbd .parseAttrPropList (_ebdad );
len (_gdceab )> 0{if _cecb ,_egaab :=_gdceab ["\u0070\u0061\u0074\u0068"];_egaab {if _ffbdcb ,_ddedd :=_dacc (_cecb );_ddedd !=nil {_bd .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_cecb ,_ddedd );
}else {return _ffbdcb ,nil ;};};};};_bd .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_egecb );return nil ,_cgfe ;};func (_bcfgd *templateProcessor )parseChapterHeading (_defg *templateNode )(interface{},error ){if _defg ._cafd ==nil {_bcfgd .nodeLogError (_defg ,"\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_bged ;};_cagg ,_daedd :=_defg ._cafd ._cdegg .(*Chapter );if !_daedd {_bcfgd .nodeLogError (_defg ,"\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_defg ._cafd ._cdegg );
return nil ,_bged ;};_fedgg :=_cagg .GetHeading ();if _ ,_caffg :=_bcfgd .parseParagraph (_defg ,_fedgg );_caffg !=nil {return nil ,_caffg ;};return _fedgg ,nil ;};

// BuyerAddress returns the buyer address used in the invoice template.
func (_aecbe *Invoice )BuyerAddress ()*InvoiceAddress {return _aecbe ._egaf };

// SetLineHeight sets the line height (1.0 default).
func (_aagf *StyledParagraph )SetLineHeight (lineheight float64 ){_aagf ._cdadd =lineheight };

// NewCurvePolygon creates a new curve polygon.
func (_fgcf *Creator )NewCurvePolygon (rings [][]_gg .CubicBezierCurve )*CurvePolygon {return _agb (rings );};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_gbdf *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dcfe :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dbda ,_fbfdf :=_dcfe .setOpacity (_gbdf ._ccde ,_gbdf ._ccde );if _fbfdf !=nil {return nil ,ctx ,_fbfdf ;};
_efagd :=_gbdf ._bacgg .Points ;for _ebeg :=range _efagd {_adef :=&_efagd [_ebeg ];_adef .Y =ctx .PageHeight -_adef .Y ;};_ccfga ,_ ,_fbfdf :=_gbdf ._bacgg .Draw (_dbda );if _fbfdf !=nil {return nil ,ctx ,_fbfdf ;};if _fbfdf =_dcfe .addContentsByString (string (_ccfga ));
_fbfdf !=nil {return nil ,ctx ,_fbfdf ;};return []*Block {_dcfe },ctx ,nil ;};func _edca (_eaaagb string )([]string ,error ){var (_edgec []string ;_geebc []rune ;);for _ ,_degab :=range _eaaagb {if _degab =='\u000A'{if len (_geebc )> 0{_edgec =append (_edgec ,string (_geebc ));
};_edgec =append (_edgec ,string (_degab ));_geebc =nil ;continue ;};_geebc =append (_geebc ,_degab );};if len (_geebc )> 0{_edgec =append (_edgec ,string (_geebc ));};var _cbcea []string ;for _ ,_bfdd :=range _edgec {_gdccb :=[]rune (_bfdd );_gaac :=_ge .NewScanner (_gdccb );
var _cfdee []rune ;for _acdg :=0;_acdg < len (_gdccb );_acdg ++{_ ,_bdba ,_bggcd :=_gaac .Next ();if _bggcd !=nil {return nil ,_bggcd ;};if _bdba ==_ge .BreakProhibited ||_ee .IsSpace (_gdccb [_acdg ]){_cfdee =append (_cfdee ,_gdccb [_acdg ]);if _ee .IsSpace (_gdccb [_acdg ]){_cbcea =append (_cbcea ,string (_cfdee ));
_cfdee =[]rune {};};continue ;}else {if len (_cfdee )> 0{_cbcea =append (_cbcea ,string (_cfdee ));};_cfdee =[]rune {_gdccb [_acdg ]};};};if len (_cfdee )> 0{_cbcea =append (_cbcea ,string (_cfdee ));};};return _cbcea ,nil ;};func (_abab *templateProcessor )parseRectangle (_cbab *templateNode )(interface{},error ){_gdcdf :=_abab .creator .NewRectangle (0,0,0,0);
for _ ,_efbad :=range _cbab ._cggg .Attr {_bbadb :=_efbad .Value ;switch _ceccg :=_efbad .Name .Local ;_ceccg {case "\u0078":_gdcdf ._edaf =_abab .parseFloatAttr (_ceccg ,_bbadb );case "\u0079":_gdcdf ._dgedd =_abab .parseFloatAttr (_ceccg ,_bbadb );case "\u0077\u0069\u0064t\u0068":_gdcdf .SetWidth (_abab .parseFloatAttr (_ceccg ,_bbadb ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_gdcdf .SetHeight (_abab .parseFloatAttr (_ceccg ,_bbadb ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_gdcdf .SetFillColor (_abab .parseColorAttr (_ceccg ,_bbadb ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_gdcdf .SetFillOpacity (_abab .parseFloatAttr (_ceccg ,_bbadb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_gdcdf .SetBorderColor (_abab .parseColorAttr (_ceccg ,_bbadb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_gdcdf .SetBorderOpacity (_abab .parseFloatAttr (_ceccg ,_bbadb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_gdcdf .SetBorderWidth (_abab .parseFloatAttr (_ceccg ,_bbadb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_dffa ,_bdfc ,_dcabf ,_fffc :=_abab .parseBorderRadiusAttr (_ceccg ,_bbadb );
_gdcdf .SetBorderRadius (_dffa ,_bdfc ,_fffc ,_dcabf );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_gdcdf ._dffbbb =_abab .parseFloatAttr (_ceccg ,_bbadb );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_gdcdf ._gegfb =_abab .parseFloatAttr (_ceccg ,_bbadb );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_gdcdf ._gagf =_abab .parseFloatAttr (_ceccg ,_bbadb );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_gdcdf ._cdfe =_abab .parseFloatAttr (_ceccg ,_bbadb );
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_gdcdf .SetPositioning (_abab .parsePositioningAttr (_ceccg ,_bbadb ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_gdcdf .SetFitMode (_abab .parseFitModeAttr (_ceccg ,_bbadb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_acae :=_abab .parseMarginAttr (_ceccg ,_bbadb );
_gdcdf .SetMargins (_acae .Left ,_acae .Right ,_acae .Top ,_acae .Bottom );default:_abab .nodeLogDebug (_cbab ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020re\u0063\u0074\u0061\u006e\u0067\u006ce\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_ceccg );
};};return _gdcdf ,nil ;};func _bcga (_ggdg string )(*GraphicSVG ,error ){_dadd ,_gdcd :=_bfg .ParseFromFile (_ggdg );if _gdcd !=nil {return nil ,_gdcd ;};return _dcdcd (_dadd );};func (_ecfgg *templateProcessor )parseColor (_bfca string )Color {if _bfca ==""{return nil ;
};_bfea ,_fcfba :=_ecfgg ._bcaf .ColorMap [_bfca ];if _fcfba {return _bfea ;};if _bfca [0]=='#'{return ColorRGBFromHex (_bfca );};return nil ;};func (_feace *templateProcessor )nodeLogDebug (_ffad *templateNode ,_bdac string ,_dabca ...interface{}){_bd .Log .Debug (_feace .getNodeErrorLocation (_ffad ,_bdac ,_dabca ...));
};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_aegfg *Table )MultiColCell (colspan int )*TableCell {return _aegfg .MultiCell (1,colspan )};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_baecf rune ;_ddgg []error ;};func (_fbbec *TOCLine )prepareParagraph (_geccdd *StyledParagraph ,_gccg DrawContext ){_abggb :=_fbbec .Title .Text ;if _fbbec .Number .Text !=""{_abggb ="\u0020"+_abggb ;};_abggb +="\u0020";_bgfce :=_fbbec .Page .Text ;
if _bgfce !=""{_bgfce ="\u0020"+_bgfce ;};_geccdd ._acbg =[]*TextChunk {{Text :_fbbec .Number .Text ,Style :_fbbec .Number .Style ,_aacgc :_fbbec .getLineLink ()},{Text :_abggb ,Style :_fbbec .Title .Style ,_aacgc :_fbbec .getLineLink ()},{Text :_bgfce ,Style :_fbbec .Page .Style ,_aacgc :_fbbec .getLineLink ()}};
_geccdd .wrapText ();_geadd :=len (_geccdd ._dbgba );if _geadd ==0{return ;};_egge :=_gccg .Width *1000-_geccdd .getTextLineWidth (_geccdd ._dbgba [_geadd -1]);_ddcgc :=_geccdd .getTextLineWidth ([]*TextChunk {&_fbbec .Separator });_dgece :=int (_egge /_ddcgc );
_cdecg :=_bea .Repeat (_fbbec .Separator .Text ,_dgece );_dgcad :=_fbbec .Separator .Style ;_fgaeb :=_geccdd .Insert (2,_cdecg );_fgaeb .Style =_dgcad ;_fgaeb ._aacgc =_fbbec .getLineLink ();_egge =_egge -float64 (_dgece )*_ddcgc ;if _egge > 500{_ceabc ,_dgdaf :=_dgcad .Font .GetRuneMetrics (' ');
if _dgdaf &&_egge > _ceabc .Wx {_gdbac :=int (_egge /_ceabc .Wx );if _gdbac > 0{_fafcg :=_dgcad ;_fafcg .FontSize =1;_fgaeb =_geccdd .Insert (2,_bea .Repeat ("\u0020",_gdbac ));_fgaeb .Style =_fafcg ;_fgaeb ._aacgc =_fbbec .getLineLink ();};};};};func (_cffce *Creator )newPage ()*_gec .PdfPage {_egcg :=_gec .NewPdfPage ();
_fecg :=_cffce ._fff [0];_dbeb :=_cffce ._fff [1];_fdg :=_gec .PdfRectangle {Llx :0,Lly :0,Urx :_fecg ,Ury :_dbeb };_egcg .MediaBox =&_fdg ;_cffce ._bfe =_fecg ;_cffce ._aae =_dbeb ;_cffce .initContext ();return _egcg ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_bdfff *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_bdfff .Text },nil ;};var _cfada []string ;var _gceda []rune ;var _ageg float64 ;var _caggb []float64 ;_cbad :=_bdfff .Style ;_ggea :=_bacfb (_bdfff .Text );
for _ ,_edeb :=range _bdfff .Text {if _edeb =='\u000A'{_bbbd :=_gadg (string (_gceda ),_ggea );_cfada =append (_cfada ,_bea .TrimRightFunc (_bbbd ,_ee .IsSpace )+string (_edeb ));_gceda =nil ;_ageg =0;_caggb =nil ;continue ;};_fbdgg :=_edeb ==' ';_fabec ,_caaaa :=_cbad .Font .GetRuneMetrics (_edeb );
if !_caaaa {_bd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_edeb ,_edeb ,_cbad .Font .BaseFont (),_cbad .Font .Subtype ());
_bd .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_cbad .Font );_bd .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_cbad .Font .Encoder ());return nil ,_d .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_bddd :=_cbad .FontSize *_fabec .Wx ;_aadda :=_bddd ;if !_fbdgg {_aadda =_bddd +_cbad .CharSpacing *1000.0;};if _ageg +_bddd > width *1000.0{_affe :=-1;if !_fbdgg {for _cgdbd :=len (_gceda )-1;_cgdbd >=0;_cgdbd --{if _gceda [_cgdbd ]==' '{_affe =_cgdbd ;
break ;};};};_cbggd :=string (_gceda );if _affe > 0{_cbggd =string (_gceda [0:_affe +1]);_gceda =append (_gceda [_affe +1:],_edeb );_caggb =append (_caggb [_affe +1:],_aadda );_ageg =0;for _ ,_acfe :=range _caggb {_ageg +=_acfe ;};}else {if _fbdgg {_gceda =[]rune {};
_caggb =[]float64 {};_ageg =0;}else {_gceda =[]rune {_edeb };_caggb =[]float64 {_aadda };_ageg =_aadda ;};};_cbggd =_gadg (_cbggd ,_ggea );_cfada =append (_cfada ,_bea .TrimRightFunc (_cbggd ,_ee .IsSpace ));}else {_gceda =append (_gceda ,_edeb );_ageg +=_aadda ;
_caggb =append (_caggb ,_aadda );};};if len (_gceda )> 0{_dgdab :=string (_gceda );_dgdab =_gadg (_dgdab ,_ggea );_cfada =append (_cfada ,_dgdab );};return _cfada ,nil ;};

// SetPos sets absolute positioning with specified coordinates.
func (_eeaa *Paragraph )SetPos (x ,y float64 ){_eeaa ._dfgb =PositionAbsolute ;_eeaa ._fbeab =x ;_eeaa ._dbec =y ;};func (_eddb *Invoice )generateTotalBlocks (_abacd DrawContext )([]*Block ,DrawContext ,error ){_dcagb :=_gegcdg (4);_dcagb .SetMargins (0,0,10,10);
_adcd :=[][2]*InvoiceCell {_eddb ._aaaeg };_adcd =append (_adcd ,_eddb ._dgfba ...);_adcd =append (_adcd ,_eddb ._fedd );for _ ,_abcg :=range _adcd {_fdee ,_egffg :=_abcg [0],_abcg [1];if _egffg .Value ==""{continue ;};_dcagb .SkipCells (2);_fcebd :=_dcagb .NewCell ();
_fcebd .SetBackgroundColor (_fdee .BackgroundColor );_fcebd .SetHorizontalAlignment (_egffg .Alignment );_eddb .setCellBorder (_fcebd ,_fdee );_bbgd :=_bffb (_fdee .TextStyle );_bbgd .SetMargins (0,0,2,1);_bbgd .Append (_fdee .Value );_fcebd .SetContent (_bbgd );
_fcebd =_dcagb .NewCell ();_fcebd .SetBackgroundColor (_egffg .BackgroundColor );_fcebd .SetHorizontalAlignment (_egffg .Alignment );_eddb .setCellBorder (_fcebd ,_fdee );_bbgd =_bffb (_egffg .TextStyle );_bbgd .SetMargins (0,0,2,1);_bbgd .Append (_egffg .Value );
_fcebd .SetContent (_bbgd );};return _dcagb .GeneratePageBlocks (_abacd );};

// Height returns the height of the graphic svg.
func (_afae *GraphicSVG )Height ()float64 {return _afae ._bbce .Height };

// Vertical returns total vertical (top + bottom) margin.
func (_bdedf *Margins )Vertical ()float64 {return _bdedf .Bottom +_bdedf .Top };

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// SetBorderWidth sets the border width.
func (_fbgb *CurvePolygon )SetBorderWidth (borderWidth float64 ){_fbgb ._cecf .BorderWidth =borderWidth };func _dedbf (_dceag TextStyle )*List {return &List {_egebb :TextChunk {Text :"\u2022\u0020",Style :_dceag },_ecfe :0,_debeb :true ,_bbgaa :PositionRelative ,_gfag :_dceag };
};

// Height returns the total height of all rows.
func (_bfbfa *Table )Height ()float64 {_dbdgg :=float64 (0.0);for _ ,_fcdd :=range _bfbfa ._faga {_dbdgg +=_fcdd ;};return _dbdgg ;};

// Scale block by specified factors in the x and y directions.
func (_gag *Block )Scale (sx ,sy float64 ){_cacd :=_bee .NewContentCreator ().Scale (sx ,sy ).Operations ();*_gag ._efc =append (*_cacd ,*_gag ._efc ...);_gag ._efc .WrapIfNeeded ();_gag ._bb *=sx ;_gag ._df *=sy ;};

// SetMargins sets the margins TOC line.
func (_gaagg *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_gaagg ._cbaed =left ;_bddac :=&_gaagg ._ebebg ._dfcfg ;_bddac .Left =_gaagg ._cbaed +float64 (_gaagg ._aabgg -1)*_gaagg ._debg ;_bddac .Right =right ;_bddac .Top =top ;_bddac .Bottom =bottom ;
};

// SetBorderColor sets the cell's border color.
func (_egef *TableCell )SetBorderColor (col Color ){_egef ._aeab =col ;_egef ._dgbdg =col ;_egef ._ceff =col ;_egef ._ageeb =col ;};

// SetOpacity sets opacity for Image.
func (_ccbcd *Image )SetOpacity (opacity float64 ){_ccbcd ._abgdb =opacity };

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_ebg *Block )Draw (d Drawable )error {_geda :=DrawContext {};_geda .Width =_ebg ._bb ;_geda .Height =_ebg ._df ;_geda .PageWidth =_ebg ._bb ;_geda .PageHeight =_ebg ._df ;_geda .X =0;_geda .Y =0;_ce ,_ ,_gf :=d .GeneratePageBlocks (_geda );if _gf !=nil {return _gf ;
};if len (_ce )!=1{return ErrContentNotFit ;};for _ ,_aee :=range _ce {if _fbfc :=_ebg .mergeBlocks (_aee );_fbfc !=nil {return _fbfc ;};};return nil ;};

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_cee *Division )SetPadding (left ,right ,top ,bottom float64 ){_cee ._gcag .Left =left ;_cee ._gcag .Right =right ;_cee ._gcag .Top =top ;_cee ._gcag .Bottom =bottom ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_gafga *Invoice )SetTerms (title ,content string ){_gafga ._fcgg =[2]string {title ,content }};func (_feg *Block )transform (_bcd _ea .Matrix ){_cda :=_bee .NewContentCreator ().Add_cm (_bcd [0],_bcd [1],_bcd [3],_bcd [4],_bcd [6],_bcd [7]).Operations ();
*_feg ._efc =append (*_cda ,*_feg ._efc ...);_feg ._efc .WrapIfNeeded ();};

// Positioning returns the type of positioning the rectangle is set to use.
func (_dgegc *Rectangle )Positioning ()Positioning {return _dgegc ._dbaf };

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_cadcb *Creator )PageFinalize (pageFinalizeFunc func (_afaf PageFinalizeFunctionArgs )error ){_cadcb ._ecgd =pageFinalizeFunc ;};

// List represents a list of items.
// The representation of a list item is as follows:
//
//	[marker] [content]
//
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_eacg []*listItem ;_ebde Margins ;_egebb TextChunk ;_ecfe float64 ;_debeb bool ;_bbgaa Positioning ;_gfag TextStyle ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_debbc *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_bebe :=_bffb (_debbc ._gfag );_bebe .Append (text );_eaee ,_fefb :=_debbc .Add (_bebe );return _bebe ,_eaee ,_fefb ;};func (_abde *listItem )ctxHeight (_febg float64 )float64 {var _adea float64 ;
switch _edce :=_abde ._bdbgb .(type ){case *Paragraph :if _edce ._bcab {_edce .SetWidth (_febg -_edce ._bgcd .Horizontal ());};_adea =_edce .Height ()+_edce ._bgcd .Vertical ();_adea +=0.5*_edce ._dffb *_edce ._cdeb ;case *StyledParagraph :if _edce ._cafa {_edce .SetWidth (_febg -_edce ._dfcfg .Horizontal ());
};_adea =_edce .Height ()+_edce ._dfcfg .Vertical ();_adea +=0.5*_edce .getTextHeight ();case *List :_bdgfc :=_febg -_abde ._fddae .Width ()-_edce ._ebde .Horizontal ()-_edce ._ecfe ;_adea =_edce .ctxHeight (_bdgfc )+_edce ._ebde .Vertical ();case *Image :_adea =_edce .Height ()+_edce ._afgf .Vertical ();
case *Division :_ffafd :=_febg -_abde ._fddae .Width ()-_edce ._dedd .Horizontal ();_adea =_edce .ctxHeight (_ffafd )+_edce ._dedd .Vertical ();case *Table :_ggga :=_febg -_abde ._fddae .Width ()-_edce ._degb .Horizontal ();_edce .updateRowHeights (_ggga );
_adea =_edce .Height ()+_edce ._degb .Vertical ();default:_adea =_abde ._bdbgb .Height ();};return _adea ;};

// SetMargins sets the Paragraph's margins.
func (_adca *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_adca ._bgcd .Left =left ;_adca ._bgcd .Right =right ;_adca ._bgcd .Top =top ;_adca ._bgcd .Bottom =bottom ;};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _deac ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_dgab :=&Creator {};_dgab ._gage =[]*_gec .PdfPage {};_dgab ._gggc =map[*_gec .PdfPage ]*Block {};_dgab ._eabc =map[*_gec .PdfPage ]*pageTransformations {};
_dgab .SetPageSize (PageSizeLetter );_bfa :=0.1*_dgab ._bfe ;_dgab ._bag .Left =_bfa ;_dgab ._bag .Right =_bfa ;_dgab ._bag .Top =_bfa ;_dgab ._bag .Bottom =_bfa ;var _aefd error ;_dgab ._dgaf ,_aefd =_gec .NewStandard14Font (_gec .HelveticaName );if _aefd !=nil {_dgab ._dgaf =_gec .DefaultFont ();
};_dgab ._bccg ,_aefd =_gec .NewStandard14Font (_gec .HelveticaBoldName );if _aefd !=nil {_dgab ._dgaf =_gec .DefaultFont ();};_dgab ._fed =_dgab .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");
_dgab .AddOutlines =true ;_dgab ._aggf =_gec .NewOutline ();_ggb .TrackUse (_deac );return _dgab ;};const (PositionRelative Positioning =iota ;PositionAbsolute ;);

// SetIndent sets the left offset of the list when nested into another list.
func (_cgdc *List )SetIndent (indent float64 ){_cgdc ._ecfe =indent ;_cgdc ._debeb =false };

// Width returns the width of the specified text chunk.
func (_decdb *TextChunk )Width ()float64 {var (_gcda float64 ;_aggbdg =_decdb .Style ;);for _ ,_cbcee :=range _decdb .Text {_fabbda ,_aadff :=_aggbdg .Font .GetRuneMetrics (_cbcee );if !_aadff {_bd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_cbcee ,_cbcee ,_aggbdg .Font .BaseFont (),_aggbdg .Font .Subtype ());
_bd .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_aggbdg .Font );_bd .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_aggbdg .Font .Encoder ());};_cfgcg :=_aggbdg .FontSize *_fabbda .Wx ;_gacg :=_cfgcg ;
if _cbcee !=' '{_gacg =_cfgcg +_aggbdg .CharSpacing *1000.0;};_gcda +=_gacg ;};return _gcda /1000.0;};

// SetBorderColor sets the border color of the ellipse.
func (_aggfd *Ellipse )SetBorderColor (col Color ){_aggfd ._dgde =col };

// AppendCurve appends a Bezier curve to the filled curve.
func (_cdgd *FilledCurve )AppendCurve (curve _gg .CubicBezierCurve )*FilledCurve {_cdgd ._fcbf =append (_cdgd ._fcbf ,curve );return _cdgd ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_adgaf *Paragraph )SetEnableWrap (enableWrap bool ){_adgaf ._bcab =enableWrap ;_adgaf ._fffec =false ;};func _gegcdg (_fgbb int )*Table {_fcgce :=&Table {_acgc :_fgbb ,_eagc :10.0,_fgdb :[]float64 {},_faga :[]float64 {},_dabec :[]*TableCell {},_afabg :make ([]int ,_fgbb ),_eddeg :true };
_fcgce .resetColumnWidths ();return _fcgce ;};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;TextVerticalAlignmentBottom ;TextVerticalAlignmentTop ;);

// SetLazy sets the lazy mode for the image.
func (_agbd *Image )SetLazy (lazy bool ){_agbd ._aeef =lazy };func _fafba (_eedfc VectorDrawable ,_gaff float64 )float64 {switch _gfab :=_eedfc .(type ){case *Paragraph :if _gfab ._bcab {_gfab .SetWidth (_gaff -_gfab ._bgcd .Left -_gfab ._bgcd .Right );
};return _gfab .Height ()+_gfab ._bgcd .Top +_gfab ._bgcd .Bottom ;case *StyledParagraph :if _gfab ._cafa {_gfab .SetWidth (_gaff -_gfab ._dfcfg .Left -_gfab ._dfcfg .Right );};return _gfab .Height ()+_gfab ._dfcfg .Top +_gfab ._dfcfg .Bottom ;case *Image :_gfab .applyFitMode (_gaff );
return _gfab .Height ()+_gfab ._afgf .Top +_gfab ._afgf .Bottom ;case *Rectangle :_gfab .applyFitMode (_gaff );return _gfab .Height ()+_gfab ._ebfa .Top +_gfab ._ebfa .Bottom +_gfab ._dacd ;case *Ellipse :_gfab .applyFitMode (_gaff );return _gfab .Height ()+_gfab ._ddcf .Top +_gfab ._ddcf .Bottom ;
case *Division :return _gfab .ctxHeight (_gaff )+_gfab ._dedd .Top +_gfab ._dedd .Bottom +_gfab ._gcag .Top +_gfab ._gcag .Bottom ;case *Table :_gfab .updateRowHeights (_gaff -_gfab ._degb .Left -_gfab ._degb .Right );return _gfab .Height ()+_gfab ._degb .Top +_gfab ._degb .Bottom ;
case *List :return _gfab .ctxHeight (_gaff )+_gfab ._ebde .Top +_gfab ._ebde .Bottom ;case marginDrawable :_ ,_ ,_ecea ,_gagc :=_gfab .GetMargins ();return _gfab .Height ()+_ecea +_gagc ;default:return _gfab .Height ();};};

// Indent returns the left offset of the list when nested into another list.
func (_ccfbd *List )Indent ()float64 {return _ccfbd ._ecfe };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};func _fabd (_gfdef float64 ,_agaab float64 )float64 {return _ag .Round (_gfdef /_agaab )*_agaab };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_bgafc *TOC )SetHeading (text string ,style TextStyle ){_bfcb :=_bgafc .Heading ();_bfcb .Reset ();_fbfff :=_bfcb .Append (text );_fbfff .Style =style ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_gafd *Invoice )AddressStyle ()TextStyle {return _gafd ._accd };

// Crop crops the Image to the specified bounds.
func (_bbcb *Image )Crop (x0 ,y0 ,x1 ,y1 int ){_dfcf ,_eaea :=_bbcb ._adgg .ToGoImage ();if _eaea !=nil {_be .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0074o\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_eaea );
};var _begfc _cc .Image ;_feade :=_cc .Rect (x0 ,y0 ,x1 ,y1 );if _dgabc :=_feade .Intersect (_dfcf .Bounds ());!_feade .Empty (){_bdef :=_cc .NewRGBA (_cc .Rect (0,0,_feade .Dx (),_feade .Dy ()));for _edbf :=_dgabc .Min .Y ;_edbf < _dgabc .Max .Y ;_edbf ++{for _cfag :=_dgabc .Min .X ;
_cfag < _dgabc .Max .X ;_cfag ++{_bdef .Set (_cfag -_dgabc .Min .X ,_edbf -_dgabc .Min .Y ,_dfcf .At (_cfag ,_edbf ));};};_begfc =_bdef ;}else {_begfc =&_cc .RGBA {};};_bddea ,_eaea :=_gec .ImageHandling .NewImageFromGoImage (_begfc );if _eaea !=nil {_be .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0066\u0072\u006fm\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_eaea );
};_ecdb :=float64 (_bddea .Width );_edge :=float64 (_bddea .Height );_bbcb ._adgg =_bddea ;_bbcb ._cbfd =_ecdb ;_bbcb ._gegfd =_edge ;_bbcb ._bdebc =_ecdb ;_bbcb ._eaec =_edge ;};

// Width returns the width of the Paragraph.
func (_eedda *Paragraph )Width ()float64 {if _eedda ._bcab &&int (_eedda ._abcd )> 0{return _eedda ._abcd ;};return _eedda .getTextWidth ()/1000.0;};

// NewSubchapter creates a new child chapter with the specified title.
func (_dbe *Chapter )NewSubchapter (title string )*Chapter {_cgf :=_gbcg (_dbe ._aec ._eged );_cgf .FontSize =14;_dbe ._bcbe ++;_bdfg :=_cgd (_dbe ,_dbe ._egfa ,_dbe ._aed ,title ,_dbe ._bcbe ,_cgf );_dbe .Add (_bdfg );return _bdfg ;};

// NewCellProps returns the default properties of an invoice cell.
func (_aacd *Invoice )NewCellProps ()InvoiceCellProps {_cgebb :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_aacd ._bebbc ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_cgebb ,BorderColor :_cgebb ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};func _dbaaa (_aafdb *templateProcessor ,_gacb *templateNode )(interface{},error ){return _aafdb .parseEllipse (_gacb );};

// CreateTableOfContents sets a function to generate table of contents.
func (_bcae *Creator )CreateTableOfContents (genTOCFunc func (_eca *TOC )error ){_bcae ._dfed =genTOCFunc ;};func _ccba (_fccgg *templateProcessor ,_fdfc *templateNode )(interface{},error ){return _fccgg .parseTableCell (_fdfc );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bbcab *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _eeceed float64 ;var _aagda []*StyledParagraph ;for _ ,_dega :=range _bbcab ._eacg {_fafae :=_bffb (_bbcab ._gfag );_fafae .SetEnableWrap (false );_fafae .SetTextAlignment (TextAlignmentRight );
_fafae .Append (_dega ._fddae .Text ).Style =_dega ._fddae .Style ;_abgca :=_fafae .getTextWidth ()/1000.0/ctx .Width ;if _eeceed < _abgca {_eeceed =_abgca ;};_aagda =append (_aagda ,_fafae );};_deffb :=_gegcdg (2);_deffb .SetColumnWidths (_eeceed ,1-_eeceed );
_deffb .SetMargins (_bbcab ._ebde .Left +_bbcab ._ecfe ,_bbcab ._ebde .Right ,_bbcab ._ebde .Top ,_bbcab ._ebde .Bottom );_deffb .EnableRowWrap (true );for _fefc ,_badef :=range _bbcab ._eacg {_dgafe :=_deffb .NewCell ();_dgafe .SetIndent (0);_dgafe .SetContent (_aagda [_fefc ]);
_dgafe =_deffb .NewCell ();_dgafe .SetIndent (0);_dgafe .SetContent (_badef ._bdbgb );};return _deffb .GeneratePageBlocks (ctx );};func (_feee *Creator )getActivePage ()*_gec .PdfPage {if _feee ._cgc ==nil {if len (_feee ._gage )==0{return nil ;};return _feee ._gage [len (_feee ._gage )-1];
};return _feee ._cgc ;};

// SetCoords sets the upper left corner coordinates of the rectangle.
func (_aefcg *Rectangle )SetCoords (x ,y float64 ){_aefcg ._edaf =x ;_aefcg ._dgedd =y };

// SetNumber sets the number of the invoice.
func (_gdge *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_gdge ._bebc [1].Value =number ;return _gdge ._bebc [0],_gdge ._bebc [1];};func (_cfaga *templateProcessor )parseTextRenderingModeAttr (_aedg ,_gcdca string )TextRenderingMode {_bd .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_aedg ,_gcdca );
_abdbd :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_gcdca ];
return _abdbd ;};

// CurCol returns the currently active cell's column number.
func (_cabgg *Table )CurCol ()int {_gedfd :=(_cabgg ._faaef -1)%(_cabgg ._acgc )+1;return _gedfd };func _ecdc (_egdf *Block ,_bgaec *Image ,_dcgb DrawContext )(DrawContext ,error ){_bddee :=_dcgb ;_dabbd :=1;_egfc :=_dc .PdfObjectName (_e .Sprintf ("\u0049\u006d\u0067%\u0064",_dabbd ));
for _egdf ._fb .HasXObjectByName (_egfc ){_dabbd ++;_egfc =_dc .PdfObjectName (_e .Sprintf ("\u0049\u006d\u0067%\u0064",_dabbd ));};_bfda :=_egdf ._fb .SetXObjectImageByNameLazy (_egfc ,_bgaec ._dccf ,_bgaec ._aeef );if _bfda !=nil {return _dcgb ,_bfda ;
};_cbd :=0;_ddcc :=_dc .PdfObjectName (_e .Sprintf ("\u0047\u0053\u0025\u0064",_cbd ));for _egdf ._fb .HasExtGState (_ddcc ){_cbd ++;_ddcc =_dc .PdfObjectName (_e .Sprintf ("\u0047\u0053\u0025\u0064",_cbd ));};_fgfe :=_dc .MakeDict ();_fgfe .Set ("\u0042\u004d",_dc .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));
if _bgaec ._abgdb < 1.0{_fgfe .Set ("\u0043\u0041",_dc .MakeFloat (_bgaec ._abgdb ));_fgfe .Set ("\u0063\u0061",_dc .MakeFloat (_bgaec ._abgdb ));};_bfda =_egdf ._fb .AddExtGState (_ddcc ,_dc .MakeIndirectObject (_fgfe ));if _bfda !=nil {return _dcgb ,_bfda ;
};_cfgfc :=_bgaec .Width ();_gbe :=_bgaec .Height ();_ ,_ddgc :=_bgaec .rotatedSize ();_cfgg :=_dcgb .X ;_acec :=_dcgb .PageHeight -_dcgb .Y -_gbe ;if _bgaec ._acde .IsRelative (){_acec -=(_ddgc -_gbe )/2;switch _bgaec ._ebaeg {case HorizontalAlignmentCenter :_cfgg +=(_dcgb .Width -_cfgfc )/2;
case HorizontalAlignmentRight :_cfgg =_dcgb .PageWidth -_dcgb .Margins .Right -_bgaec ._afgf .Right -_cfgfc ;};};_edf :=_bgaec ._afcf ;_egda :=_bee .NewContentCreator ();_egda .Add_gs (_ddcc );_egda .Translate (_cfgg ,_acec );if _edf !=0{_egda .Translate (_cfgfc /2,_gbe /2);
_egda .RotateDeg (_edf );_egda .Translate (-_cfgfc /2,-_gbe /2);};_egda .Scale (_cfgfc ,_gbe ).Add_Do (_egfc );_bbbc :=_egda .Operations ();_bbbc .WrapIfNeeded ();_egdf .addContents (_bbbc );if _bgaec ._acde .IsRelative (){_dcgb .Y +=_ddgc ;_dcgb .Height -=_ddgc ;
return _dcgb ,nil ;};return _bddee ,nil ;};

// SetBorderColor sets border color of the rectangle.
func (_bcage *Rectangle )SetBorderColor (col Color ){_bcage ._afcfd =col };func _ddcag (_dbfcd *templateProcessor ,_bbgc *templateNode )(interface{},error ){return _dbfcd .parseChapterHeading (_bbgc );};

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_ccca *Line )Width ()float64 {return _ag .Abs (_ccca ._ccfa -_ccca ._cfgae )};

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_acecd *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _acecd ._egbc .Left ,_acecd ._egbc .Right ,_acecd ._egbc .Top ,_acecd ._egbc .Bottom ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_fcdfc *Creator )NewTextStyle ()TextStyle {return _gbcg (_fcdfc ._dgaf )};

// AddColorStop add color stop information for rendering gradient.
func (_cece *shading )AddColorStop (color Color ,point float64 ){_cece ._cbgef =append (_cece ._cbgef ,_egga (color ,point ));};

// FitMode returns the fit mode of the line.
func (_ddgf *Line )FitMode ()FitMode {return _ddgf ._dabe };

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_cecfc *Division )EnablePageWrap (enable bool ){_cecfc ._ecd =enable };

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_baee *Creator )SetForms (form *_gec .PdfAcroForm )error {_baee ._eeea =form ;return nil };

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_dcce *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _cdgeb (number ,title ,page ,level ,style );};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_aebad *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ccdab :=_aebad ;if _aebad ._bfec {_ccdab =_aebad .clone ();};return _dggga (_ccdab ,ctx );};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_eceaa *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_ffeaa :=NewTextChunk (text ,_eceaa ._dffcf );_ffeaa ._aacgc =_acge (url );return _eceaa .appendChunk (_ffeaa );};func _gadg (_abeeed string ,_geef bool )string {_baeff :=_abeeed ;
if _baeff ==""{return "";};_ebcfg :=_da .Paragraph {};_ ,_bbfbg :=_ebcfg .SetString (_abeeed );if _bbfbg !=nil {return _baeff ;};_efdgdg ,_bbfbg :=_ebcfg .Order ();if _bbfbg !=nil {return _baeff ;};_eaefg :=_efdgdg .NumRuns ();_abfbe :=make ([]string ,_eaefg );
for _feaa :=0;_feaa < _efdgdg .NumRuns ();_feaa ++{_bccf :=_efdgdg .Run (_feaa );_fegbd :=_bccf .String ();if _bccf .Direction ()==_da .RightToLeft {_fegbd =_da .ReverseString (_fegbd );};if _geef {_abfbe [_feaa ]=_fegbd ;}else {_abfbe [_eaefg -1]=_fegbd ;
};_eaefg --;};if len (_abfbe )!=_efdgdg .NumRuns (){return _abeeed ;};_baeff =_bea .Join (_abfbe ,"");return _baeff ;};func _cgd (_fcc *Chapter ,_daef *TOC ,_geee *_gec .Outline ,_fceb string ,_bgae int ,_gab TextStyle )*Chapter {var _bbe uint =1;if _fcc !=nil {_bbe =_fcc ._gdd +1;
};_gdeb :=&Chapter {_bcc :_bgae ,_ccf :_fceb ,_dcd :true ,_ggbf :true ,_fbea :_fcc ,_egfa :_daef ,_aed :_geee ,_dcea :[]Drawable {},_gdd :_bbe };_ebe :=_daac (_gdeb .headingText (),_gab );_ebe .SetFont (_gab .Font );_ebe .SetFontSize (_gab .FontSize );
_gdeb ._aec =_ebe ;return _gdeb ;};

// SetMargins sets the margins of the ellipse.
// NOTE: ellipse margins are only applied if relative positioning is used.
func (_adcg *Ellipse )SetMargins (left ,right ,top ,bottom float64 ){_adcg ._ddcf .Left =left ;_adcg ._ddcf .Right =right ;_adcg ._ddcf .Top =top ;_adcg ._ddcf .Bottom =bottom ;};func (_dbgab *StyledParagraph )getTextHeight ()float64 {var _baef float64 ;
for _ ,_faagc :=range _dbgab ._acbg {_faeec :=_faagc .Style .FontSize *_dbgab ._cdadd ;if _faeec > _baef {_baef =_faeec ;};};return _baef ;};

// SetFillColor sets background color for border.
func (_dbb *border )SetFillColor (col Color ){_dbb ._aaf =col };

// Padding returns the padding of the component.
func (_eddc *Division )Padding ()(_dabb ,_dba ,_aafd ,_abgf float64 ){return _eddc ._gcag .Left ,_eddc ._gcag .Right ,_eddc ._gcag .Top ,_eddc ._gcag .Bottom ;};func (_aadb *templateProcessor )nodeError (_decaa *templateNode ,_efcb string ,_cdae ...interface{})error {return _e .Errorf (_aadb .getNodeErrorLocation (_decaa ,_efcb ,_cdae ...));
};func (_eaab *templateProcessor )parseMarginAttr (_fdab ,_ddefd string )Margins {_bd .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_fdab ,_ddefd );
_dabg :=Margins {};switch _bfdg :=_bea .Fields (_ddefd );len (_bfdg ){case 1:_dabg .Top ,_ =_fa .ParseFloat (_bfdg [0],64);_dabg .Bottom =_dabg .Top ;_dabg .Left =_dabg .Top ;_dabg .Right =_dabg .Top ;case 2:_dabg .Top ,_ =_fa .ParseFloat (_bfdg [0],64);
_dabg .Bottom =_dabg .Top ;_dabg .Left ,_ =_fa .ParseFloat (_bfdg [1],64);_dabg .Right =_dabg .Left ;case 3:_dabg .Top ,_ =_fa .ParseFloat (_bfdg [0],64);_dabg .Left ,_ =_fa .ParseFloat (_bfdg [1],64);_dabg .Right =_dabg .Left ;_dabg .Bottom ,_ =_fa .ParseFloat (_bfdg [2],64);
case 4:_dabg .Top ,_ =_fa .ParseFloat (_bfdg [0],64);_dabg .Right ,_ =_fa .ParseFloat (_bfdg [1],64);_dabg .Bottom ,_ =_fa .ParseFloat (_bfdg [2],64);_dabg .Left ,_ =_fa .ParseFloat (_bfdg [3],64);};return _dabg ;};

// DashPattern returns the dash pattern of the line.
func (_geaff *Line )DashPattern ()(_cdbc []int64 ,_fbee int64 ){return _geaff ._cgdgd ,_geaff ._cggede };func _bceed (_bbaaf *templateProcessor ,_edfb *templateNode )(interface{},error ){return _bbaaf .parsePageBreak (_edfb );};

// SetStyleLeft sets border style for left side.
func (_geed *border )SetStyleLeft (style CellBorderStyle ){_geed ._ffcg =style };

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// SetBorderOpacity sets the border opacity.
func (_aage *Polygon )SetBorderOpacity (opacity float64 ){_aage ._cggc =opacity };func (_eddce *Image )applyFitMode (_egbd float64 ){_egbd -=_eddce ._afgf .Left +_eddce ._afgf .Right ;switch _eddce ._ade {case FitModeFillWidth :_eddce .ScaleToWidth (_egbd );
};};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};func _fcbdb (_cccce float64 ,_bdfba int )float64 {_ddae :=_ag .Pow10 (_bdfba );return _ag .Round (_ddae *_cccce )/_ddae ;};

// BorderWidth returns the border width of the ellipse.
func (_bdaa *Ellipse )BorderWidth ()float64 {return _bdaa ._eagd };

// Notes returns the notes section of the invoice as a title-content pair.
func (_eaaa *Invoice )Notes ()(string ,string ){return _eaaa ._efed [0],_eaaa ._efed [1]};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_degd *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_degd ._adgeg =valign };

// InsertColumn inserts a column in the line items table at the specified index.
func (_gecee *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_agaa :=uint (len (_gecee ._bcdc ));if index > _agaa {index =_agaa ;};_eddae :=_gecee .NewColumn (description );_gecee ._bcdc =append (_gecee ._bcdc [:index ],append ([]*InvoiceCell {_eddae },_gecee ._bcdc [index :]...)...);
return _eddae ;};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_ged *Block )ScaleToWidth (w float64 ){_ggaa :=w /_ged ._bb ;_ged .Scale (_ggaa ,_ggaa )};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_fefgb *RadialShading )SetAntiAlias (enable bool ){_fefgb ._ddggc .SetAntiAlias (enable )};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};func _bacfb (_fabgga string )bool {_dgggag :=func (_dfba rune )bool {return _dfba =='\u000A'};_eeeb :=_bea .TrimFunc (_fabgga ,_dgggag );_agfg :=_da .Paragraph {};_ ,_cggb :=_agfg .SetString (_eeeb );if _cggb !=nil {return true ;};
_dbeae ,_cggb :=_agfg .Order ();if _cggb !=nil {return true ;};if _dbeae .NumRuns ()< 1{return true ;};return _agfg .IsLeftToRight ();};

// SetFitMode sets the fit mode of the ellipse.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_bgff *Ellipse )SetFitMode (fitMode FitMode ){_bgff ._bbcaf =fitMode };

// AddColorStop add color stop info for rendering gradient color.
func (_fafe *RadialShading )AddColorStop (color Color ,point float64 ){_fafe ._ddggc .AddColorStop (color ,point );};func (_gdcgf *templateProcessor )parsePageBreak (_gabf *templateNode )(interface{},error ){return _fcbca (),nil ;};

// Invoice represents a configurable invoice template.
type Invoice struct{_gfeg string ;_ega *Image ;_egaf *InvoiceAddress ;_bega *InvoiceAddress ;_adec string ;_bebc [2]*InvoiceCell ;_gbdb [2]*InvoiceCell ;_gefg [2]*InvoiceCell ;_effcg [][2]*InvoiceCell ;_bcdc []*InvoiceCell ;_cbcg [][]*InvoiceCell ;_aaaeg [2]*InvoiceCell ;
_fedd [2]*InvoiceCell ;_dgfba [][2]*InvoiceCell ;_efed [2]string ;_fcgg [2]string ;_gede [][2]string ;_bebbc TextStyle ;_cfga TextStyle ;_baca TextStyle ;_accd TextStyle ;_cgfdg TextStyle ;_gbff TextStyle ;_fafa TextStyle ;_daddb InvoiceCellProps ;_fbec InvoiceCellProps ;
_fdeg InvoiceCellProps ;_dbga InvoiceCellProps ;_gece Positioning ;};func _daea (_bgdac *templateProcessor ,_efbe *templateNode )(interface{},error ){return _bgdac .parseDivision (_efbe );};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bccc *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _bccc ._gefg [0],_bccc ._gefg [1]};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_fdad *Paragraph )Height ()float64 {_fdad .wrapText ();return float64 (len (_fdad ._bdad ))*_fdad ._cdeb *_fdad ._dffb ;};func (_cegbd *templateProcessor )parseFloatAttr (_febe ,_egab string )float64 {_bd .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_febe ,_egab );
_eeeef ,_ :=_fa .ParseFloat (_egab ,64);return _eeeef ;};

// SetBackground sets the background properties of the component.
func (_dff *Division )SetBackground (background *Background ){_dff ._geaa =background };

// SetPositioning sets the positioning of the rectangle (absolute or relative).
func (_efca *Rectangle )SetPositioning (position Positioning ){_efca ._dbaf =position };func _agacg (_ccfgb *templateProcessor ,_begbc *templateNode )(interface{},error ){return _ccfgb .parseList (_begbc );};

// SkipOver skips over a specified number of rows and cols.
func (_bcee *Table )SkipOver (rows ,cols int ){_acgge :=rows *_bcee ._acgc +cols -1;if _acgge < 0{_bd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _gcfgb :=0;_gcfgb < _acgge ;_gcfgb ++{_bcee .NewCell ();};};

// FitMode defines resizing options of an object inside a container.
type FitMode int ;func (_bcbeg *TextStyle )horizontalScale ()float64 {return _bcbeg .HorizontalScaling /100};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_eegbd *LinearShading )SetBoundingBox (x ,y ,width ,height float64 ){_eegbd ._fadfd =&_gec .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};func (_eeae *Block )translate (_cb ,_cf float64 ){_bae :=_bee .NewContentCreator ().Translate (_cb ,-_cf ).Operations ();
*_eeae ._efc =append (*_bae ,*_eeae ._efc ...);_eeae ._efc .WrapIfNeeded ();};

// Heading returns the heading component of the table of contents.
func (_ecgcd *TOC )Heading ()*StyledParagraph {return _ecgcd ._eeabf };

// Height returns the Block's height.
func (_dgf *Block )Height ()float64 {return _dgf ._df };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// SetDate sets the date of the invoice.
func (_gdfc *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_gdfc ._gbdb [1].Value =date ;return _gdfc ._gbdb [0],_gdfc ._gbdb [1];};func (_ecfc *Invoice )generateLineBlocks (_dage DrawContext )([]*Block ,DrawContext ,error ){_fgga :=_gegcdg (len (_ecfc ._bcdc ));
_fgga .SetMargins (0,0,25,0);for _ ,_bgaa :=range _ecfc ._bcdc {_gedc :=_bffb (_bgaa .TextStyle );_gedc .SetMargins (0,0,1,0);_gedc .Append (_bgaa .Value );_aaad :=_fgga .NewCell ();_aaad .SetHorizontalAlignment (_bgaa .Alignment );_aaad .SetBackgroundColor (_bgaa .BackgroundColor );
_ecfc .setCellBorder (_aaad ,_bgaa );_aaad .SetContent (_gedc );};for _ ,_adeg :=range _ecfc ._cbcg {for _ ,_fdae :=range _adeg {_gdbe :=_bffb (_fdae .TextStyle );_gdbe .SetMargins (0,0,3,2);_gdbe .Append (_fdae .Value );_gege :=_fgga .NewCell ();_gege .SetHorizontalAlignment (_fdae .Alignment );
_gege .SetBackgroundColor (_fdae .BackgroundColor );_ecfc .setCellBorder (_gege ,_fdae );_gege .SetContent (_gdbe );};};return _fgga .GeneratePageBlocks (_dage );};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_gbb *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gbb ._ae .Left ,_gbb ._ae .Right ,_gbb ._ae .Top ,_gbb ._ae .Bottom ;};func _fge (_ggbfa []_gg .Point )*Polyline {return &Polyline {_bacgg :&_gg .Polyline {Points :_ggbfa ,LineColor :_gec .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_ccde :1.0};
};

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_ddbc *Line )SetColor (color Color ){_ddbc ._bddae =color };

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// GeneratePageBlocks generates a page break block.
func (_fcbe *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fdcgb :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_bgdf :=ctx ;_bgdf .Y =ctx .Margins .Top ;
_bgdf .X =ctx .Margins .Left ;_bgdf .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_bgdf .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_bgdf ;return _fdcgb ,ctx ,nil ;};func (_cbae *templateProcessor )addNodeText (_fgbbd *templateNode ,_cdfg string )error {_baadf :=_fgbbd ._cdegg ;
if _baadf ==nil {return nil ;};switch _dfeff :=_baadf .(type ){case *TextChunk :_dfeff .Text =_cdfg ;case *Paragraph :switch _fgbbd ._cggg .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _fgbbd ._cafd !=nil {if _efcfa ,_efee :=_fgbbd ._cafd ._cdegg .(*Chapter );
_efee {_efcfa ._ccf =_cdfg ;_dfeff .SetText (_efcfa .headingText ());};};default:_dfeff .SetText (_cdfg );};};return nil ;};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_gcgb *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gcgb ._afgf .Left ,_gcgb ._afgf .Right ,_gcgb ._afgf .Top ,_gcgb ._afgf .Bottom ;};

// SetHeight sets the Image's document height to specified h.
func (_ddef *Image )SetHeight (h float64 ){_ddef ._eaec =h };

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_gdfb *Invoice )NoteHeadingStyle ()TextStyle {return _gdfb ._fafa };const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);func (_cdgbc *templateProcessor )parseRadialGradientAttr (creator *Creator ,_bdfbd string )Color {_eafde :=ColorBlack ;
if _bdfbd ==""{return _eafde ;};var (_cagcc error ;_cfgd =0.0;_gdcad =0.0;_bgedb =-1.0;_bdafc =_bea .Split (_bdfbd [16:len (_bdfbd )-1],"\u002c"););_dfaa :=_bea .Fields (_bdafc [0]);if len (_dfaa )==2&&_bea .TrimSpace (_dfaa [0])[0]!='#'{_cfgd ,_cagcc =_fa .ParseFloat (_dfaa [0],64);
if _cagcc !=nil {_bd .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0058\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_cagcc );
};_gdcad ,_cagcc =_fa .ParseFloat (_dfaa [1],64);if _cagcc !=nil {_bd .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0059\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_cagcc );
};_bdafc =_bdafc [1:];};_dbee :=_bea .TrimSpace (_bdafc [0]);if _dbee [0]!='#'{_bgedb ,_cagcc =_fa .ParseFloat (_dbee ,64);if _cagcc !=nil {_bd .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0072\u0061\u0064\u0069\u0061l\u0020\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0073\u0069\u007ae\u003a\u0020\u0025\u0076",_cagcc );
};_bdafc =_bdafc [1:];};_bbed ,_dcaeb :=_cdgbc .processGradientColorPair (_bdafc );if _bbed ==nil ||_dcaeb ==nil {return _eafde ;};_befdc :=creator .NewRadialGradientColor (_cfgd ,_gdcad ,0,_bgedb ,[]*ColorPoint {});for _egded :=0;_egded < len (_bbed );
_egded ++{_befdc .AddColorStop (_bbed [_egded ],_dcaeb [_egded ]);};return _befdc ;};

// SetMargins sets the margins of the rectangle.
// NOTE: rectangle margins are only applied if relative positioning is used.
func (_deagg *Rectangle )SetMargins (left ,right ,top ,bottom float64 ){_deagg ._ebfa .Left =left ;_deagg ._ebfa .Right =right ;_deagg ._ebfa .Top =top ;_deagg ._ebfa .Bottom =bottom ;};

// SetLineWidth sets the line width.
func (_bfdag *Line )SetLineWidth (width float64 ){_bfdag ._faaeb =width };

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_bgc *Creator )MoveRight (dx float64 ){_bgc ._bdfae .X +=dx };

// SetFillOpacity sets the fill opacity.
func (_eedf *CurvePolygon )SetFillOpacity (opacity float64 ){_eedf ._fegad =opacity };func (_dfcca *Division )drawBackground (_affb []*Block ,_eabdd ,_dcee DrawContext ,_edda bool )([]*Block ,error ){_deca :=len (_affb );if _deca ==0||_dfcca ._geaa ==nil {return _affb ,nil ;
};_dadcf :=make ([]*Block ,0,len (_affb ));for _dgeg ,_eedde :=range _affb {var (_babe =_dfcca ._geaa .BorderRadiusTopLeft ;_dced =_dfcca ._geaa .BorderRadiusTopRight ;_cffceg =_dfcca ._geaa .BorderRadiusBottomLeft ;_ffaca =_dfcca ._geaa .BorderRadiusBottomRight ;
);_ecga :=_eabdd ;_ecga .Page +=_dgeg ;if _dgeg ==0{if _edda {_dadcf =append (_dadcf ,_eedde );continue ;};if _deca ==1{_ecga .Height =_dcee .Y -_eabdd .Y ;};}else {_ecga .X =_ecga .Margins .Left +_dfcca ._dedd .Left ;_ecga .Y =_ecga .Margins .Top ;_ecga .Width =_ecga .PageWidth -_ecga .Margins .Left -_ecga .Margins .Right -_dfcca ._dedd .Left -_dfcca ._dedd .Right ;
if _dgeg ==_deca -1{_ecga .Height =_dcee .Y -_ecga .Margins .Top -_dfcca ._dedd .Top ;}else {_ecga .Height =_ecga .PageHeight -_ecga .Margins .Top -_ecga .Margins .Bottom ;};if !_edda {_babe =0;_dced =0;};};if _deca > 1&&_dgeg !=_deca -1{_cffceg =0;_ffaca =0;
};_ceef :=_fcdfa (_ecga .X ,_ecga .Y ,_ecga .Width ,_ecga .Height );_ceef .SetFillColor (_dfcca ._geaa .FillColor );_ceef .SetBorderColor (_dfcca ._geaa .BorderColor );_ceef .SetBorderWidth (_dfcca ._geaa .BorderSize );_ceef .SetBorderRadius (_babe ,_dced ,_cffceg ,_ffaca );
_cdac ,_ ,_egfgc :=_ceef .GeneratePageBlocks (_ecga );if _egfgc !=nil {return nil ,_egfgc ;};if len (_cdac )==0{continue ;};_fffa :=_cdac [0];if _egfgc =_fffa .mergeBlocks (_eedde );_egfgc !=nil {return nil ,_egfgc ;};_dadcf =append (_dadcf ,_fffa );};
return _dadcf ,nil ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_gcgac *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_fabf []*Block ;_febd =NewBlock (ctx .PageWidth ,ctx .PageHeight );_cabdd =ctx ;_gfda =_gcgac ._dacd /2;);_acgb :=_gcgac ._dbaf .IsRelative ();if _acgb {_gcgac .applyFitMode (ctx .Width );
ctx .X +=_gcgac ._ebfa .Left +_gfda ;ctx .Y +=_gcgac ._ebfa .Top +_gfda ;ctx .Width -=_gcgac ._ebfa .Left +_gcgac ._ebfa .Right ;ctx .Height -=_gcgac ._ebfa .Top +_gcgac ._ebfa .Bottom ;if _gcgac ._gfef > ctx .Height {_fabf =append (_fabf ,_febd );_febd =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_egfaf :=ctx ;_egfaf .Y =ctx .Margins .Top +_gcgac ._ebfa .Top +_gfda ;_egfaf .X =ctx .Margins .Left +_gcgac ._ebfa .Left +_gfda ;_egfaf .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_gcgac ._ebfa .Top -_gcgac ._ebfa .Bottom ;
_egfaf .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_gcgac ._ebfa .Left -_gcgac ._ebfa .Right ;ctx =_egfaf ;};}else {ctx .X =_gcgac ._edaf ;ctx .Y =_gcgac ._dgedd ;};_bedb :=_gg .Rectangle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_gcgac ._gfef ,Width :_gcgac ._dgdba ,Height :_gcgac ._gfef ,BorderRadiusTopLeft :_gcgac ._dffbbb ,BorderRadiusTopRight :_gcgac ._gegfb ,BorderRadiusBottomLeft :_gcgac ._gagf ,BorderRadiusBottomRight :_gcgac ._cdfe ,Opacity :1.0};
if _gcgac ._gbbce !=nil {_bedb .FillEnabled =true ;_eagbb :=_dbceg (_gcgac ._gbbce );_aabg :=_eecec (_febd ,_eagbb ,_gcgac ._gbbce ,func ()Rectangle {return Rectangle {_edaf :_bedb .X ,_dgedd :_bedb .Y ,_dgdba :_bedb .Width ,_gfef :_bedb .Height };});if _aabg !=nil {return nil ,ctx ,_aabg ;
};_bedb .FillColor =_eagbb ;};if _gcgac ._afcfd !=nil &&_gcgac ._dacd > 0{_bedb .BorderEnabled =true ;_bedb .BorderColor =_dbceg (_gcgac ._afcfd );_bedb .BorderWidth =_gcgac ._dacd ;};_baa ,_eedb :=_febd .setOpacity (_gcgac ._bcag ,_gcgac ._gcdb );if _eedb !=nil {return nil ,ctx ,_eedb ;
};_dfcd ,_ ,_eedb :=_bedb .Draw (_baa );if _eedb !=nil {return nil ,ctx ,_eedb ;};if _eedb =_febd .addContentsByString (string (_dfcd ));_eedb !=nil {return nil ,ctx ,_eedb ;};if _acgb {ctx .X =_cabdd .X ;ctx .Width =_cabdd .Width ;_cgfad :=_gcgac ._gfef +_gfda ;
ctx .Y +=_cgfad +_gcgac ._ebfa .Bottom ;ctx .Height -=_cgfad ;}else {ctx =_cabdd ;};_fabf =append (_fabf ,_febd );return _fabf ,ctx ,nil ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_aecbf *TOC )SetLineSeparatorStyle (style TextStyle ){_aecbf ._fbfaf =style };func _acge (_edgbc string )*_gec .PdfAnnotation {_dgage :=_gec .NewPdfAnnotationLink ();_gagec :=_gec .NewBorderStyle ();_gagec .SetBorderWidth (0);_dgage .BS =_gagec .ToPdfObject ();
_gddd :=_gec .NewPdfActionURI ();_gddd .URI =_dc .MakeString (_edgbc );_dgage .SetAction (_gddd .PdfAction );return _dgage .PdfAnnotation ;};

// Color returns the color of the line.
func (_faag *Line )Color ()Color {return _faag ._bddae };func _cfeff (_bffdg ...interface{})[]interface{}{return _bffdg };func (_bdaba *templateProcessor )parseCellVerticalAlignmentAttr (_gggac ,_aggd string )CellVerticalAlignment {_bd .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gggac ,_aggd );
_ecgac :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_aggd ];return _ecgac ;};


// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//
//	red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_dfgea :float64 (r )/255.0,_eee :float64 (g )/255.0,_ddab :float64 (b )/255.0};};

// SetPositioning sets the positioning of the ellipse (absolute or relative).
func (_ageb *Ellipse )SetPositioning (position Positioning ){_ageb ._ggfe =position };

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_dgdc *Image )SetFitMode (fitMode FitMode ){_dgdc ._ade =fitMode };

// SetStyleTop sets border style for top side.
func (_gadd *border )SetStyleTop (style CellBorderStyle ){_gadd ._eed =style };

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_bbbcg *Table )Width ()float64 {return 0};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_gfgcd *Invoice )SetAddressStyle (style TextStyle ){_gfgcd ._accd =style };func _gaddc ()*Division {return &Division {_ecd :true }};

// GetMargins returns the margins of the graphic svg (left, right, top, bottom).
func (_fefa *GraphicSVG )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fefa ._fggef .Left ,_fefa ._fggef .Right ,_fefa ._fggef .Top ,_fefa ._fggef .Bottom ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_cdcce *Image )SetWidth (w float64 ){_cdcce ._bdebc =w };func _agb (_gafg [][]_gg .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_cecf :&_gg .CurvePolygon {Rings :_gafg },_fegad :1.0,_fecf :1.0};};

// SetAngle sets the rotation angle of the text.
func (_cede *StyledParagraph )SetAngle (angle float64 ){_cede ._dafa =angle };func (_edcfc *templateProcessor )nodeLogError (_bcdee *templateNode ,_abdcf string ,_gbga ...interface{}){_bd .Log .Error (_edcfc .getNodeErrorLocation (_bcdee ,_abdcf ,_gbga ...));
};func (_cddge *TextChunk )clone ()*TextChunk {_feda :=*_cddge ;_feda ._aacgc =_edaac (_cddge ._aacgc );return &_feda ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_cab *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gef :=_ea .IdentityMatrix ();_dae ,_beab :=_cab .Width (),_cab .Height ();if _cab ._eec .IsRelative (){_gef =_gef .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_beab );
}else {_gef =_gef .Translate (_cab ._bg ,ctx .PageHeight -_cab ._fe -_beab );};_bfd :=_beab ;if _cab ._gd !=0{_gef =_gef .Translate (_dae /2,_beab /2).Rotate (_cab ._gd *_ag .Pi /180.0).Translate (-_dae /2,-_beab /2);_ ,_bfd =_cab .RotatedSize ();};if _cab ._eec .IsRelative (){ctx .Y +=_bfd ;
};_eac :=_bee .NewContentCreator ();_eac .Add_cm (_gef [0],_gef [1],_gef [3],_gef [4],_gef [6],_gef [7]);_ab :=_cab .duplicate ();_dfdg :=append (*_eac .Operations (),*_ab ._efc ...);_dfdg .WrapIfNeeded ();_ab ._efc =&_dfdg ;for _ ,_fbc :=range _cab ._fc {_agc ,_gc :=_dc .GetArray (_fbc .Rect );
if !_gc ||_agc .Len ()!=4{_bd .Log .Debug ("\u0057\u0041\u0052\u004e\u003a \u0069\u006e\u0076\u0061\u006ci\u0064 \u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065l\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e",_fbc .Rect );
continue ;};_feb ,_bab :=_gec .NewPdfRectangle (*_agc );if _bab !=nil {_bd .Log .Debug ("\u0057A\u0052N\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074 \u0070\u0061\u0072\u0073e\u0020\u0061\u006e\u006e\u006ft\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u002e",_bab );
continue ;};_feb .Transform (_gef );_fbc .Rect =_feb .ToPdfObject ();};return []*Block {_ab },ctx ,nil ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);func (_agae *templateProcessor )parseImage (_egebc *templateNode )(interface{},error ){var _dggdb string ;
for _ ,_ebgfee :=range _egebc ._cggg .Attr {_dbdef :=_ebgfee .Value ;switch _aefgc :=_ebgfee .Name .Local ;_aefgc {case "\u0073\u0072\u0063":_dggdb =_dbdef ;};};_ecgdd ,_bgdc :=_agae .loadImageFromSrc (_dggdb );if _bgdc !=nil {return nil ,_bgdc ;};for _ ,_fddd :=range _egebc ._cggg .Attr {_efda :=_fddd .Value ;
switch _bdegg :=_fddd .Name .Local ;_bdegg {case "\u0061\u006c\u0069g\u006e":_ecgdd .SetHorizontalAlignment (_agae .parseHorizontalAlignmentAttr (_bdegg ,_efda ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_ecgdd .SetOpacity (_agae .parseFloatAttr (_bdegg ,_efda ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_cfegc :=_agae .parseMarginAttr (_bdegg ,_efda );_ecgdd .SetMargins (_cfegc .Left ,_cfegc .Right ,_cfegc .Top ,_cfegc .Bottom );case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_ecgdd .SetFitMode (_agae .parseFitModeAttr (_bdegg ,_efda ));
case "\u0078":_ecgdd .SetPos (_agae .parseFloatAttr (_bdegg ,_efda ),_ecgdd ._gagce );case "\u0079":_ecgdd .SetPos (_ecgdd ._gfbb ,_agae .parseFloatAttr (_bdegg ,_efda ));case "\u0077\u0069\u0064t\u0068":_ecgdd .SetWidth (_agae .parseFloatAttr (_bdegg ,_efda ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_ecgdd .SetHeight (_agae .parseFloatAttr (_bdegg ,_efda ));case "\u0061\u006e\u0067l\u0065":_ecgdd .SetAngle (_agae .parseFloatAttr (_bdegg ,_efda ));case "\u0073\u0072\u0063":break ;default:_agae .nodeLogDebug (_egebc ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_bdegg );
};};return _ecgdd ,nil ;};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_ffdd *Image )ScaleToWidth (w float64 ){_feed :=_ffdd ._eaec /_ffdd ._bdebc ;_ffdd ._bdebc =w ;_ffdd ._eaec =w *_feed ;};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_ddf *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ddf ._gebe .Left ,_ddf ._gebe .Right ,_ddf ._gebe .Top ,_ddf ._gebe .Bottom ;};func _dbde (_debe ,_bfde TextStyle )*Invoice {_bcac :=&Invoice {_gfeg :"\u0049N\u0056\u004f\u0049\u0043\u0045",_adec :"\u002c\u0020",_bebbc :_debe ,_cfga :_bfde };
_bcac ._bega =&InvoiceAddress {Separator :_bcac ._adec };_bcac ._egaf =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_bcac ._adec };_fdbd :=ColorRGBFrom8bit (245,245,245);_aefb :=ColorRGBFrom8bit (155,155,155);_bcac ._baca =_bfde ;
_bcac ._baca .Color =_aefb ;_bcac ._baca .FontSize =20;_bcac ._accd =_debe ;_bcac ._cgfdg =_bfde ;_bcac ._gbff =_debe ;_bcac ._fafa =_bfde ;_bcac ._daddb =_bcac .NewCellProps ();_bcac ._daddb .BackgroundColor =_fdbd ;_bcac ._daddb .TextStyle =_bfde ;_bcac ._fbec =_bcac .NewCellProps ();
_bcac ._fbec .TextStyle =_bfde ;_bcac ._fbec .BackgroundColor =_fdbd ;_bcac ._fbec .BorderColor =_fdbd ;_bcac ._fdeg =_bcac .NewCellProps ();_bcac ._fdeg .BorderColor =_fdbd ;_bcac ._fdeg .BorderSides =[]CellBorderSide {CellBorderSideBottom };_bcac ._fdeg .Alignment =CellHorizontalAlignmentRight ;
_bcac ._dbga =_bcac .NewCellProps ();_bcac ._dbga .Alignment =CellHorizontalAlignmentRight ;_bcac ._bebc =[2]*InvoiceCell {_bcac .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_bcac ._daddb ),_bcac .newCell ("",_bcac ._daddb )};
_bcac ._gbdb =[2]*InvoiceCell {_bcac .newCell ("\u0044\u0061\u0074\u0065",_bcac ._daddb ),_bcac .newCell ("",_bcac ._daddb )};_bcac ._gefg =[2]*InvoiceCell {_bcac .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_bcac ._daddb ),_bcac .newCell ("",_bcac ._daddb )};
_bcac ._aaaeg =[2]*InvoiceCell {_bcac .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_bcac ._dbga ),_bcac .newCell ("",_bcac ._dbga )};_cfdc :=_bcac ._dbga ;_cfdc .TextStyle =_bfde ;_cfdc .BackgroundColor =_fdbd ;_cfdc .BorderColor =_fdbd ;
_bcac ._fedd =[2]*InvoiceCell {_bcac .newCell ("\u0054\u006f\u0074a\u006c",_cfdc ),_bcac .newCell ("",_cfdc )};_bcac ._efed =[2]string {"\u004e\u006f\u0074e\u0073",""};_bcac ._fcgg =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_bcac ._bcdc =[]*InvoiceCell {_bcac .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_bcac .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_bcac .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_bcac .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _bcac ;};

// NewPolygon creates a new polygon.
func (_eded *Creator )NewPolygon (points [][]_gg .Point )*Polygon {return _gebgc (points )};func (_aead *templateProcessor )parseLinkAttr (_edfa ,_febdg string )*_gec .PdfAnnotation {_febdg =_bea .TrimSpace (_febdg );if _bea .HasPrefix (_febdg ,"\u0075\u0072\u006c(\u0027")&&_bea .HasSuffix (_febdg ,"\u0027\u0029")&&len (_febdg )> 7{return _acge (_febdg [5:len (_febdg )-2]);
};if _bea .HasPrefix (_febdg ,"\u0070\u0061\u0067e\u0028")&&_bea .HasSuffix (_febdg ,"\u0029")&&len (_febdg )> 6{var (_dadfa error ;_bdbb int64 ;_gbedc float64 ;_cbgcc float64 ;_bebcb =1.0;_dcaca =_bea .Split (_febdg [5:len (_febdg )-1],"\u002c"););_bdbb ,_dadfa =_fa .ParseInt (_bea .TrimSpace (_dcaca [0]),10,64);
if _dadfa !=nil {_bd .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_dadfa );return nil ;};if len (_dcaca )>=2{_gbedc ,_dadfa =_fa .ParseFloat (_bea .TrimSpace (_dcaca [1]),64);
if _dadfa !=nil {_bd .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0058\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_dadfa );
return nil ;};};if len (_dcaca )>=3{_cbgcc ,_dadfa =_fa .ParseFloat (_bea .TrimSpace (_dcaca [2]),64);if _dadfa !=nil {_bd .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0059\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_dadfa );
return nil ;};};if len (_dcaca )>=4{_bebcb ,_dadfa =_fa .ParseFloat (_bea .TrimSpace (_dcaca [3]),64);if _dadfa !=nil {_bd .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u007a\u006f\u006f\u006d\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_dadfa );
return nil ;};};return _aebee (_bdbb -1,_gbedc ,_cbgcc ,_bebcb );};return nil ;};func (_edd *Chapter )headingNumber ()string {var _cffc string ;if _edd ._dcd {if _edd ._bcc !=0{_cffc =_fa .Itoa (_edd ._bcc )+"\u002e";};if _edd ._fbea !=nil {_bbea :=_edd ._fbea .headingNumber ();
if _bbea !=""{_cffc =_bbea +_cffc ;};};};return _cffc ;};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// GetMargins returns the margins of the rectangle: left, right, top, bottom.
func (_fcba *Rectangle )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fcba ._ebfa .Left ,_fcba ._ebfa .Right ,_fcba ._ebfa .Top ,_fcba ._ebfa .Bottom ;};

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_gefef *Line )SetMargins (left ,right ,top ,bottom float64 ){_gefef ._egbc .Left =left ;_gefef ._egbc .Right =right ;_gefef ._egbc .Top =top ;_gefef ._egbc .Bottom =bottom ;};

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_abbg *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_abbg ._cgdgd =dashArray ;_abbg ._cggede =dashPhase ;};func (_gafdf *Table )resetColumnWidths (){_gafdf ._fgdb =[]float64 {};_fabgg :=float64 (1.0)/float64 (_gafdf ._acgc );for _ffgc :=0;
_ffgc < _gafdf ._acgc ;_ffgc ++{_gafdf ._fgdb =append (_gafdf ._fgdb ,_fabgg );};};func (_fefg *Invoice )newCell (_eccf string ,_bbacc InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_bbacc ,_eccf };};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_fdce *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_gddg :=range subtable ._dabec {_dddbf :=&TableCell {};*_dddbf =*_gddg ;_dddbf ._cedbg =_fdce ;_dddbf ._dfdfe +=col -1;if _cefe :=_fdce ._acgc -(_dddbf ._dfdfe -1);_cefe < _dddbf ._cebg {_fdce ._acgc +=_dddbf ._cebg -_cefe ;
_fdce .resetColumnWidths ();_bd .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_fdce ._acgc );
};_dddbf ._eddfg +=row -1;_fbff :=subtable ._faga [_gddg ._eddfg -1];if _dddbf ._eddfg > _fdce ._gebff {for _dddbf ._eddfg > _fdce ._gebff {_fdce ._gebff ++;_fdce ._faga =append (_fdce ._faga ,_fdce ._eagc );};_fdce ._faga [_dddbf ._eddfg -1]=_fbff ;}else {_fdce ._faga [_dddbf ._eddfg -1]=_ag .Max (_fdce ._faga [_dddbf ._eddfg -1],_fbff );
};_fdce ._dabec =append (_fdce ._dabec ,_dddbf );};_fdce .sortCells ();};

// SkipRows skips over a specified number of rows in the table.
func (_eccb *Table )SkipRows (num int ){_ddcac :=num *_eccb ._acgc -1;if _ddcac < 0{_bd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _debf :=0;_debf < _ddcac ;_debf ++{_eccb .NewCell ();};};

// SetDueDate sets the due date of the invoice.
func (_bbeb *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_bbeb ._gefg [1].Value =dueDate ;return _bbeb ._gefg [0],_bbeb ._gefg [1];};

// SetLevel sets the indentation level of the TOC line.
func (_cbfe *TOCLine )SetLevel (level uint ){_cbfe ._aabgg =level ;_cbfe ._ebebg ._dfcfg .Left =_cbfe ._cbaed +float64 (_cbfe ._aabgg -1)*_cbfe ._debg ;};

// SetWidthLeft sets border width for left.
func (_bdg *border )SetWidthLeft (bw float64 ){_bdg ._afdc =bw };

// SetFitMode sets the fit mode of the rectangle.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_dbac *Rectangle )SetFitMode (fitMode FitMode ){_dbac ._ccef =fitMode };

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_efae *_gg .Polygon ;_bafb float64 ;_cggc float64 ;_eeed Color ;};

// SetFillOpacity sets the fill opacity of the rectangle.
func (_dcfa *Rectangle )SetFillOpacity (opacity float64 ){_dcfa ._bcag =opacity };

// GetCoords returns coordinates of border.
func (_dge *border )GetCoords ()(float64 ,float64 ){return _dge ._fgde ,_dge ._dfge };

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//
//	[number] [title]      [separator] [page]
//
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_eeabf *StyledParagraph ;_gbece []*TOCLine ;_cgagb TextStyle ;_dbgcb TextStyle ;_fbfaf TextStyle ;_ebcc TextStyle ;_cadb string ;_cacgf float64 ;_gcgec Margins ;_bced Positioning ;_ddged TextStyle ;_gfge bool ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//
//	red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_cbe :_ag .Min (float64 (c ),100)/100.0,_aacg :_ag .Min (float64 (m ),100)/100.0,_cbb :_ag .Min (float64 (y ),100)/100.0,_fbcg :_ag .Min (float64 (k ),100)/100.0};};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_egaea *TableCell )SetContent (vd VectorDrawable )error {switch _gecaa :=vd .(type ){case *Paragraph :if _gecaa ._fffec {_gecaa ._bcab =true ;};_egaea ._cbbec =vd ;case *StyledParagraph :if _gecaa ._cfdd {_gecaa ._cafa =true ;};_egaea ._cbbec =vd ;
case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_egaea ._cbbec =vd ;default:_bd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _dc .ErrTypeError ;};return nil ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_decf *Creator )NewImage (img *_gec .Image )(*Image ,error ){return _cged (img )};

// SetColorTop sets border color for top.
func (_cef *border )SetColorTop (col Color ){_cef ._aegb =col };func (_ffgcf *templateProcessor )parseDivision (_bgbdg *templateNode )(interface{},error ){_gbfaa :=_ffgcf .creator .NewDivision ();for _ ,_acbc :=range _bgbdg ._cggg .Attr {_gedac :=_acbc .Value ;
switch _fbbe :=_acbc .Name .Local ;_fbbe {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_gbfaa .EnablePageWrap (_ffgcf .parseBoolAttr (_fbbe ,_gedac ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_bcaed :=_ffgcf .parseMarginAttr (_fbbe ,_gedac );
_gbfaa .SetMargins (_bcaed .Left ,_bcaed .Right ,_bcaed .Top ,_bcaed .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_ebag :=_ffgcf .parseMarginAttr (_fbbe ,_gedac );_gbfaa .SetPadding (_ebag .Left ,_ebag .Right ,_ebag .Top ,_ebag .Bottom );default:_ffgcf .nodeLogDebug (_bgbdg ,"U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_fbbe );
};};return _gbfaa ,nil ;};func (_dddfg *templateProcessor )parseTextAlignmentAttr (_bdbf ,_ebed string )TextAlignment {_bd .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bdbf ,_ebed );
_fbeac :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_ebed ];
return _fbeac ;};type border struct{_fgde float64 ;_dfge float64 ;_cdf float64 ;_ead float64 ;_aaf Color ;_dadc Color ;_afdc float64 ;_febb Color ;_fga float64 ;_eag Color ;_aegf float64 ;_aegb Color ;_dga float64 ;LineStyle _gg .LineStyle ;_ffcg CellBorderStyle ;
_ebcd CellBorderStyle ;_eed CellBorderStyle ;_ffe CellBorderStyle ;};func (_dffbc *StyledParagraph )getTextWidth ()float64 {var _cfgfg float64 ;_agecd :=len (_dffbc ._acbg );for _bgebg ,_decd :=range _dffbc ._acbg {_baad :=&_decd .Style ;_fdcf :=len (_decd .Text );
for _fgfb ,_ecag :=range _decd .Text {if _ecag =='\u000A'{continue ;};_cagf ,_adcb :=_baad .Font .GetRuneMetrics (_ecag );if !_adcb {_bd .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ecag );
return -1;};_cfgfg +=_baad .FontSize *_cagf .Wx *_baad .horizontalScale ();if _ecag !=' '&&(_bgebg !=_agecd -1||_fgfb !=_fdcf -1){_cfgfg +=_baad .CharSpacing *1000.0;};};};return _cfgfg ;};func _efefc (_dddeg *templateProcessor ,_caeea *templateNode )(interface{},error ){return _dddeg .parseChart (_caeea );
};func (_fgf *pageTransformations )transformBlock (_aafb *Block ){if _fgf ._eabg !=nil {_aafb .transform (*_fgf ._eabg );};};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_egbga *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_facg :=ctx ;_ffeg ,ctx ,_adcag :=_egbga ._eeabf .GeneratePageBlocks (ctx );if _adcag !=nil {return _ffeg ,ctx ,_adcag ;};for _ ,_bgbab :=range _egbga ._gbece {_addg :=_bgbab ._ccbe ;
if !_egbga ._gfge {_bgbab ._ccbe =0;};_dcgfbg ,_cfbbd ,_ggdc :=_bgbab .GeneratePageBlocks (ctx );_bgbab ._ccbe =_addg ;if _ggdc !=nil {return _ffeg ,ctx ,_ggdc ;};if len (_dcgfbg )< 1{continue ;};_ffeg [len (_ffeg )-1].mergeBlocks (_dcgfbg [0]);_ffeg =append (_ffeg ,_dcgfbg [1:]...);
ctx =_cfbbd ;};if _egbga ._bced .IsRelative (){ctx .X =_facg .X ;};if _egbga ._bced .IsAbsolute (){return _ffeg ,_facg ,nil ;};return _ffeg ,ctx ,nil ;};func _beac (_aeaf *_cg .File )([]*_gec .PdfPage ,error ){_bggc ,_ecagd :=_gec .NewPdfReader (_aeaf );
if _ecagd !=nil {return nil ,_ecagd ;};_faefb ,_ecagd :=_bggc .GetNumPages ();if _ecagd !=nil {return nil ,_ecagd ;};var _dagdg []*_gec .PdfPage ;for _gcfc :=0;_gcfc < _faefb ;_gcfc ++{_gegbg ,_adbggg :=_bggc .GetPage (_gcfc +1);if _adbggg !=nil {return nil ,_adbggg ;
};_dagdg =append (_dagdg ,_gegbg );};return _dagdg ,nil ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_gebff int ;_acgc int ;_faaef int ;_fgdb []float64 ;_faga []float64 ;_eagc float64 ;_dabec []*TableCell ;_afabg []int ;_cfcbe Positioning ;_dbdeb ,_edde float64 ;_degb Margins ;_ddagb bool ;_dbbcc int ;_gdecd int ;_bfec bool ;_eddeg bool ;
_bbef bool ;};

// AddColorStop add color stop info for rendering gradient color.
func (_eefb *LinearShading )AddColorStop (color Color ,point float64 ){_eefb ._dece .AddColorStop (color ,point );};func (_dbffa *StyledParagraph )getLineMetrics (_eggaa int )(_aeae ,_bcda ,_becac float64 ){if _dbffa ._dbgba ==nil ||len (_dbffa ._dbgba )==0{_dbffa .wrapText ();
};if _eggaa < 0||_eggaa > len (_dbffa ._dbgba )-1{_bd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_eggaa );
return 0,0,0;};_edbc :=_dbffa ._dbgba [_eggaa ];for _ ,_agfd :=range _edbc {_dgfd :=_baeef (_agfd .Style .Font ,_agfd .Style .FontSize );if _dgfd ._dgbdd > _aeae {_aeae =_dgfd ._dgbdd ;};if _dgfd ._fcef < _becac {_becac =_dgfd ._fcef ;};if _afcd :=_agfd .Style .FontSize ;
_afcd > _bcda {_bcda =_afcd ;};};return _aeae ,_bcda ,_becac ;};func _fcdfa (_ggbdc ,_ceac ,_aegde ,_ggfaf float64 )*Rectangle {return &Rectangle {_edaf :_ggbdc ,_dgedd :_ceac ,_dgdba :_aegde ,_gfef :_ggfaf ,_dbaf :PositionAbsolute ,_bcag :1.0,_afcfd :ColorBlack ,_dacd :1.0,_gcdb :1.0};
};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_bdag *Paragraph )SetTextAlignment (align TextAlignment ){_bdag ._abcc =align };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_gdcf *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ggag :=ctx ;var _fgab []*Block ;_geecb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _gdcf ._dfgb .IsRelative (){ctx .X +=_gdcf ._bgcd .Left ;ctx .Y +=_gdcf ._bgcd .Top ;
ctx .Width -=_gdcf ._bgcd .Left +_gdcf ._bgcd .Right ;ctx .Height -=_gdcf ._bgcd .Top ;_gdcf .SetWidth (ctx .Width );if _gdcf .Height ()> ctx .Height {_fgab =append (_fgab ,_geecb );_geecb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_adgb :=ctx ;
_adgb .Y =ctx .Margins .Top ;_adgb .X =ctx .Margins .Left +_gdcf ._bgcd .Left ;_adgb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_adgb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_gdcf ._bgcd .Left -_gdcf ._bgcd .Right ;
ctx =_adgb ;};}else {if int (_gdcf ._abcd )<=0{_gdcf .SetWidth (_gdcf .getTextWidth ());};ctx .X =_gdcf ._fbeab ;ctx .Y =_gdcf ._dbec ;};ctx ,_fgfg :=_afdg (_geecb ,_gdcf ,ctx );if _fgfg !=nil {_bd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fgfg );
return nil ,ctx ,_fgfg ;};_fgab =append (_fgab ,_geecb );if _gdcf ._dfgb .IsRelative (){ctx .Y +=_gdcf ._bgcd .Bottom ;ctx .Height -=_gdcf ._bgcd .Bottom ;if !ctx .Inline {ctx .X =_ggag .X ;ctx .Width =_ggag .Width ;};return _fgab ,ctx ,nil ;};return _fgab ,_ggag ,nil ;
};func (_ggd *Block )mergeBlocks (_daa *Block )error {_afe :=_agd (_ggd ._efc ,_ggd ._fb ,_daa ._efc ,_daa ._fb );if _afe !=nil {return _afe ;};for _ ,_aea :=range _daa ._fc {_ggd .AddAnnotation (_aea );};return nil ;};

// NewLinearGradientColor creates a linear gradient color that could act as a color in other components.
func (_gaaff *Creator )NewLinearGradientColor (colorPoints []*ColorPoint )*LinearShading {return _fag (colorPoints );};

// SetFillColor sets the fill color.
func (_dbaa *Polygon )SetFillColor (color Color ){_dbaa ._eeed =color ;_dbaa ._efae .FillColor =_dbceg (color );};

// NewPageBreak create a new page break.
func (_gagd *Creator )NewPageBreak ()*PageBreak {return _fcbca ()};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_gdfa *Image )GetHorizontalAlignment ()HorizontalAlignment {return _gdfa ._ebaeg };func (_gcdf *templateProcessor )parseBoolAttr (_agcb ,_afdf string )bool {_bd .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_agcb ,_afdf );
_becgb ,_ :=_fa .ParseBool (_afdf );return _afdf ==""||_becgb ;};func _gbgac (_ffdeaa *templateProcessor ,_dffab *templateNode )(interface{},error ){return _ffdeaa .parseLine (_dffab );};func (_bdee *Invoice )drawInformation ()*Table {_fbbc :=_gegcdg (2);
_fdgcf :=append ([][2]*InvoiceCell {_bdee ._bebc ,_bdee ._gbdb ,_bdee ._gefg },_bdee ._effcg ...);for _ ,_ddec :=range _fdgcf {_egafg ,_beea :=_ddec [0],_ddec [1];if _beea .Value ==""{continue ;};_eggg :=_fbbc .NewCell ();_eggg .SetBackgroundColor (_egafg .BackgroundColor );
_bdee .setCellBorder (_eggg ,_egafg );_dfae :=_bffb (_egafg .TextStyle );_dfae .Append (_egafg .Value );_dfae .SetMargins (0,0,2,1);_eggg .SetContent (_dfae );_eggg =_fbbc .NewCell ();_eggg .SetBackgroundColor (_beea .BackgroundColor );_bdee .setCellBorder (_eggg ,_beea );
_dfae =_bffb (_beea .TextStyle );_dfae .Append (_beea .Value );_dfae .SetMargins (0,0,2,1);_eggg .SetContent (_dfae );};return _fbbc ;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_bdggd *shading )SetAntiAlias (enable bool ){_bdggd ._gdegc =enable };

// ScaleToHeight sets the graphic svg scaling factor with the given height.
func (_adda *GraphicSVG )ScaleToHeight (h float64 ){_caed :=_adda ._bbce .Width /_adda ._bbce .Height ;_adda ._bbce .Height =h ;_adda ._bbce .Width =h *_caed ;_adda ._bbce .SetScaling (_caed ,_caed );};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_edcg *Invoice )SetNoteStyle (style TextStyle ){_edcg ._gbff =style };

// ColorPoint is a pair of Color and a relative point where the color
// would be rendered.
type ColorPoint struct{_accee Color ;_ccbcc float64 ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_bgfg *Creator )NewPage ()*_gec .PdfPage {_bgga :=_bgfg .newPage ();_bgfg ._gage =append (_bgfg ._gage ,_bgga );_bgfg ._bdfae .Page ++;return _bgga ;};

// Add adds a new line with the default style to the table of contents.
func (_gefa *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_gegfe :=_gefa .AddLine (_cdgeb (TextChunk {Text :number ,Style :_gefa ._cgagb },TextChunk {Text :title ,Style :_gefa ._dbgcb },TextChunk {Text :page ,Style :_gefa ._ebcc },level ,_gefa ._ddged ));
if _gegfe ==nil {return nil ;};_fbdbcd :=&_gefa ._gcgec ;_gegfe .SetMargins (_fbdbcd .Left ,_fbdbcd .Right ,_fbdbcd .Top ,_fbdbcd .Bottom );_gegfe .SetLevelOffset (_gefa ._cacgf );_gegfe .Separator .Text =_gefa ._cadb ;_gegfe .Separator .Style =_gefa ._fbfaf ;
return _gegfe ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gecc *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bgbd :=ctx ;_dgede :=[]func (_ddfg DrawContext )([]*Block ,DrawContext ,error ){_gecc .generateHeaderBlocks ,_gecc .generateInformationBlocks ,_gecc .generateLineBlocks ,_gecc .generateTotalBlocks ,_gecc .generateNoteBlocks };
var _bacfg []*Block ;for _ ,_eddcb :=range _dgede {_eccg ,_cabdg ,_dgcfg :=_eddcb (ctx );if _dgcfg !=nil {return _bacfg ,ctx ,_dgcfg ;};if len (_bacfg )==0{_bacfg =_eccg ;}else if len (_eccg )> 0{_bacfg [len (_bacfg )-1].mergeBlocks (_eccg [0]);_bacfg =append (_bacfg ,_eccg [1:]...);
};ctx =_cabdg ;};if _gecc ._gece .IsRelative (){ctx .X =_bgbd .X ;};if _gecc ._gece .IsAbsolute (){return _bacfg ,_bgbd ,nil ;};return _bacfg ,ctx ,nil ;};

// NewDivision returns a new Division container component.
func (_abdf *Creator )NewDivision ()*Division {return _gaddc ()};

// SetBorderColor sets the border color.
func (_bdfeb *Polygon )SetBorderColor (color Color ){_bdfeb ._efae .BorderColor =_dbceg (color )};func (_efaf *templateProcessor )parseTextChunk (_feag *templateNode ,_adbgg *TextChunk )(interface{},error ){if _feag ._cafd ==nil {_efaf .nodeLogError (_feag ,"\u0054\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_bged ;};var (_gffe =_efaf .creator .NewTextStyle ();_dceg bool ;);for _ ,_aabd :=range _feag ._cggg .Attr {if _aabd .Name .Local =="\u006c\u0069\u006e\u006b"{_gfdfc ,_cbff :=_feag ._cafd ._cdegg .(*StyledParagraph );if !_cbff {_efaf .nodeLogError (_feag ,"\u004c\u0069\u006e\u006b \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u006f\u006e\u006c\u0079\u0020\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0070\u0061\u0072\u0061\u0067r\u0061\u0070\u0068\u0027\u0073\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e");
_dceg =true ;}else {_gffe =_gfdfc ._dffcf ;};break ;};};if _adbgg ==nil {_adbgg =NewTextChunk ("",_gffe );};for _ ,_dfbb :=range _feag ._cggg .Attr {_cecac :=_dfbb .Value ;switch _efgfb :=_dfbb .Name .Local ;_efgfb {case "\u0063\u006f\u006co\u0072":_adbgg .Style .Color =_efaf .parseColorAttr (_efgfb ,_cecac );
case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_adbgg .Style .OutlineColor =_efaf .parseColorAttr (_efgfb ,_cecac );case "\u0066\u006f\u006e\u0074":_adbgg .Style .Font =_efaf .parseFontAttr (_efgfb ,_cecac );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_adbgg .Style .FontSize =_efaf .parseFloatAttr (_efgfb ,_cecac );
case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_adbgg .Style .OutlineSize =_efaf .parseFloatAttr (_efgfb ,_cecac );case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_adbgg .Style .CharSpacing =_efaf .parseFloatAttr (_efgfb ,_cecac );
case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_adbgg .Style .HorizontalScaling =_efaf .parseFloatAttr (_efgfb ,_cecac );case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_adbgg .Style .RenderingMode =_efaf .parseTextRenderingModeAttr (_efgfb ,_cecac );
case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_adbgg .Style .Underline =_efaf .parseBoolAttr (_efgfb ,_cecac );case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_adbgg .Style .UnderlineStyle .Color =_efaf .parseColorAttr (_efgfb ,_cecac );
case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_adbgg .Style .UnderlineStyle .Offset =_efaf .parseFloatAttr (_efgfb ,_cecac );case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_adbgg .Style .UnderlineStyle .Thickness =_efaf .parseFloatAttr (_efgfb ,_cecac );
case "\u006c\u0069\u006e\u006b":if !_dceg {_adbgg ._aacgc =_efaf .parseLinkAttr (_efgfb ,_cecac );};case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_adbgg .Style .TextRise =_efaf .parseFloatAttr (_efgfb ,_cecac );default:_efaf .nodeLogDebug (_feag ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_efgfb );
};};return _adbgg ,nil ;};

// DrawWithContext draws the Block using the specified drawing context.
func (_cfg *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_cgg ,_ ,_dad :=d .GeneratePageBlocks (ctx );if _dad !=nil {return _dad ;};if len (_cgg )!=1{return ErrContentNotFit ;};for _ ,_cgge :=range _cgg {if _ed :=_cfg .mergeBlocks (_cgge );
_ed !=nil {return _ed ;};};return nil ;};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_edee *Invoice )SetAddressHeadingStyle (style TextStyle ){_edee ._cgfdg =style };func (_fdgba *TableCell )cloneProps (_fgbgf VectorDrawable )*TableCell {_dgfa :=*_fdgba ;_dgfa ._cbbec =_fgbgf ;return &_dgfa ;};

// SetFillColor sets the fill color.
func (_ceb *CurvePolygon )SetFillColor (color Color ){_ceb ._cedb =color ;_ceb ._cecf .FillColor =_dbceg (color );};

// SetTotal sets the total of the invoice.
func (_fddaf *Invoice )SetTotal (value string ){_fddaf ._fedd [1].Value =value };

// SetHeight sets the height of the rectangle.
func (_gace *Rectangle )SetHeight (height float64 ){_gace ._gfef =height };

// SetInline sets the inline mode of the division.
func (_bade *Division )SetInline (inline bool ){_bade ._fffg =inline };var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);
ColorYellow =ColorRGBFromArithmetic (1,1,0););

// Scale scales Image by a constant factor, both width and height.
func (_accc *Image )Scale (xFactor ,yFactor float64 ){_accc ._bdebc =xFactor *_accc ._bdebc ;_accc ._eaec =yFactor *_accc ._eaec ;};

// SetSellerAddress sets the seller address of the invoice.
func (_aedeb *Invoice )SetSellerAddress (address *InvoiceAddress ){_aedeb ._bega =address };const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// ScaleToWidth scales the ellipse to the specified width. The height of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_dgce *Ellipse )ScaleToWidth (w float64 ){_ggdb :=_dgce ._gaeb /_dgce ._eegf ;_dgce ._eegf =w ;_dgce ._gaeb =w *_ggdb ;};

// EnableWordWrap sets the paragraph word wrap flag.
func (_aabb *StyledParagraph )EnableWordWrap (val bool ){_aabb ._gedfe =val };

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_efff *Paragraph )SetMaxLines (maxLines int ){_efff ._dfedg =maxLines ;_efff .wrapText ()};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_cbe :_ag .Max (_ag .Min (c ,1.0),0.0),_aacg :_ag .Max (_ag .Min (m ,1.0),0.0),_cbb :_ag .Max (_ag .Min (y ,1.0),0.0),_fbcg :_ag .Max (_ag .Min (k ,1.0),0.0)};};func _aaegg (_gdadga interface{})(interface{},error ){switch _dcca :=_gdadga .(type ){case uint8 :return int64 (_dcca ),nil ;
case int8 :return int64 (_dcca ),nil ;case uint16 :return int64 (_dcca ),nil ;case int16 :return int64 (_dcca ),nil ;case uint32 :return int64 (_dcca ),nil ;case int32 :return int64 (_dcca ),nil ;case uint64 :return int64 (_dcca ),nil ;case int64 :return _dcca ,nil ;
case int :return int64 (_dcca ),nil ;case float32 :return float64 (_dcca ),nil ;case float64 :return _dcca ,nil ;};return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0076\u0061\u006c\u0075\u0065\u002c\u0020\u0025\u0076\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072",_gdadga );
};

// GetCoords returns the upper left corner coordinates of the rectangle (`x`, `y`).
func (_egbab *Rectangle )GetCoords ()(float64 ,float64 ){return _egbab ._edaf ,_egbab ._dgedd };

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_eaa *Creator )Flip (flipH ,flipV bool )error {_bcde :=_eaa .getActivePage ();if _bcde ==nil {return _d .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_cgagf ,_cdd :=_eaa ._eabc [_bcde ];if !_cdd {_cgagf =&pageTransformations {};
_eaa ._eabc [_bcde ]=_cgagf ;};_cgagf ._fbac =flipH ;_cgagf ._eeb =flipV ;return nil ;};

// WriteToFile writes the Creator output to file specified by path.
func (_ccfg *Creator )WriteToFile (outputPath string )error {_aeeg ,_ebgbd :=_cg .Create (outputPath );if _ebgbd !=nil {return _ebgbd ;};defer _aeeg .Close ();return _ccfg .Write (_aeeg );};

// SetColor sets the line color.
func (_aaeg *Curve )SetColor (col Color ){_aaeg ._aada =col };func _gaed (_bcgafd *templateProcessor ,_fgabf *templateNode )(interface{},error ){return _bcgafd .parseTable (_fgabf );};

// NewTOCLine creates a new table of contents line with the default style.
func (_gbf *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _ecgga (number ,title ,page ,level ,_gbf .NewTextStyle ());};

// SetNotes sets the notes section of the invoice.
func (_deff *Invoice )SetNotes (title ,content string ){_deff ._efed =[2]string {title ,content }};func (_ggcg *templateProcessor )parseBackground (_cagc *templateNode )(interface{},error ){_aebe :=&Background {};for _ ,_cecae :=range _cagc ._cggg .Attr {_cefa :=_cecae .Value ;
switch _gfaf :=_cecae .Name .Local ;_gfaf {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_aebe .FillColor =_ggcg .parseColorAttr (_gfaf ,_cefa );case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_aebe .BorderColor =_ggcg .parseColorAttr (_gfaf ,_cefa );
case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_aebe .BorderSize =_ggcg .parseFloatAttr (_gfaf ,_cefa );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_agdg ,_aafga ,_ffaa ,_ggebe :=_ggcg .parseBorderRadiusAttr (_gfaf ,_cefa );
_aebe .SetBorderRadius (_agdg ,_aafga ,_ggebe ,_ffaa );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_aebe .BorderRadiusTopLeft =_ggcg .parseFloatAttr (_gfaf ,_cefa );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_aebe .BorderRadiusTopRight =_ggcg .parseFloatAttr (_gfaf ,_cefa );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_aebe .BorderRadiusBottomLeft =_ggcg .parseFloatAttr (_gfaf ,_cefa );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_aebe .BorderRadiusBottomRight =_ggcg .parseFloatAttr (_gfaf ,_cefa );
default:_ggcg .nodeLogDebug (_cagc ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_gfaf );
};};return _aebe ,nil ;};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_bdgb *LinearShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};func (_cgdd *StyledParagraph )appendChunk (_eabb *TextChunk )*TextChunk {_cgdd ._acbg =append (_cgdd ._acbg ,_eabb );_cgdd .wrapText ();return _eabb ;};

// Append adds a new text chunk to the paragraph.
func (_efbd *StyledParagraph )Append (text string )*TextChunk {_bedf :=NewTextChunk (text ,_efbd ._gfbba );return _efbd .appendChunk (_bedf );};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_fbbf *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_fbbf ._fed =toc ;};func _cacc (_bbag ,_abeee ,_deeb int )[]int {_acbfc :=[]int {};for _dbdac :=_bbag ;_dbdac <=_deeb ;_dbdac +=_abeee {_acbfc =append (_acbfc ,_dbdac );};return _acbfc ;};


// SetAngle sets the rotation angle in degrees.
func (_ca *Block )SetAngle (angleDeg float64 ){_ca ._gd =angleDeg };type shading struct{_edaa Color ;_gdegc bool ;_babg []bool ;_cbgef []*ColorPoint ;};

// IsRelative checks if the positioning is relative.
func (_bgg Positioning )IsRelative ()bool {return _bgg ==PositionRelative };

// Horizontal returns total horizontal (left + right) margin.
func (_cgcg *Margins )Horizontal ()float64 {return _cgcg .Left +_cgcg .Right };

// SetOpacity sets the opacity of the line (0-1).
func (_eaddc *Line )SetOpacity (opacity float64 ){_eaddc ._bceg =opacity };func _fag (_ccdeb []*ColorPoint )*LinearShading {return &LinearShading {_dece :&shading {_edaa :ColorWhite ,_gdegc :false ,_babg :[]bool {false ,false },_cbgef :_ccdeb },_fadfd :&_gec .PdfRectangle {}};
};

// Width returns the cell's width based on the input draw context.
func (_geafb *TableCell )Width (ctx DrawContext )float64 {_ccfe :=float64 (0.0);for _cddd :=0;_cddd < _geafb ._cebg ;_cddd ++{_ccfe +=_geafb ._cedbg ._fgdb [_geafb ._dfdfe +_cddd -1];};_eege :=ctx .Width *_ccfe ;return _eege ;};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_cdaad *_gg .PolyBezierCurve ;_dddge float64 ;_gggfc float64 ;_adeaf Color ;};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_gcaa *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_gcaa ._bag .Left =left ;_gcaa ._bag .Right =right ;_gcaa ._bag .Top =top ;_gcaa ._bag .Bottom =bottom ;};func _eccgg (_bbeef *Creator ,_becb string ,_gced []byte ,_dcdfd *TemplateOptions ,_fbdbc componentRenderer )*templateProcessor {if _dcdfd ==nil {_dcdfd =&TemplateOptions {};
};_dcdfd .init ();if _fbdbc ==nil {_fbdbc =_bbeef ;};return &templateProcessor {creator :_bbeef ,_dffeg :_gced ,_bcaf :_dcdfd ,_degea :_fbdbc ,_fbbbf :_becb };};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_gcd *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _gcd ._cfgae ,_gcd ._ebf ,_gcd ._ccfa ,_gcd ._cfcbb ;};

// The Image type is used to draw an image onto PDF.
type Image struct{_dccf *_gec .XObjectImage ;_adgg *_gec .Image ;_afcf float64 ;_bdebc ,_eaec float64 ;_cbfd ,_gegfd float64 ;_acde Positioning ;_ebaeg HorizontalAlignment ;_gfbb float64 ;_gagce float64 ;_abgdb float64 ;_afgf Margins ;_edgd ,_debb float64 ;
_faaad _dc .StreamEncoder ;_ade FitMode ;_aeef bool ;};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_cecf *_gg .CurvePolygon ;_fegad float64 ;_fecf float64 ;_cedb Color ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_bdda *Invoice )SetBuyerAddress (address *InvoiceAddress ){_bdda ._egaf =address };

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};func (_bbac *Creator )wrapPageIfNeeded (_efe *_gec .PdfPage )(*_gec .PdfPage ,error ){_ggda ,_ddee :=_efe .GetAllContentStreams ();
if _ddee !=nil {return nil ,_ddee ;};_aafg :=_bee .NewContentStreamParser (_ggda );_bgdd ,_ddee :=_aafg .Parse ();if _ddee !=nil {return nil ,_ddee ;};if !_bgdd .HasUnclosedQ (){return nil ,nil ;};_bgdd .WrapIfNeeded ();_gegf ,_ddee :=_dc .MakeStream (_bgdd .Bytes (),_dc .NewFlateEncoder ());
if _ddee !=nil {return nil ,_ddee ;};_efe .Contents =_dc .MakeArray (_gegf );return _efe ,nil ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_gac float64 ;_dbcef float64 ;_eegf float64 ;_gaeb float64 ;_ggfe Positioning ;_fddfa Color ;_gaddb float64 ;_dgde Color ;_eagd float64 ;_fda float64 ;_ddcf Margins ;_bbcaf FitMode ;};func _cdgeb (_cdgdf ,_ebdfb ,_bafcf TextChunk ,_fdege uint ,_gggcg TextStyle )*TOCLine {_agbgc :=_bffb (_gggcg );
_agbgc .SetEnableWrap (true );_agbgc .SetTextAlignment (TextAlignmentLeft );_agbgc .SetMargins (0,0,2,2);_cddca :=&TOCLine {_ebebg :_agbgc ,Number :_cdgdf ,Title :_ebdfb ,Page :_bafcf ,Separator :TextChunk {Text :"\u002e",Style :_gggcg },_cbaed :0,_aabgg :_fdege ,_debg :10,_gefbe :PositionRelative };
_agbgc ._dfcfg .Left =_cddca ._cbaed +float64 (_cddca ._aabgg -1)*_cddca ._debg ;_agbgc ._bcgaf =_cddca .prepareParagraph ;return _cddca ;};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_edfad *TOCLine )SetLink (page int64 ,x ,y float64 ){_edfad ._aecea =x ;_edfad ._fdbf =y ;_edfad ._ccbe =page ;_dbba :=_edfad ._ebebg ._dffcf .Color ;_edfad .Number .Style .Color =_dbba ;_edfad .Title .Style .Color =_dbba ;_edfad .Separator .Style .Color =_dbba ;
_edfad .Page .Style .Color =_dbba ;};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
//	c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//		userPass := []byte("password")
//		ownerPass := []byte("password")
//		err := w.Encrypt(userPass, ownerPass, nil)
//		return err
//	})
func (_bdfd *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_edc *_gec .PdfWriter )error ){_bdfd ._dbbd =pdfWriterAccessFunc ;};

// CurRow returns the currently active cell's row number.
func (_baabg *Table )CurRow ()int {_ffgg :=(_baabg ._faaef -1)/_baabg ._acgc +1;return _ffgg };

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_ecbc *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _ecbc ._fedd [0],_ecbc ._fedd [1]};type pageTransformations struct{_eabg *_ea .Matrix ;_fbac bool ;_eeb bool ;};

// SetBorderWidth sets the border width.
func (_abbgb *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_abbgb ._cdaad .BorderWidth =borderWidth ;};

// NewTable create a new Table with a specified number of columns.
func (_ccgd *Creator )NewTable (cols int )*Table {return _gegcdg (cols )};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_feecf *List )Marker ()*TextChunk {return &_feecf ._egebb };const (AnchorBottomLeft AnchorPoint =iota ;AnchorBottomRight ;AnchorTopLeft ;AnchorTopRight ;AnchorCenter ;AnchorLeft ;AnchorRight ;AnchorTop ;AnchorBottom ;);func _dgcfd (_ddge *Block ,_cdba *StyledParagraph ,_fegbc [][]*TextChunk ,_eeccf DrawContext )(DrawContext ,[][]*TextChunk ,error ){_feea :=1;
_bccd :=_dc .PdfObjectName (_e .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_feea ));for _ddge ._fb .HasFontByName (_bccd ){_feea ++;_bccd =_dc .PdfObjectName (_e .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_feea ));};_bgba :=_ddge ._fb .SetFontByName (_bccd ,_cdba ._gfbba .Font .ToPdfObject ());
if _bgba !=nil {return _eeccf ,nil ,_bgba ;};_feea ++;_bdca :=_bccd ;_bbdf :=_cdba ._gfbba .FontSize ;_gbfa :=_cdba ._ebdeg .IsRelative ();var _fccc [][]_dc .PdfObjectName ;var _bcacf [][]*TextChunk ;var _aacf float64 ;for _eeba ,_gfabf :=range _fegbc {var _cbfbdc []_dc .PdfObjectName ;
var _ccda float64 ;if len (_gfabf )> 0{_ccda =_gfabf [0].Style .FontSize ;};for _ ,_dbeacf :=range _gfabf {_bfae :=_dbeacf .Style ;if _dbeacf .Text !=""&&_bfae .FontSize > _ccda {_ccda =_bfae .FontSize ;};if _ccda > _eeccf .PageHeight {return _eeccf ,nil ,_d .New ("\u0050\u0061\u0072\u0061\u0067\u0072a\u0070\u0068\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020\u006ca\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0070\u0061\u0067\u0065 \u0068e\u0069\u0067\u0068\u0074");
};_bccd =_dc .PdfObjectName (_e .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_feea ));_ggffb :=_ddge ._fb .SetFontByName (_bccd ,_bfae .Font .ToPdfObject ());if _ggffb !=nil {return _eeccf ,nil ,_ggffb ;};_cbfbdc =append (_cbfbdc ,_bccd );_feea ++;
};_ccda *=_cdba ._cdadd ;if _gbfa &&_aacf +_ccda > _eeccf .Height {_bcacf =_fegbc [_eeba :];_fegbc =_fegbc [:_eeba ];break ;};_aacf +=_ccda ;_fccc =append (_fccc ,_cbfbdc );};_dbcc ,_egfab ,_cbedc :=_cdba .getLineMetrics (0);_bafca ,_cgbda :=_dbcc *_cdba ._cdadd ,_egfab *_cdba ._cdadd ;
if len (_fegbc )==0{return _eeccf ,_bcacf ,nil ;};_eacb :=_bee .NewContentCreator ();_eacb .Add_q ();_fabab :=_cgbda ;if _cdba ._ggdge ==TextVerticalAlignmentCenter {_fabab =_egfab +(_dbcc +_cbedc -_egfab )/2+(_cgbda -_egfab )/2;};_dbdge :=_eeccf .PageHeight -_eeccf .Y -_fabab ;
_eacb .Translate (_eeccf .X ,_dbdge );_afcg :=_dbdge ;if _cdba ._dafa !=0{_eacb .RotateDeg (_cdba ._dafa );};if _cdba ._affg ==TextOverflowHidden {_eacb .Add_re (0,-_aacf +_bafca +1,_cdba ._dabc ,_aacf ).Add_W ().Add_n ();};_eacb .Add_BT ();var _cbggf []*_gg .BasicLine ;
for _cba ,_gagfd :=range _fegbc {_debac :=_eeccf .X ;var _gccc float64 ;if len (_gagfd )> 0{_gccc =_gagfd [0].Style .FontSize ;};_dbcc ,_ ,_cbedc =_cdba .getLineMetrics (_cba );_cgbda =(_dbcc +_cbedc );for _ ,_bcegb :=range _gagfd {_caee :=&_bcegb .Style ;
if _bcegb .Text !=""&&_caee .FontSize > _gccc {_gccc =_caee .FontSize ;};if _cgbda > _gccc {_gccc =_cgbda ;};};if _cba !=0{_eacb .Add_TD (0,-_gccc *_cdba ._cdadd );_afcg -=_gccc *_cdba ._cdadd ;};_cdgef :=_cba ==len (_fegbc )-1;var (_dbecf float64 ;_ebege float64 ;
_gcff *fontMetrics ;_fbedf float64 ;_dddbe uint ;);var _acdef []float64 ;for _ ,_gdgd :=range _gagfd {_ccdag :=&_gdgd .Style ;if _ccdag .FontSize > _ebege {_ebege =_ccdag .FontSize ;_gcff =_baeef (_gdgd .Style .Font ,_ccdag .FontSize );};if _cgbda > _ebege {_ebege =_cgbda ;
};_febbf ,_aecg :=_ccdag .Font .GetRuneMetrics (' ');if _febbf .Wx ==0&&_ccdag .MultiFont !=nil {_febbf ,_aecg =_ccdag .MultiFont .GetRuneMetrics (' ');_ccdag .MultiFont .Reset ();};if !_aecg {return _eeccf ,nil ,_d .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _aggbb uint ;var _eaag float64 ;_fddg :=len (_gdgd .Text );for _ggcfg ,_gfbc :=range _gdgd .Text {if _gfbc ==' '{_aggbb ++;continue ;};if _gfbc =='\u000A'{continue ;};_gfdf ,_ddfgc :=_ccdag .Font .GetRuneMetrics (_gfbc );if _gfdf .Wx ==0&&_ccdag .MultiFont !=nil {_gfdf ,_ddfgc =_ccdag .MultiFont .GetRuneMetrics (' ');
_ccdag .MultiFont .Reset ();};if !_ddfgc {_bd .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_gfbc );return _eeccf ,nil ,_d .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");
};_eaag +=_ccdag .FontSize *_gfdf .Wx *_ccdag .horizontalScale ();if _ggcfg !=_fddg -1{_eaag +=_ccdag .CharSpacing *1000.0;};};_acdef =append (_acdef ,_eaag );_dbecf +=_eaag ;_fbedf +=float64 (_aggbb )*_febbf .Wx *_ccdag .FontSize *_ccdag .horizontalScale ();
_dddbe +=_aggbb ;};_ebege *=_cdba ._cdadd ;var _gddf []_dc .PdfObject ;_fegf :=_cdba ._dabc *1000.0;if _cdba ._ebcg ==TextAlignmentJustify {if _dddbe > 0&&!_cdgef {_fbedf =(_fegf -_dbecf )/float64 (_dddbe )/_bbdf ;};}else if _cdba ._ebcg ==TextAlignmentCenter {_aded :=(_fegf -_dbecf -_fbedf )/2;
_gbfe :=_aded /_bbdf ;_gddf =append (_gddf ,_dc .MakeFloat (-_gbfe ));_debac +=_aded /1000.0;}else if _cdba ._ebcg ==TextAlignmentRight {_efeg :=(_fegf -_dbecf -_fbedf );_agdb :=_efeg /_bbdf ;_gddf =append (_gddf ,_dc .MakeFloat (-_agdb ));_debac +=_efeg /1000.0;
};if len (_gddf )> 0{_eacb .Add_Tf (_bdca ,_bbdf ).Add_TL (_bbdf *_cdba ._cdadd ).Add_TJ (_gddf ...);};_ggeg :=0.0;for _ggcc ,_degac :=range _gagfd {_gfaa :=&_degac .Style ;_acccf :=_bdca ;_ccefd :=_bbdf ;_fagc :=_gfaa .OutlineColor !=nil ;_badgd :=_gfaa .HorizontalScaling !=DefaultHorizontalScaling ;
_edaab :=_gfaa .OutlineSize !=1;if _edaab {_eacb .Add_w (_gfaa .OutlineSize );};_ddcae :=_gfaa .RenderingMode !=TextRenderingModeFill ;if _ddcae {_eacb .Add_Tr (int64 (_gfaa .RenderingMode ));};_cbaf :=_gfaa .CharSpacing !=0;if _cbaf {_eacb .Add_Tc (_gfaa .CharSpacing );
};_fccgc :=_gfaa .TextRise !=0;if _fccgc {_eacb .Add_Ts (_gfaa .TextRise );};if _degac .VerticalAlignment !=TextVerticalAlignmentBaseline {_cage :=_baeef (_degac .Style .Font ,_gfaa .FontSize );switch _degac .VerticalAlignment {case TextVerticalAlignmentCenter :_ggeg =_gcff ._eceag /2-_cage ._eceag /2;
case TextVerticalAlignmentBottom :_ggeg =_gcff ._fcef -_cage ._fcef ;case TextVerticalAlignmentTop :_ggeg =_egfab -_gfaa .FontSize ;};if _ggeg !=0.0{_eacb .Translate (0,_ggeg );};};if _cdba ._ebcg !=TextAlignmentJustify ||_cdgef {_dbgd ,_dbcff :=_gfaa .Font .GetRuneMetrics (' ');
if !_dbcff {return _eeccf ,nil ,_d .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_acccf =_fccc [_cba ][_ggcc ];_ccefd =_gfaa .FontSize ;
_fbedf =_dbgd .Wx *_gfaa .horizontalScale ();};_gcdc :=_gfaa .Font .Encoder ();var _bbced []byte ;var _eeaed bool ;_ggagf :=_gfaa .Font ;for _ ,_ecdd :=range _degac .Text {if _ecdd =='\u000A'{continue ;};if _ecdd ==' '{if len (_bbced )> 0{if _fagc {_eacb .SetStrokingColor (_dbceg (_gfaa .OutlineColor ));
};if _badgd {_eacb .Add_Tz (_gfaa .HorizontalScaling );};_cfbbf :=_fccc [_cba ][_ggcc ];if _eeaed {_cfbbf =_dc .PdfObjectName (_e .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_feea ));_aaef :=_ddge ._fb .SetFontByName (_cfbbf ,_ggagf .ToPdfObject ());
if _aaef !=nil {return _eeccf ,nil ,_aaef ;};_feea ++;_eeaed =false ;_gcdc =_gfaa .Font .Encoder ();};_eacb .SetNonStrokingColor (_dbceg (_gfaa .Color )).Add_Tf (_cfbbf ,_gfaa .FontSize ).Add_TJ ([]_dc .PdfObject {_dc .MakeStringFromBytes (_bbced )}...);
_bbced =nil ;};if _badgd {_eacb .Add_Tz (DefaultHorizontalScaling );};_eacb .Add_Tf (_acccf ,_ccefd ).Add_TJ ([]_dc .PdfObject {_dc .MakeFloat (-_fbedf )}...);_acdef [_ggcc ]+=_fbedf *_ccefd ;}else {if _ ,_dabf :=_gcdc .RuneToCharcode (_ecdd );!_dabf {if _gfaa .MultiFont !=nil {_aeba ,_aaaf :=_gfaa .MultiFont .Encoder (_ecdd );
if _aaaf {if len (_bbced )!=0{_fffeg :=_dc .PdfObjectName (_e .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_feea ));_gcfbb :=_ddge ._fb .SetFontByName (_acccf ,_ggagf .ToPdfObject ());if _gcfbb !=nil {return _eeccf ,nil ,_gcfbb ;};_eacb .SetNonStrokingColor (_dbceg (_gfaa .Color )).Add_Tf (_fffeg ,_gfaa .FontSize ).Add_TJ ([]_dc .PdfObject {_dc .MakeStringFromBytes (_bbced )}...);
_feea ++;_bbced =nil ;};_gcdc =_aeba ;_eeaed =true ;_ggagf =_gfaa .MultiFont .CurrentFont ;};}else {_bgba =UnsupportedRuneError {Message :_e .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_ecdd ,_ecdd ),Rune :_ecdd };
_eeccf ._ddgg =append (_eeccf ._ddgg ,_bgba );_bd .Log .Debug (_bgba .Error ());if _eeccf ._baecf <=0{continue ;};_ecdd =_eeccf ._baecf ;};};_cagd :=_gcdc .Encode (string (_ecdd ));_bbced =append (_bbced ,_cagd ...);};if _gfaa .MultiFont !=nil {_gfaa .MultiFont .Reset ();
};};if len (_bbced )> 0{if _fagc {_eacb .SetStrokingColor (_dbceg (_gfaa .OutlineColor ));};if _badgd {_eacb .Add_Tz (_gfaa .HorizontalScaling );};_cgedf :=_fccc [_cba ][_ggcc ];if _eeaed {_cgedf =_dc .PdfObjectName (_e .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_feea ));
_ggbdb :=_ddge ._fb .SetFontByName (_cgedf ,_ggagf .ToPdfObject ());if _ggbdb !=nil {return _eeccf ,nil ,_ggbdb ;};_feea ++;_eeaed =false ;};_eacb .SetNonStrokingColor (_dbceg (_gfaa .Color )).Add_Tf (_cgedf ,_gfaa .FontSize ).Add_TJ ([]_dc .PdfObject {_dc .MakeStringFromBytes (_bbced )}...);
};_feadg :=_acdef [_ggcc ]/1000.0;if _gfaa .Underline {_dabd :=_gfaa .UnderlineStyle .Color ;if _dabd ==nil {_dabd =_degac .Style .Color ;};_dfgg ,_efefb ,_edege :=_dabd .ToRGB ();_eabbe :=_debac -_eeccf .X ;_cccd :=_afcg -_dbdge +_gfaa .TextRise -_gfaa .UnderlineStyle .Offset ;
_cbggf =append (_cbggf ,&_gg .BasicLine {X1 :_eabbe ,Y1 :_cccd ,X2 :_eabbe +_feadg ,Y2 :_cccd ,LineWidth :_degac .Style .UnderlineStyle .Thickness ,LineColor :_gec .NewPdfColorDeviceRGB (_dfgg ,_efefb ,_edege )});};if _degac ._aacgc !=nil {var _fccd *_dc .PdfObjectArray ;
if !_degac ._ggebf {switch _aedc :=_degac ._aacgc .GetContext ().(type ){case *_gec .PdfAnnotationLink :_fccd =_dc .MakeArray ();_aedc .Rect =_fccd ;_cgeff ,_cgba :=_aedc .Dest .(*_dc .PdfObjectArray );if _cgba &&_cgeff .Len ()==5{_gdca ,_fdfg :=_cgeff .Get (1).(*_dc .PdfObjectName );
if _fdfg &&_gdca .String ()=="\u0058\u0059\u005a"{_feca ,_dbab :=_dc .GetNumberAsFloat (_cgeff .Get (3));if _dbab ==nil {_cgeff .Set (3,_dc .MakeFloat (_eeccf .PageHeight -_feca ));};};};};_degac ._ggebf =true ;};if _fccd !=nil {_abfc :=_gg .NewPoint (_debac -_eeccf .X ,_afcg +_gfaa .TextRise -_dbdge ).Rotate (_cdba ._dafa );
_abfc .X +=_eeccf .X ;_abfc .Y +=_dbdge ;_gbg ,_ccfcc ,_cagfa ,_dacdf :=_gdag (_feadg ,_ebege ,_cdba ._dafa );_abfc .X +=_gbg ;_abfc .Y +=_ccfcc ;_fccd .Clear ();_fccd .Append (_dc .MakeFloat (_abfc .X ));_fccd .Append (_dc .MakeFloat (_abfc .Y ));_fccd .Append (_dc .MakeFloat (_abfc .X +_cagfa ));
_fccd .Append (_dc .MakeFloat (_abfc .Y +_dacdf ));};_ddge .AddAnnotation (_degac ._aacgc );};_debac +=_feadg ;if _edaab {_eacb .Add_w (1.0);};if _fagc {_eacb .Add_RG (0.0,0.0,0.0);};if _ddcae {_eacb .Add_Tr (int64 (TextRenderingModeFill ));};if _cbaf {_eacb .Add_Tc (0);
};if _fccgc {_eacb .Add_Ts (0);};if _badgd {_eacb .Add_Tz (DefaultHorizontalScaling );};if _ggeg !=0.0{_eacb .Translate (0,-_ggeg );_ggeg =0.0;};};};_eacb .Add_ET ();for _ ,_dgea :=range _cbggf {_eacb .SetStrokingColor (_dgea .LineColor ).Add_w (_dgea .LineWidth ).Add_m (_dgea .X1 ,_dgea .Y1 ).Add_l (_dgea .X2 ,_dgea .Y2 ).Add_s ();
};_eacb .Add_Q ();_afee :=_eacb .Operations ();_afee .WrapIfNeeded ();_ddge .addContents (_afee );if _gbfa {_ageae :=_aacf ;_eeccf .Y +=_ageae ;_eeccf .Height -=_ageae ;if _eeccf .Inline {_eeccf .X +=_cdba .Width ()+_cdba ._dfcfg .Right ;};};return _eeccf ,_bcacf ,nil ;
};func _ggfeb (_gdbdd string ,_gegb ,_fcgf TextStyle )*TOC {_dcbaf :=_fcgf ;_dcbaf .FontSize =14;_fbfbd :=_bffb (_dcbaf );_fbfbd .SetEnableWrap (true );_fbfbd .SetTextAlignment (TextAlignmentLeft );_fbfbd .SetMargins (0,0,0,5);_bbgec :=_fbfbd .Append (_gdbdd );
_bbgec .Style =_dcbaf ;return &TOC {_eeabf :_fbfbd ,_gbece :[]*TOCLine {},_cgagb :_gegb ,_dbgcb :_gegb ,_fbfaf :_gegb ,_ebcc :_gegb ,_cadb :"\u002e",_cacgf :10,_gcgec :Margins {0,0,2,2},_bced :PositionRelative ,_ddged :_gegb ,_gfge :true };};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_deee *List )Width ()float64 {return 0};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_cabf *LinearShading )SetBackgroundColor (backgroundColor Color ){_cabf ._dece .SetBackgroundColor (backgroundColor );};

// BorderOpacity returns the border opacity of the rectangle (0-1).
func (_abfed *Rectangle )BorderOpacity ()float64 {return _abfed ._gcdb };func (_fea *Creator )setActivePage (_dbf *_gec .PdfPage ){_fea ._cgc =_dbf };

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_eafd *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dfafa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cgdga ,_gbcab :=_dfafa .setOpacity (_eafd ._dddge ,_eafd ._gggfc );if _gbcab !=nil {return nil ,ctx ,_gbcab ;
};_efdf :=_eafd ._cdaad ;_efdf .FillEnabled =_efdf .FillColor !=nil ;var (_ggfbc =ctx .PageHeight ;_agge =_efdf .Curves ;_acb =make ([]_gg .CubicBezierCurve ,0,len (_efdf .Curves )););_bdeda :=_gec .PdfRectangle {};for _deec :=range _efdf .Curves {_aace :=_agge [_deec ];
_aace .P0 .Y =_ggfbc -_aace .P0 .Y ;_aace .P1 .Y =_ggfbc -_aace .P1 .Y ;_aace .P2 .Y =_ggfbc -_aace .P2 .Y ;_aace .P3 .Y =_ggfbc -_aace .P3 .Y ;_acb =append (_acb ,_aace );_dbbc :=_aace .GetBounds ();if _deec ==0{_bdeda =_dbbc ;}else {_bdeda .Llx =_ag .Min (_bdeda .Llx ,_dbbc .Llx );
_bdeda .Lly =_ag .Min (_bdeda .Lly ,_dbbc .Lly );_bdeda .Urx =_ag .Max (_bdeda .Urx ,_dbbc .Urx );_bdeda .Ury =_ag .Max (_bdeda .Ury ,_dbbc .Ury );};};_efdf .Curves =_acb ;defer func (){_efdf .Curves =_agge }();if _efdf .FillEnabled {_ebca :=_eecec (_dfafa ,_eafd ._cdaad .FillColor ,_eafd ._adeaf ,func ()Rectangle {return Rectangle {_edaf :_bdeda .Llx ,_dgedd :_bdeda .Lly ,_dgdba :_bdeda .Width (),_gfef :_bdeda .Height ()};
});if _ebca !=nil {return nil ,ctx ,_ebca ;};};_eeacf ,_ ,_gbcab :=_efdf .Draw (_cgdga );if _gbcab !=nil {return nil ,ctx ,_gbcab ;};if _gbcab =_dfafa .addContentsByString (string (_eeacf ));_gbcab !=nil {return nil ,ctx ,_gbcab ;};return []*Block {_dfafa },ctx ,nil ;
};func (_eeedd *templateProcessor )parseBorderRadiusAttr (_ffbcd ,_faac string )(_begef ,_eddg ,_afdgd ,_bbbcb float64 ){_bd .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_ffbcd ,_faac );
switch _ddbd :=_bea .Fields (_faac );len (_ddbd ){case 1:_begef ,_ =_fa .ParseFloat (_ddbd [0],64);_eddg =_begef ;_afdgd =_begef ;_bbbcb =_begef ;case 2:_begef ,_ =_fa .ParseFloat (_ddbd [0],64);_afdgd =_begef ;_eddg ,_ =_fa .ParseFloat (_ddbd [1],64);
_bbbcb =_eddg ;case 3:_begef ,_ =_fa .ParseFloat (_ddbd [0],64);_eddg ,_ =_fa .ParseFloat (_ddbd [1],64);_bbbcb =_eddg ;_afdgd ,_ =_fa .ParseFloat (_ddbd [2],64);case 4:_begef ,_ =_fa .ParseFloat (_ddbd [0],64);_eddg ,_ =_fa .ParseFloat (_ddbd [1],64);
_afdgd ,_ =_fa .ParseFloat (_ddbd [2],64);_bbbcb ,_ =_fa .ParseFloat (_ddbd [3],64);};return _begef ,_eddg ,_afdgd ,_bbbcb ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_dfgc *Invoice )SetNoteHeadingStyle (style TextStyle ){_dfgc ._fafa =style };

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_aacgc *_gec .PdfAnnotation ;_ggebf bool ;

// The vertical alignment of the text chunk.
VerticalAlignment TextVerticalAlignment ;};var _adc =_bf .MustCompile ("\u005c\u0064\u002b");

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_acbg []*TextChunk ;_gfbba TextStyle ;_dffcf TextStyle ;_ebcg TextAlignment ;_ggdge TextVerticalAlignment ;_cdadd float64 ;_cafa bool ;_dabc float64 ;_gedfe bool ;_cfdd bool ;_affg TextOverflow ;_dafa float64 ;_dfcfg Margins ;
_ebdeg Positioning ;_fefbd float64 ;_ddfge float64 ;_eddbe float64 ;_ccdbc float64 ;_dbgba [][]*TextChunk ;_bcgaf func (_ccgfc *StyledParagraph ,_gedd DrawContext );};

// SetSideBorderWidth sets the cell's side border width.
func (_eddegd *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_eddegd ._bbeee =width ;_eddegd ._ecba =width ;_eddegd ._dceac =width ;_eddegd ._degae =width ;case CellBorderSideTop :_eddegd ._bbeee =width ;
case CellBorderSideBottom :_eddegd ._ecba =width ;case CellBorderSideLeft :_eddegd ._dceac =width ;case CellBorderSideRight :_eddegd ._degae =width ;};};func _eecec (_fdebc *Block ,_aggge _gec .PdfColor ,_feceb Color ,_edfe func ()Rectangle )error {switch _addbb :=_aggge .(type ){case *_gec .PdfColorPatternType2 :_fcge ,_adad :=_feceb .(*LinearShading );
if !_adad {return _e .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u004c\u0069\u006e\u0065\u0061\u0072\u0053\u0068\u0061d\u0069\u006e\u0067");};_bbgf :=_edfe ();_fcge .SetBoundingBox (_bbgf ._edaf ,_bbgf ._dgedd ,_bbgf ._dgdba ,_bbgf ._gfef );
_debd ,_fcdbe :=_fcge .AddPatternResource (_fdebc );if _fcdbe !=nil {return _e .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_fcdbe );
};_addbb .PatternName =_debd ;case *_gec .PdfColorPatternType3 :_cfae ,_ccgg :=_feceb .(*RadialShading );if !_ccgg {return _e .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0052\u0061\u0064\u0069\u0061\u006c\u0053\u0068\u0061d\u0069\u006e\u0067");
};_ccdb :=_edfe ();_cfae .SetBoundingBox (_ccdb ._edaf ,_ccdb ._dgedd ,_ccdb ._dgdba ,_ccdb ._gfef );_bdffc ,_fcggf :=_cfae .AddPatternResource (_fdebc );if _fcggf !=nil {return _e .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_fcggf );
};_addbb .PatternName =_bdffc ;};return nil ;};

// Rows returns the total number of rows the table has.
func (_baed *Table )Rows ()int {return _baed ._gebff };

// TextAlignment options for paragraph.
type TextAlignment int ;

// NewRadialGradientColor creates a radial gradient color that could act as a color in other componenents.
// Note: The innerRadius must be smaller than outerRadius for the circle to render properly.
func (_cegb *Creator )NewRadialGradientColor (x float64 ,y float64 ,innerRadius float64 ,outerRadius float64 ,colorPoints []*ColorPoint )*RadialShading {return _ecdeb (x ,y ,innerRadius ,outerRadius ,colorPoints );};var (ErrContentNotFit =_d .New ("\u0043\u0061\u006e\u006e\u006ft\u0020\u0066\u0069\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020i\u006e\u0074\u006f\u0020\u0061\u006e\u0020\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0073\u0070\u0061\u0063\u0065");
);

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_adfcf *LinearShading )SetAntiAlias (enable bool ){_adfcf ._dece .SetAntiAlias (enable )};func _efdb (_fadc []_gg .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_cdaad :&_gg .PolyBezierCurve {Curves :_fadc ,BorderColor :_gec .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_dddge :1.0,_gggfc :1.0};
};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_ffaf :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_bd .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ffaf ;
};var _baeg ,_gfd ,_gaec int ;if len (hexStr )==4{var _ebdd ,_eagg ,_bacf int ;_dcdcb ,_gbaa :=_e .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_ebdd ,&_eagg ,&_bacf );if _gbaa !=nil {_bd .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_gbaa );
return _ffaf ;};if _dcdcb !=3{_bd .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ffaf ;};_baeg =_ebdd *16+_ebdd ;_gfd =_eagg *16+_eagg ;_gaec =_bacf *16+_bacf ;}else {_dgc ,_acgg :=_e .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_baeg ,&_gfd ,&_gaec );
if _acgg !=nil {_bd .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ffaf ;};if _dgc !=3{_bd .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_dgc );
return _ffaf ;};};_fece :=float64 (_baeg )/255.0;_aaaa :=float64 (_gfd )/255.0;_fdda :=float64 (_gaec )/255.0;_ffaf ._dfgea =_fece ;_ffaf ._eee =_aaaa ;_ffaf ._ddab =_fdda ;return _ffaf ;};func _bgfea (_ebfce *templateProcessor ,_fabbd *templateNode )(interface{},error ){return _ebfce .parseBackground (_fabbd );
};func (_gebf *Division )split (_gegcd DrawContext )(_agac ,_ffdea *Division ){var (_gceg float64 ;_cbbb ,_beef []VectorDrawable ;);_cbce :=_gegcd .Width -_gebf ._dedd .Left -_gebf ._dedd .Right -_gebf ._gcag .Left -_gebf ._gcag .Right ;for _aced ,_bbab :=range _gebf ._dcdd {_gceg +=_fafba (_bbab ,_cbce );
if _gceg < _gegcd .Height {_cbbb =append (_cbbb ,_bbab );}else {_beef =_gebf ._dcdd [_aced :];break ;};};if len (_cbbb )> 0{_agac =_gaddc ();*_agac =*_gebf ;_agac ._dcdd =_cbbb ;if _gebf ._geaa !=nil {_agac ._geaa =&Background {};*_agac ._geaa =*_gebf ._geaa ;
};};if len (_beef )> 0{_ffdea =_gaddc ();*_ffdea =*_gebf ;_ffdea ._dcdd =_beef ;if _gebf ._geaa !=nil {_ffdea ._geaa =&Background {};*_ffdea ._geaa =*_gebf ._geaa ;};};return _agac ,_ffdea ;};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// NewGraphicSVGFromFile creates a graphic SVG from a file.
func NewGraphicSVGFromFile (path string )(*GraphicSVG ,error ){return _bcga (path )};func _agd (_ccgf *_bee .ContentStreamOperations ,_cff *_gec .PdfPageResources ,_gaa *_bee .ContentStreamOperations ,_geb *_gec .PdfPageResources )error {_bbc :=map[_dc .PdfObjectName ]_dc .PdfObjectName {};
_cdc :=map[_dc .PdfObjectName ]_dc .PdfObjectName {};_cgb :=map[_dc .PdfObjectName ]_dc .PdfObjectName {};_ebc :=map[_dc .PdfObjectName ]_dc .PdfObjectName {};_bgf :=map[_dc .PdfObjectName ]_dc .PdfObjectName {};_cca :=map[_dc .PdfObjectName ]_dc .PdfObjectName {};
for _ ,_eef :=range *_gaa {switch _eef .Operand {case "\u0044\u006f":if len (_eef .Params )==1{if _fbe ,_bgb :=_eef .Params [0].(*_dc .PdfObjectName );_bgb {if _ ,_aa :=_bbc [*_fbe ];!_aa {var _aeaa _dc .PdfObjectName ;_ffc ,_ :=_geb .GetXObjectByName (*_fbe );
if _ffc !=nil {_aeaa =*_fbe ;for {_abff ,_ :=_cff .GetXObjectByName (_aeaa );if _abff ==nil ||_abff ==_ffc {break ;};_aeaa =*_dc .MakeName (_ddg (_aeaa .String ()));};};_cff .SetXObjectByName (_aeaa ,_ffc );_bbc [*_fbe ]=_aeaa ;};_beaf :=_bbc [*_fbe ];
_eef .Params [0]=&_beaf ;};};case "\u0054\u0066":if len (_eef .Params )==2{if _cea ,_bde :=_eef .Params [0].(*_dc .PdfObjectName );_bde {if _ ,_dce :=_cdc [*_cea ];!_dce {_cggf ,_fbd :=_geb .GetFontByName (*_cea );_bfc :=*_cea ;if _fbd &&_cggf !=nil {_bfc =_dac (_cea .String (),_cggf ,_cff );
};_cff .SetFontByName (_bfc ,_cggf );_cdc [*_cea ]=_bfc ;};_cbg :=_cdc [*_cea ];_eef .Params [0]=&_cbg ;};};case "\u0043\u0053","\u0063\u0073":if len (_eef .Params )==1{if _fec ,_abd :=_eef .Params [0].(*_dc .PdfObjectName );_abd {if _ ,_bbg :=_cgb [*_fec ];
!_bbg {var _ec _dc .PdfObjectName ;_fca ,_egf :=_geb .GetColorspaceByName (*_fec );if _egf {_ec =*_fec ;for {_beb ,_ece :=_cff .GetColorspaceByName (_ec );if !_ece ||_fca ==_beb {break ;};_ec =*_dc .MakeName (_ddg (_ec .String ()));};_cff .SetColorspaceByName (_ec ,_fca );
_cgb [*_fec ]=_ec ;}else {_bd .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _egfg ,_abg :=_cgb [*_fec ];_abg {_eef .Params [0]=&_egfg ;}else {_bd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_fec );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_eef .Params )==1{if _fce ,_aba :=_eef .Params [0].(*_dc .PdfObjectName );_aba {if _ ,_fgd :=_ebc [*_fce ];!_fgd {var _egc _dc .PdfObjectName ;_ggdd ,_fbb :=_geb .GetPatternByName (*_fce );if _fbb {_egc =*_fce ;
for {_gad ,_gebb :=_cff .GetPatternByName (_egc );if !_gebb ||_gad ==_ggdd {break ;};_egc =*_dc .MakeName (_ddg (_egc .String ()));};_abdb :=_cff .SetPatternByName (_egc ,_ggdd .ToPdfObject ());if _abdb !=nil {return _abdb ;};_ebc [*_fce ]=_egc ;};};if _deb ,_eeac :=_ebc [*_fce ];
_eeac {_eef .Params [0]=&_deb ;};};};case "\u0073\u0068":if len (_eef .Params )==1{if _ecf ,_dcg :=_eef .Params [0].(*_dc .PdfObjectName );_dcg {if _ ,_egd :=_bgf [*_ecf ];!_egd {var _afdb _dc .PdfObjectName ;_egff ,_bff :=_geb .GetShadingByName (*_ecf );
if _bff {_afdb =*_ecf ;for {_ebd ,_gcf :=_cff .GetShadingByName (_afdb );if !_gcf ||_egff ==_ebd {break ;};_afdb =*_dc .MakeName (_ddg (_afdb .String ()));};_ggg :=_cff .SetShadingByName (_afdb ,_egff .ToPdfObject ());if _ggg !=nil {_bd .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_ggg );
return _ggg ;};_bgf [*_ecf ]=_afdb ;}else {_bd .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _aad ,_edb :=_bgf [*_ecf ];_edb {_eef .Params [0]=&_aad ;}else {_bd .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_ecf );
};};};case "\u0067\u0073":if len (_eef .Params )==1{if _bcdd ,_aaa :=_eef .Params [0].(*_dc .PdfObjectName );_aaa {if _ ,_fad :=_cca [*_bcdd ];!_fad {var _aac _dc .PdfObjectName ;_cbgc ,_egce :=_geb .GetExtGState (*_bcdd );if _egce {_aac =*_bcdd ;for {_bbb ,_fab :=_cff .GetExtGState (_aac );
if !_fab ||_cbgc ==_bbb {break ;};_aac =*_dc .MakeName (_ddg (_aac .String ()));};};_cff .AddExtGState (_aac ,_cbgc );_cca [*_bcdd ]=_aac ;};_dde :=_cca [*_bcdd ];_eef .Params [0]=&_dde ;};};};*_ccgf =append (*_ccgf ,_eef );};return nil ;};func (_dfdb *templateProcessor )processGradientColorPair (_gcca []string )(_fafdc []Color ,_afdad []float64 ){for _ ,_efbdf :=range _gcca {var (_fcgac =_bea .Fields (_efbdf );
_fdba =len (_fcgac ););if _fdba ==0{continue ;};_dcedd :="";if _fdba > 1{_dcedd =_bea .TrimSpace (_fcgac [1]);};_cgddb :=-1.0;if _bea .HasSuffix (_dcedd ,"\u0025"){_agga ,_fccae :=_fa .ParseFloat (_dcedd [:len (_dcedd )-1],64);if _fccae !=nil {_bd .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0069n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_fccae );
};_cgddb =_agga /100.0;};_ceec :=_dfdb .parseColor (_bea .TrimSpace (_fcgac [0]));if _ceec !=nil {_fafdc =append (_fafdc ,_ceec );_afdad =append (_afdad ,_cgddb );};};if len (_fafdc )!=len (_afdad ){_bd .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u006c\u0069\u006e\u0065\u0061\u0072\u0020\u0067\u0072\u0061\u0064i\u0065\u006e\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0064\u0065\u0066\u0069\u006e\u0069\u0074\u0069\u006f\u006e\u0021");
return nil ,nil ;};_ecee :=-1;_ddfba :=0.0;for _bacfgg ,_ebbd :=range _afdad {if _ebbd ==-1.0{if _bacfgg ==0{_ebbd =0.0;_afdad [_bacfgg ]=0.0;continue ;};_ecee ++;if _bacfgg < len (_afdad )-1{continue ;}else {_ebbd =1.0;_afdad [_bacfgg ]=1.0;};};_ebfcc :=_ecee +1;
for _cfcff :=_bacfgg -_ecee ;_cfcff < _bacfgg ;_cfcff ++{_afdad [_cfcff ]=_ddfba +(float64 (_cfcff )*(_ebbd -_ddfba )/float64 (_ebfcc ));};_ddfba =_ebbd ;_ecee =-1;};return _fafdc ,_afdad ;};func (_cafbd *Invoice )generateNoteBlocks (_efbg DrawContext )([]*Block ,DrawContext ,error ){_gcbg :=_gaddc ();
_aedee :=append ([][2]string {_cafbd ._efed ,_cafbd ._fcgg },_cafbd ._gede ...);for _ ,_bcff :=range _aedee {if _bcff [1]!=""{_dcab :=_cafbd .drawSection (_bcff [0],_bcff [1]);for _ ,_fede :=range _dcab {_gcbg .Add (_fede );};_fbdb :=_bffb (_cafbd ._bebbc );
_fbdb .SetMargins (0,0,10,0);_gcbg .Add (_fbdb );};};return _gcbg .GeneratePageBlocks (_efbg );};

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_cbf *Division )SetMargins (left ,right ,top ,bottom float64 ){_cbf ._dedd .Left =left ;_cbf ._dedd .Right =right ;_cbf ._dedd .Top =top ;_cbf ._dedd .Bottom =bottom ;};func (_cgfb *StyledParagraph )wrapWordChunks (){if !_cgfb ._gedfe {return ;};
var (_efdfd []*TextChunk ;_daefb *_gec .PdfFont ;);for _ ,_baag :=range _cgfb ._acbg {_cccb :=[]rune (_baag .Text );if _daefb ==nil {_daefb =_baag .Style .Font ;};_eddad :=_baag ._aacgc ;_gebbc :=_baag .VerticalAlignment ;if len (_efdfd )> 0{if len (_cccb )==1&&_ee .IsPunct (_cccb [0])&&_baag .Style .Font ==_daefb {_gedg :=[]rune (_efdfd [len (_efdfd )-1].Text );
_efdfd [len (_efdfd )-1].Text =string (append (_gedg ,_cccb [0]));continue ;}else {_ ,_cecc :=_fa .Atoi (_baag .Text );if _cecc ==nil {_eafb :=[]rune (_efdfd [len (_efdfd )-1].Text );_dgbd :=len (_eafb );if _dgbd >=2{_ ,_cbfbd :=_fa .Atoi (string (_eafb [_dgbd -2]));
if _cbfbd ==nil &&_ee .IsPunct (_eafb [_dgbd -1]){_efdfd [len (_efdfd )-1].Text =string (append (_eafb ,_cccb ...));continue ;};};};};};_dded ,_cegg :=_edca (_baag .Text );if _cegg !=nil {_bd .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_cegg );
_dded =[]string {_baag .Text };};for _ ,_ggfgg :=range _dded {_ecdg :=NewTextChunk (_ggfgg ,_baag .Style );_ecdg ._aacgc =_edaac (_eddad );_ecdg .VerticalAlignment =_gebbc ;_efdfd =append (_efdfd ,_ecdg );};_daefb =_baag .Style .Font ;};if len (_efdfd )> 0{_cgfb ._acbg =_efdfd ;
};};type fontMetrics struct{_dgbdd float64 ;_eceag float64 ;_ggfea float64 ;_fcef float64 ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_bfcg *Creator )DrawHeader (drawHeaderFunc func (_eabdc *Block ,_cadf HeaderFunctionArgs )){_bfcg ._acf =drawHeaderFunc ;};

// Height returns the current page height.
func (_ddb *Creator )Height ()float64 {return _ddb ._aae };

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_bec *Block )SetMargins (left ,right ,top ,bottom float64 ){_bec ._ae .Left =left ;_bec ._ae .Right =right ;_bec ._ae .Top =top ;_bec ._ae .Bottom =bottom ;};

// SetExtends specifies whether to extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_caeb *shading )SetExtends (start bool ,end bool ){_caeb ._babg =[]bool {start ,end }};

// ScaleToHeight scales the ellipse to the specified height. The width of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_ccbf *Ellipse )ScaleToHeight (h float64 ){_agee :=_ccbf ._eegf /_ccbf ._gaeb ;_ccbf ._gaeb =h ;_ccbf ._eegf =h *_agee ;};func _aeb (_bded _de .ChartRenderable )*Chart {return &Chart {_gegc :_bded ,_ege :PositionRelative ,_fgb :Margins {Top :10,Bottom :10}};
};

// SetBorderWidth sets the border width.
func (_gbbf *Polygon )SetBorderWidth (borderWidth float64 ){_gbbf ._efae .BorderWidth =borderWidth };func (_eadbc *templateProcessor )parseLine (_cdcgc *templateNode )(interface{},error ){_dbdd :=_eadbc .creator .NewLine (0,0,0,0);for _ ,_fbgbf :=range _cdcgc ._cggg .Attr {_bbeeg :=_fbgbf .Value ;
switch _dbfe :=_fbgbf .Name .Local ;_dbfe {case "\u0078\u0031":_dbdd ._cfgae =_eadbc .parseFloatAttr (_dbfe ,_bbeeg );case "\u0079\u0031":_dbdd ._ebf =_eadbc .parseFloatAttr (_dbfe ,_bbeeg );case "\u0078\u0032":_dbdd ._ccfa =_eadbc .parseFloatAttr (_dbfe ,_bbeeg );
case "\u0079\u0032":_dbdd ._cfcbb =_eadbc .parseFloatAttr (_dbfe ,_bbeeg );case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_dbdd .SetLineWidth (_eadbc .parseFloatAttr (_dbfe ,_bbeeg ));case "\u0063\u006f\u006co\u0072":_dbdd .SetColor (_eadbc .parseColorAttr (_dbfe ,_bbeeg ));
case "\u0073\u0074\u0079l\u0065":_dbdd .SetStyle (_eadbc .parseLineStyleAttr (_dbfe ,_bbeeg ));case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_dbdd .SetDashPattern (_eadbc .parseInt64Array (_dbfe ,_bbeeg ),_dbdd ._cggede );case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_dbdd .SetDashPattern (_dbdd ._cgdgd ,_eadbc .parseInt64Attr (_dbfe ,_bbeeg ));
case "\u006fp\u0061\u0063\u0069\u0074\u0079":_dbdd .SetOpacity (_eadbc .parseFloatAttr (_dbfe ,_bbeeg ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_dbdd .SetPositioning (_eadbc .parsePositioningAttr (_dbfe ,_bbeeg ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_dbdd .SetFitMode (_eadbc .parseFitModeAttr (_dbfe ,_bbeeg ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_cfgb :=_eadbc .parseMarginAttr (_dbfe ,_bbeeg );_dbdd .SetMargins (_cfgb .Left ,_cfgb .Right ,_cfgb .Top ,_cfgb .Bottom );default:_eadbc .nodeLogDebug (_cdcgc ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_dbfe );
};};return _dbdd ,nil ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_eacd *Invoice )AddressHeadingStyle ()TextStyle {return _eacd ._cfga };const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_ffcb *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _ffcb ._gbdb [0],_ffcb ._gbdb [1]};

// NewInvoice returns an instance of an empty invoice.
func (_ccd *Creator )NewInvoice ()*Invoice {_ffef :=_ccd .NewTextStyle ();_ffef .Font =_ccd ._bccg ;return _dbde (_ccd .NewTextStyle (),_ffef );};

// Cols returns the total number of columns the table has.
func (_afed *Table )Cols ()int {return _afed ._acgc };

// SetWidth sets the width of the ellipse.
func (_gggg *Ellipse )SetWidth (width float64 ){_gggg ._eegf =width };

// GraphicSVG represents a drawable graphic SVG.
// It is used to render the graphic SVG components using a creator instance.
type GraphicSVG struct{_bbce *_bfg .GraphicSVG ;_aeag Positioning ;_geaaa float64 ;_gge float64 ;_fggef Margins ;};func (_ddfgf *Table )updateRowHeights (_degaa float64 ){for _ ,_baab :=range _ddfgf ._dabec {_gdgea :=_baab .width (_ddfgf ._fgdb ,_degaa );
_bggd :=_baab .height (_gdgea );_dcfg :=_ddfgf ._faga [_baab ._eddfg +_baab ._bcgc -2];if _baab ._bcgc > 1{_fbfce :=0.0;_deace :=_ddfgf ._faga [_baab ._eddfg -1:(_baab ._eddfg +_baab ._bcgc -1)];for _ ,_cbde :=range _deace {_fbfce +=_cbde ;};if _bggd <=_fbfce {continue ;
};};if _bggd > _dcfg {_dgbfb :=_bggd /float64 (_baab ._bcgc );if _dgbfb > _dcfg {for _agbg :=1;_agbg <=_baab ._bcgc ;_agbg ++{if _dgbfb > _ddfgf ._faga [_baab ._eddfg +_agbg -2]{_ddfgf ._faga [_baab ._eddfg +_agbg -2]=_dgbfb ;};};};};};};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_cabe *Table )MultiCell (rowspan ,colspan int )*TableCell {_cabe ._faaef ++;_beead :=(_cabe .moveToNextAvailableCell ()-1)%(_cabe ._acgc )+1;_bgfc :=(_cabe ._faaef -1)/_cabe ._acgc +1;for _bgfc > _cabe ._gebff {_cabe ._gebff ++;_cabe ._faga =append (_cabe ._faga ,_cabe ._eagc );
};_bccbe :=&TableCell {};_bccbe ._eddfg =_bgfc ;_bccbe ._dfdfe =_beead ;_bccbe ._dbafb =5;_bccbe ._afggg =CellBorderStyleNone ;_bccbe ._dbgfb =_gg .LineStyleSolid ;_bccbe ._faefa =CellHorizontalAlignmentLeft ;_bccbe ._adgeg =CellVerticalAlignmentTop ;_bccbe ._dceac =0;
_bccbe ._ecba =0;_bccbe ._degae =0;_bccbe ._bbeee =0;_gggb :=ColorBlack ;_bccbe ._aeab =_gggb ;_bccbe ._dgbdg =_gggb ;_bccbe ._ceff =_gggb ;_bccbe ._ageeb =_gggb ;if rowspan < 1{_bd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_bbdd :=_cabe ._gebff -(_bccbe ._eddfg -1);if rowspan > _bbdd {_bd .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_bbdd );
_cabe ._gebff +=rowspan -1;for _eedec :=0;_eedec <=rowspan -_bbdd ;_eedec ++{_cabe ._faga =append (_cabe ._faga ,_cabe ._eagc );};};for _afea :=0;_afea < colspan &&_beead +_afea -1< len (_cabe ._afabg );_afea ++{_cabe ._afabg [_beead +_afea -1]=rowspan -1;
};_bccbe ._bcgc =rowspan ;if colspan < 1{_bd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_acebb :=_cabe ._acgc -(_bccbe ._dfdfe -1);if colspan > _acebb {_bd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_acebb );
colspan =_acebb ;};_bccbe ._cebg =colspan ;_cabe ._faaef +=colspan -1;_cabe ._dabec =append (_cabe ._dabec ,_bccbe );_bccbe ._cedbg =_cabe ;return _bccbe ;};func (_efad *templateProcessor )parseTextOverflowAttr (_cfca ,_aecf string )TextOverflow {_bd .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_cfca ,_aecf );
_eddfe :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_aecf ];return _eddfe ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_edaf float64 ;_dgedd float64 ;_dgdba float64 ;_gfef float64 ;_dbaf Positioning ;_gbbce Color ;_bcag float64 ;_afcfd Color ;_dacd float64 ;_gcdb float64 ;_dffbbb float64 ;_gegfb float64 ;_gagf float64 ;_cdfe float64 ;_ebfa Margins ;
_ccef FitMode ;};func (_dfgf *Creator )initContext (){_dfgf ._bdfae .X =_dfgf ._bag .Left ;_dfgf ._bdfae .Y =_dfgf ._bag .Top ;_dfgf ._bdfae .Width =_dfgf ._bfe -_dfgf ._bag .Right -_dfgf ._bag .Left ;_dfgf ._bdfae .Height =_dfgf ._aae -_dfgf ._bag .Bottom -_dfgf ._bag .Top ;
_dfgf ._bdfae .PageHeight =_dfgf ._aae ;_dfgf ._bdfae .PageWidth =_dfgf ._bfe ;_dfgf ._bdfae .Margins =_dfgf ._bag ;_dfgf ._bdfae ._baecf =_dfgf .UnsupportedCharacterReplacement ;};

// Positioning returns the type of positioning the ellipse is set to use.
func (_dbbb *Ellipse )Positioning ()Positioning {return _dbbb ._ggfe };type templateNode struct{_cdegg interface{};_cggg _a .StartElement ;_cafd *templateNode ;_caff int ;_ecfg int ;_geafg int64 ;};

// Height returns the height of the list.
func (_dadf *List )Height ()float64 {var _fedee float64 ;for _ ,_bgbe :=range _dadf ._eacg {_fedee +=_bgbe .ctxHeight (_dadf .Width ());};return _fedee ;};

// GetMargins returns the left, right, top, bottom Margins.
func (_gfdg *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gfdg ._degb .Left ,_gfdg ._degb .Right ,_gfdg ._degb .Top ,_gfdg ._degb .Bottom ;};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_cege *RadialShading )SetBoundingBox (x ,y ,width ,height float64 ){_cege ._edbfe =&_gec .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// Title returns the title of the invoice.
func (_ggbd *Invoice )Title ()string {return _ggbd ._gfeg };func (_ecae *templateProcessor )parseHorizontalAlignmentAttr (_cbgff ,_gaegc string )HorizontalAlignment {_bd .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_cbgff ,_gaegc );
_fafce :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_gaegc ];return _fafce ;};func _gdag (_fdecg ,_cgddd ,_dggdc float64 )(_adgef ,_ecfbd ,_gefab ,_ebded float64 ){if _dggdc ==0{return 0,0,_fdecg ,_cgddd ;
};_cgfaf :=_gg .Path {Points :[]_gg .Point {_gg .NewPoint (0,0).Rotate (_dggdc ),_gg .NewPoint (_fdecg ,0).Rotate (_dggdc ),_gg .NewPoint (0,_cgddd ).Rotate (_dggdc ),_gg .NewPoint (_fdecg ,_cgddd ).Rotate (_dggdc )}}.GetBoundingBox ();return _cgfaf .X ,_cgfaf .Y ,_cgfaf .Width ,_cgfaf .Height ;
};func (_eae *Block )drawToPage (_abe *_gec .PdfPage )error {_af :=&_bee .ContentStreamOperations {};if _abe .Resources ==nil {_abe .Resources =_gec .NewPdfPageResources ();};_eff :=_agd (_af ,_abe .Resources ,_eae ._efc ,_eae ._fb );if _eff !=nil {return _eff ;
};if _eff =_fbcb (_eae ._fb ,_abe .Resources );_eff !=nil {return _eff ;};if _eff =_abe .AppendContentBytes (_af .Bytes (),true );_eff !=nil {return _eff ;};for _ ,_afd :=range _eae ._fc {_abe .AddAnnotation (_afd );};return nil ;};func _ddg (_bbd string )string {_fac :=_adc .FindAllString (_bbd ,-1);
if len (_fac )==0{_bbd =_bbd +"\u0030";}else {_fdb ,_faa :=_fa .Atoi (_fac [len (_fac )-1]);if _faa !=nil {_bd .Log .Debug ("\u0045r\u0072\u006f\u0072 \u0063\u006f\u006ev\u0065rt\u0069\u006e\u0067\u0020\u0064\u0069\u0067i\u0074\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0069\u006e\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006e\u0061\u006de,\u0020f\u0061\u006c\u006c\u0062\u0061\u0063k\u0020\u0074\u006f\u0020\u0062a\u0073\u0069\u0063\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u003a \u0025\u0076",_faa );
_bbd =_bbd +"\u0030";}else {_fdb ++;_gdc :=_bea .LastIndex (_bbd ,_fac [len (_fac )-1]);if _gdc ==-1{_bbd =_e .Sprintf ("\u0025\u0073\u0025\u0064",_bbd [:len (_bbd )-1],_fdb );}else {_bbd =_bbd [:_gdc ]+_fa .Itoa (_fdb );};};};return _bbd ;};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_gaddf *Chapter )SetShowNumbering (show bool ){_gaddf ._dcd =show ;_gaddf ._aec .SetText (_gaddf .headingText ());};

// SetBackgroundColor sets the cell's background color.
func (_effg *TableCell )SetBackgroundColor (col Color ){_effg ._adbdf =col };

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_gec .PdfPage )(*Block ,error ){_fae :=&Block {};_dd ,_dee :=page .GetAllContentStreams ();if _dee !=nil {return nil ,_dee ;};_ga :=_bee .NewContentStreamParser (_dd );_cce ,_dee :=_ga .Parse ();if _dee !=nil {return nil ,_dee ;
};_cce .WrapIfNeeded ();_fae ._efc =_cce ;if page .Resources !=nil {_fae ._fb =page .Resources ;}else {_fae ._fb =_gec .NewPdfPageResources ();};_gb ,_dee :=page .GetMediaBox ();if _dee !=nil {return nil ,_dee ;};if _gb .Llx !=0||_gb .Lly !=0{_fae .translate (-_gb .Llx ,_gb .Lly );
};_fae ._bb =_gb .Urx -_gb .Llx ;_fae ._df =_gb .Ury -_gb .Lly ;if page .Rotate !=nil {_fae ._gd =-float64 (*page .Rotate );};return _fae ,nil ;};func _dgg (_ebgd ,_ecg ,_agde ,_eba float64 )*border {_gfac :=&border {};_gfac ._fgde =_ebgd ;_gfac ._dfge =_ecg ;
_gfac ._cdf =_agde ;_gfac ._ead =_eba ;_gfac ._aegb =ColorBlack ;_gfac ._febb =ColorBlack ;_gfac ._dadc =ColorBlack ;_gfac ._eag =ColorBlack ;_gfac ._dga =0;_gfac ._fga =0;_gfac ._afdc =0;_gfac ._aegf =0;_gfac .LineStyle =_gg .LineStyleSolid ;return _gfac ;
};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_cggfb *TOCLine )SetLevelOffset (levelOffset float64 ){_cggfb ._debg =levelOffset ;_cggfb ._ebebg ._dfcfg .Left =_cggfb ._cbaed +float64 (_cggfb ._aabgg -1)*_cggfb ._debg ;};

// SetFillOpacity sets the fill opacity.
func (_cefba *PolyBezierCurve )SetFillOpacity (opacity float64 ){_cefba ._dddge =opacity };

// Context returns the current drawing context.
func (_fddf *Creator )Context ()DrawContext {return _fddf ._bdfae };

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_dceb *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_dceb ._faefa =halign };

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_eedddg *LinearShading )AddShadingResource (block *Block )(_ffffe _dc .PdfObjectName ,_abgcc error ){_fcgb :=1;_ffffe =_dc .PdfObjectName ("\u0053\u0068"+_fa .Itoa (_fcgb ));for block ._fb .HasShadingByName (_ffffe ){_fcgb ++;_ffffe =_dc .PdfObjectName ("\u0053\u0068"+_fa .Itoa (_fcgb ));
};if _begec :=block ._fb .SetShadingByName (_ffffe ,_eedddg .shadingModel ().ToPdfObject ());_begec !=nil {return "",_begec ;};return _ffffe ,nil ;};

// Link returns link information for this line.
func (_ededb *TOCLine )Link ()(_caaad int64 ,_fbcbge ,_cfaad float64 ){return _ededb ._ccbe ,_ededb ._aecea ,_ededb ._fdbf ;};

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_ceae *Chart )SetPos (x ,y float64 ){_ceae ._ege =PositionAbsolute ;_ceae ._gefb =x ;_ceae ._afde =y ;};

// SetWidth sets line width.
func (_abee *Curve )SetWidth (width float64 ){_abee ._ddgb =width };func (_cdgc *Table )sortCells (){_c .Slice (_cdgc ._dabec ,func (_fefeg ,_dbdb int )bool {_ecaab :=_cdgc ._dabec [_fefeg ]._eddfg ;_bgeg :=_cdgc ._dabec [_dbdb ]._eddfg ;if _ecaab < _bgeg {return true ;
};if _ecaab > _bgeg {return false ;};return _cdgc ._dabec [_fefeg ]._dfdfe < _cdgc ._dabec [_dbdb ]._dfdfe ;});};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_efdae *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_cdcde :=&_efdae ._ebebg ._dfcfg ;return _efdae ._cbaed ,_cdcde .Right ,_cdcde .Top ,_cdcde .Bottom ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;
TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_defd *StyledParagraph )Height ()float64 {_defd .wrapText ();var _ggbc float64 ;for _ ,_bfdeb :=range _defd ._dbgba {var _fgcad float64 ;for _ ,_abed :=range _bfdeb {_cabc :=_defd ._cdadd *_abed .Style .FontSize ;if _cabc > _fgcad {_fgcad =_cabc ;
};};_ggbc +=_fgcad ;};return _ggbc ;};

// SetFillColor sets the fill color for the path.
func (_aceda *FilledCurve )SetFillColor (color Color ){_aceda ._dggd =color };

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_gbd *Chapter )SetIncludeInTOC (includeInTOC bool ){_gbd ._ggbf =includeInTOC };

// SetLineColor sets the line color.
func (_ddeff *Polyline )SetLineColor (color Color ){_ddeff ._bacgg .LineColor =_dbceg (color )};func (_dg *Block )duplicate ()*Block {_bc :=&Block {};*_bc =*_dg ;_aegd :=_bee .ContentStreamOperations {};_aegd =append (_aegd ,*_dg ._efc ...);_bc ._efc =&_aegd ;
return _bc ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_egec *Creator )NewParagraph (text string )*Paragraph {return _daac (text ,_egec .NewTextStyle ())};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};func (_egbe *templateProcessor )parseLineStyleAttr (_eeccc ,_cddag string )_gg .LineStyle {_bd .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_eeccc ,_cddag );
_aafa :=map[string ]_gg .LineStyle {"\u0073\u006f\u006ci\u0064":_gg .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_gg .LineStyleDashed }[_cddag ];return _aafa ;};

// SetColorBottom sets border color for bottom.
func (_dag *border )SetColorBottom (col Color ){_dag ._febb =col };

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_ebbgg *TOC )SetLineStyle (style TextStyle ){_ebbgg .SetLineNumberStyle (style );_ebbgg .SetLineTitleStyle (style );_ebbgg .SetLineSeparatorStyle (style );_ebbgg .SetLinePageStyle (style );};func (_babef *Table )clone ()*Table {_ggaac :=*_babef ;
_ggaac ._faga =make ([]float64 ,len (_babef ._faga ));copy (_ggaac ._faga ,_babef ._faga );_ggaac ._fgdb =make ([]float64 ,len (_babef ._fgdb ));copy (_ggaac ._fgdb ,_babef ._fgdb );_ggaac ._dabec =make ([]*TableCell ,0,len (_babef ._dabec ));for _ ,_ecbb :=range _babef ._dabec {_bcdba :=*_ecbb ;
_bcdba ._cedbg =&_ggaac ;_ggaac ._dabec =append (_ggaac ._dabec ,&_bcdba );};return &_ggaac ;};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_dfgea :_ag .Max (_ag .Min (r ,1.0),0.0),_eee :_ag .Max (_ag .Min (g ,1.0),0.0),_ddab :_ag .Max (_ag .Min (b ,1.0),0.0)};};func (_dfdfg *templateProcessor )parseList (_bbddf *templateNode )(interface{},error ){_efbf :=_dfdfg .creator .NewList ();
for _ ,_dbfef :=range _bbddf ._cggg .Attr {_defb :=_dbfef .Value ;switch _cafda :=_dbfef .Name .Local ;_cafda {case "\u0069\u006e\u0064\u0065\u006e\u0074":_efbf .SetIndent (_dfdfg .parseFloatAttr (_cafda ,_defb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_bbfb :=_dfdfg .parseMarginAttr (_cafda ,_defb );
_efbf .SetMargins (_bbfb .Left ,_bbfb .Right ,_bbfb .Top ,_bbfb .Bottom );default:_dfdfg .nodeLogDebug (_bbddf ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u0073\u0074 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_cafda );
};};return _efbf ,nil ;};func (_acdd *Division )ctxHeight (_ecc float64 )float64 {_ecc -=_acdd ._dedd .Left +_acdd ._dedd .Right +_acdd ._gcag .Left +_acdd ._gcag .Right ;var _bdcf float64 ;for _ ,_cfeb :=range _acdd ._dcdd {_bdcf +=_fafba (_cfeb ,_ecc );
};return _bdcf ;};func (_aegeg *StyledParagraph )split (_edbab DrawContext )(_fgeb ,_bbfe *StyledParagraph ,_befdf error ){if _befdf =_aegeg .wrapChunks (false );_befdf !=nil {return nil ,nil ,_befdf ;};if len (_aegeg ._dbgba )==1&&_aegeg ._cdadd > _edbab .Height {return _aegeg ,nil ,nil ;
};_bdfb :=func (_cbgg []*TextChunk ,_fbcbg []*TextChunk )[]*TextChunk {if len (_fbcbg )==0{return _cbgg ;};_agab :=len (_cbgg );if _agab ==0{return append (_cbgg ,_fbcbg ...);};if _cbgg [_agab -1].Style ==_fbcbg [0].Style {_cbgg [_agab -1].Text +=_fbcbg [0].Text ;
}else {_cbgg =append (_cbgg ,_fbcbg [0]);};return append (_cbgg ,_fbcbg [1:]...);};_edab :=func (_ccgff *StyledParagraph ,_acbd []*TextChunk )*StyledParagraph {if len (_acbd )==0{return nil ;};_ddgca :=*_ccgff ;_ddgca ._acbg =_acbd ;return &_ddgca ;};var (_gbeb float64 ;
_bcgb []*TextChunk ;_fbcef []*TextChunk ;);for _ ,_gcbc :=range _aegeg ._dbgba {var _dddba float64 ;_gabg :=make ([]*TextChunk ,0,len (_gcbc ));for _ ,_edaff :=range _gcbc {if _ebfc :=_edaff .Style .FontSize ;_ebfc > _dddba {_dddba =_ebfc ;};_gabg =append (_gabg ,_edaff .clone ());
};_dddba *=_aegeg ._cdadd ;if _aegeg ._ebdeg .IsRelative (){if _gbeb +_dddba > _edbab .Height {_fbcef =_bdfb (_fbcef ,_gabg );}else {_bcgb =_bdfb (_bcgb ,_gabg );};};_gbeb +=_dddba ;};_aegeg ._dbgba =nil ;if len (_fbcef )==0{return _aegeg ,nil ,nil ;};
return _edab (_aegeg ,_bcgb ),_edab (_aegeg ,_fbcef ),nil ;};func _bgge (_fgca string )(*GraphicSVG ,error ){_aaae ,_egee :=_bfg .ParseFromString (_fgca );if _egee !=nil {return nil ,_egee ;};return _dcdcd (_aaae );};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_eadd *Image )SetEncoder (encoder _dc .StreamEncoder ){_eadd ._faaad =encoder };

// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// HelperFuncMap is used to define functions which can be accessed
// inside the rendered templates by their assigned names.
HelperFuncMap _b .FuncMap ;

// SubtemplateMap contains templates which can be rendered alongside
// the main template. They can be accessed using their assigned names
// in the main template or in the other subtemplates.
// Subtemplates defined inside the subtemplates specified in the map
// can be accessed directly.
// All resources available to the main template are also available
// to the subtemplates.
SubtemplateMap map[string ]_ef .Reader ;

// FontMap contains pre-loaded fonts which can be accessed
// inside the rendered templates by their assigned names.
FontMap map[string ]*_gec .PdfFont ;

// ImageMap contains pre-loaded images which can be accessed
// inside the rendered templates by their assigned names.
ImageMap map[string ]*_gec .Image ;

// ColorMap contains colors which can be accessed
// inside the rendered templates by their assigned names.
ColorMap map[string ]Color ;

// ChartMap contains charts which can be accessed
// inside the rendered templates by their assigned names.
ChartMap map[string ]_de .ChartRenderable ;};

// SetBorderOpacity sets the border opacity.
func (_ddbf *CurvePolygon )SetBorderOpacity (opacity float64 ){_ddbf ._fecf =opacity };

// GeneratePageBlocks draws the filled curve on page blocks.
func (_gddeg *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aggg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bcfd ,_ ,_ccdc :=_gddeg .draw (_aggg ,"");if _ccdc !=nil {return nil ,ctx ,_ccdc ;};_ccdc =_aggg .addContentsByString (string (_bcfd ));
if _ccdc !=nil {return nil ,ctx ,_ccdc ;};return []*Block {_aggg },ctx ,nil ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_cec *Block )DrawTemplate (c *Creator ,r _ef .Reader ,data interface{},options *TemplateOptions )error {return _eaac (c ,r ,data ,options ,_cec );};

// Width returns the Block's width.
func (_fg *Block )Width ()float64 {return _fg ._bb };

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// Lines returns all the rows of the invoice line items table.
func (_gegd *Invoice )Lines ()[][]*InvoiceCell {return _gegd ._cbcg };

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_eafe *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfdde :=ctx ;var _ggcf []*Block ;_befa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _eafe ._ebdeg .IsRelative (){ctx .X +=_eafe ._dfcfg .Left ;ctx .Y +=_eafe ._dfcfg .Top ;
ctx .Width -=_eafe ._dfcfg .Left +_eafe ._dfcfg .Right ;ctx .Height -=_eafe ._dfcfg .Top ;_eafe .SetWidth (ctx .Width );}else {if int (_eafe ._dabc )<=0{_eafe .SetWidth (_eafe .getTextWidth ()/1000.0);};ctx .X =_eafe ._fefbd ;ctx .Y =_eafe ._ddfge ;};if _eafe ._bcgaf !=nil {_eafe ._bcgaf (_eafe ,ctx );
};if _dbeac :=_eafe .wrapText ();_dbeac !=nil {return nil ,ctx ,_dbeac ;};_caea :=_eafe ._dbgba ;_ebdde :=0;for {_adeb ,_adegc ,_cgfdb :=_dgcfd (_befa ,_eafe ,_caea ,ctx );if _cgfdb !=nil {_bd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cgfdb );
return nil ,ctx ,_cgfdb ;};ctx =_adeb ;_ggcf =append (_ggcf ,_befa );if _caea =_adegc ;len (_adegc )==0{break ;};if len (_adegc )==_ebdde {return nil ,ctx ,_d .New ("\u006e\u006f\u0074\u0020\u0065\u006e\u006f\u0075\u0067\u0068 \u0073\u0070\u0061\u0063\u0065\u0020\u0066o\u0072\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068");
};_befa =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_adeb =ctx ;_adeb .Y =ctx .Margins .Top ;_adeb .X =ctx .Margins .Left +_eafe ._dfcfg .Left ;_adeb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_adeb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_eafe ._dfcfg .Left -_eafe ._dfcfg .Right ;
ctx =_adeb ;_ebdde =len (_adegc );};if _eafe ._ebdeg .IsRelative (){ctx .Y +=_eafe ._dfcfg .Bottom ;ctx .Height -=_eafe ._dfcfg .Bottom ;if !ctx .Inline {ctx .X =_cfdde .X ;ctx .Width =_cfdde .Width ;};return _ggcf ,ctx ,nil ;};return _ggcf ,_cfdde ,nil ;
};func (_gddgd *TOCLine )getLineLink ()*_gec .PdfAnnotation {if _gddgd ._ccbe <=0{return nil ;};return _aebee (_gddgd ._ccbe -1,_gddgd ._aecea ,_gddgd ._fdbf ,0);};func _eccbea (_dbdbe *_gec .PdfAnnotationLink )*_gec .PdfAnnotationLink {if _dbdbe ==nil {return nil ;
};_fbdd :=_gec .NewPdfAnnotationLink ();_fbdd .BS =_dbdbe .BS ;_fbdd .A =_dbdbe .A ;if _cbafb ,_edcec :=_dbdbe .GetAction ();_edcec ==nil &&_cbafb !=nil {_fbdd .SetAction (_cbafb );};if _bedfd ,_gegeg :=_dbdbe .Dest .(*_dc .PdfObjectArray );_gegeg {_fbdd .Dest =_dc .MakeArray (_bedfd .Elements ()...);
};return _fbdd ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_cdec *StyledParagraph )SetWidth (width float64 ){_cdec ._dabc =width ;_cdec .wrapText ()};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph, *Division, *Image, *Table, and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_egaa *List )Add (item VectorDrawable )(*TextChunk ,error ){_aabf :=&listItem {_bdbgb :item ,_fddae :_egaa ._egebb };switch _cbfb :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _cbfb ._debeb {_cbfb ._ecfe =15;};case *Division :case *Image :case *Table :default:return nil ,_d .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_egaa ._eacg =append (_egaa ._eacg ,_aabf );return &_aabf ._fddae ,nil ;};func _gbcg (_aabgb *_gec .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_aabgb ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_eccda *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _eccda ._bebc [0],_eccda ._bebc [1]};func (_dfdf *List )split (_ebga DrawContext )(_bggb ,_bfdf *List ){var (_afb float64 ;_dfbf ,_gdcc []*listItem ;);_gaeag :=_ebga .Width -_dfdf ._ebde .Horizontal ()-_dfdf ._ecfe -_dfdf .markerWidth ();
_fcbb :=_dfdf .markerWidth ();for _fadff ,_dbebbf :=range _dfdf ._eacg {_gdae :=_dbebbf .ctxHeight (_gaeag );_afb +=_gdae ;if _afb <=_ebga .Height {_dfbf =append (_dfbf ,_dbebbf );}else {switch _degfg :=_dbebbf ._bdbgb .(type ){case *List :_adge :=_ebga ;
_adge .Height =_ag .Floor (_gdae -(_afb -_ebga .Height ));_gegdg ,_ebdfe :=_degfg .split (_adge );if _gegdg !=nil {_fcbc :=_dagd ();_fcbc ._fddae =_dbebbf ._fddae ;_fcbc ._bdbgb =_gegdg ;_dfbf =append (_dfbf ,_fcbc );};if _ebdfe !=nil {_egca :=_degfg ._egebb .Style .FontSize ;
_fabe ,_ccbb :=_degfg ._egebb .Style .Font .GetRuneMetrics (' ');if _ccbb {_egca =_degfg ._egebb .Style .FontSize *_fabe .Wx *_degfg ._egebb .Style .horizontalScale ()/1000.0;};_cebe :=_bea .Repeat ("\u0020",int (_fcbb /_egca ));_dadfd :=_dagd ();_dadfd ._fddae =*NewTextChunk (_cebe ,_degfg ._egebb .Style );
_dadfd ._bdbgb =_ebdfe ;_gdcc =append (_gdcc ,_dadfd );_gdcc =append (_gdcc ,_dfdf ._eacg [_fadff +1:]...);};default:_gdcc =_dfdf ._eacg [_fadff :];};if len (_gdcc )> 0{break ;};};};if len (_dfbf )> 0{_bggb =_dedbf (_dfdf ._gfag );*_bggb =*_dfdf ;_bggb ._eacg =_dfbf ;
};if len (_gdcc )> 0{_bfdf =_dedbf (_dfdf ._gfag );*_bfdf =*_dfdf ;_bfdf ._eacg =_gdcc ;};return _bggb ,_bfdf ;};

// Width returns the width of the ellipse.
func (_ffbe *Ellipse )Width ()float64 {return _ffbe ._eegf };

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_ebgbf *TOC )SetLineTitleStyle (style TextStyle ){_ebgbf ._dbgcb =style };

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_aedd *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_aedd ._gebe .Left =left ;_aedd ._gebe .Right =right ;_aedd ._gebe .Top =top ;_aedd ._gebe .Bottom =bottom ;};func (_bacg *Invoice )generateHeaderBlocks (_efef DrawContext )([]*Block ,DrawContext ,error ){_dbdf :=_bffb (_bacg ._baca );
_dbdf .SetEnableWrap (true );_dbdf .Append (_bacg ._gfeg );_abffb :=_gegcdg (2);if _bacg ._ega !=nil {_fbgd :=_abffb .NewCell ();_fbgd .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_fbgd .SetVerticalAlignment (CellVerticalAlignmentMiddle );_fbgd .SetIndent (0);
_fbgd .SetContent (_bacg ._ega );_bacg ._ega .ScaleToHeight (_dbdf .Height ()+20);}else {_abffb .SkipCells (1);};_bbec :=_abffb .NewCell ();_bbec .SetHorizontalAlignment (CellHorizontalAlignmentRight );_bbec .SetVerticalAlignment (CellVerticalAlignmentMiddle );
_bbec .SetContent (_dbdf );return _abffb .GeneratePageBlocks (_efef );};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_aaabc *Table )EnableRowWrap (enable bool ){_aaabc ._bfec =enable };func _afaeb (_ebgef *_gec .PdfRectangle ,_fdddd _ea .Matrix )*_gec .PdfRectangle {var _abbaa _gec .PdfRectangle ;_abbaa .Llx ,_abbaa .Lly =_fdddd .Transform (_ebgef .Llx ,_ebgef .Lly );
_abbaa .Urx ,_abbaa .Ury =_fdddd .Transform (_ebgef .Urx ,_ebgef .Ury );_abbaa .Normalize ();return &_abbaa ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_dffc *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _dffc ._dccf ==nil {if _eccd :=_dffc .makeXObject ();_eccd !=nil {return nil ,ctx ,_eccd ;};};var _cefb []*Block ;_afgg :=ctx ;_fcag :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _dffc ._acde .IsRelative (){_dffc .applyFitMode (ctx .Width );ctx .X +=_dffc ._afgf .Left ;ctx .Y +=_dffc ._afgf .Top ;ctx .Width -=_dffc ._afgf .Left +_dffc ._afgf .Right ;ctx .Height -=_dffc ._afgf .Top +_dffc ._afgf .Bottom ;if _dffc ._eaec > ctx .Height {_cefb =append (_cefb ,_fcag );
_fcag =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_ecgg :=ctx ;_ecgg .Y =ctx .Margins .Top +_dffc ._afgf .Top ;_ecgg .X =ctx .Margins .Left +_dffc ._afgf .Left ;_ecgg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_dffc ._afgf .Top -_dffc ._afgf .Bottom ;
_ecgg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dffc ._afgf .Left -_dffc ._afgf .Right ;ctx =_ecgg ;};}else {ctx .X =_dffc ._gfbb ;ctx .Y =_dffc ._gagce ;};ctx ,_adfce :=_ecdc (_fcag ,_dffc ,ctx );if _adfce !=nil {return nil ,ctx ,_adfce ;
};_cefb =append (_cefb ,_fcag );if _dffc ._acde .IsAbsolute (){ctx =_afgg ;}else {ctx .X =_afgg .X ;ctx .Width =_afgg .Width ;ctx .Y +=_dffc ._afgf .Bottom ;};return _cefb ,ctx ,nil ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_bdea *Image )SetMargins (left ,right ,top ,bottom float64 ){_bdea ._afgf .Left =left ;_bdea ._afgf .Right =right ;_bdea ._afgf .Top =top ;_bdea ._afgf .Bottom =bottom ;};

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_dfea *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _addd (x1 ,y1 ,x2 ,y2 )};

// NewPolyline creates a new polyline.
func (_efcd *Creator )NewPolyline (points []_gg .Point )*Polyline {return _fge (points )};

// SetHeight sets the height of the ellipse.
func (_dfdca *Ellipse )SetHeight (height float64 ){_dfdca ._gaeb =height };func _dbbg (_beec map[string ]interface{},_aggda ...interface{})(map[string ]interface{},error ){_daged :=len (_aggda );if _daged %2!=0{return nil ,_dc .ErrRangeError ;};for _gedcg :=0;
_gedcg < _daged ;_gedcg +=2{_cbeab ,_bdcb :=_aggda [_gedcg ].(string );if !_bdcb {return nil ,_dc .ErrTypeError ;};_beec [_cbeab ]=_aggda [_gedcg +1];};return _beec ,nil ;};func _eaac (_gdadg *Creator ,_bagc _ef .Reader ,_bcfc interface{},_ccbdc *TemplateOptions ,_bacb componentRenderer )error {if _gdadg ==nil {_bd .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _gfeda ;};_bdbcc :="";if _dacad ,_fbeg :=_bagc .(*_cg .File );_fbeg {_bdbcc =_dacad .Name ();};_fcfb :=_f .NewBuffer (nil );if _ ,_agbgg :=_ef .Copy (_fcfb ,_bagc );_agbgg !=nil {return _agbgg ;};_adfe :=_b .FuncMap {"\u0064\u0069\u0063\u0074":_fdag ,"\u0061\u0064\u0064":_cabdda ,"\u0061\u0072\u0072a\u0079":_cfeff ,"\u0065\u0078\u0074\u0065\u006e\u0064\u0044\u0069\u0063\u0074":_dbbg ,"\u006da\u006b\u0065\u0053\u0065\u0071":_cacc };
if _ccbdc !=nil &&_ccbdc .HelperFuncMap !=nil {for _fcabg ,_efeb :=range _ccbdc .HelperFuncMap {if _ ,_edafg :=_adfe [_fcabg ];_edafg {_bd .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_fcabg );
continue ;};_adfe [_fcabg ]=_efeb ;};};_caegb ,_ecdee :=_b .New ("").Funcs (_adfe ).Parse (_fcfb .String ());if _ecdee !=nil {return _ecdee ;};if _ccbdc !=nil &&_ccbdc .SubtemplateMap !=nil {for _ccdf ,_acbf :=range _ccbdc .SubtemplateMap {if _ccdf ==""{_bd .Log .Debug ("\u0053\u0075\u0062\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u006e\u0061\u006d\u0065\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006d\u0070\u0074\u0079\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067.\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e");
continue ;};if _acbf ==nil {_bd .Log .Debug ("S\u0075\u0062t\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u002e");
continue ;};_gffff :=_f .NewBuffer (nil );if _ ,_gfed :=_ef .Copy (_gffff ,_acbf );_gfed !=nil {return _gfed ;};if _ ,_fdcge :=_caegb .New (_ccdf ).Parse (_gffff .String ());_fdcge !=nil {return _fdcge ;};};};_fcfb .Reset ();if _efdgd :=_caegb .Execute (_fcfb ,_bcfc );
_efdgd !=nil {return _efdgd ;};return _eccgg (_gdadg ,_bdbcc ,_fcfb .Bytes (),_ccbdc ,_bacb ).run ();};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_ccbd *Creator )NewStyledParagraph ()*StyledParagraph {return _bffb (_ccbd .NewTextStyle ())};

// GeneratePageBlocks draws the curve onto page blocks.
func (_ffac *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fbfbe :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_aga :=_bee .NewContentCreator ();_aga .Add_q ().Add_w (_ffac ._ddgb ).SetStrokingColor (_dbceg (_ffac ._aada )).Add_m (_ffac ._gdfg ,ctx .PageHeight -_ffac ._cggd ).Add_v (_ffac ._faba ,ctx .PageHeight -_ffac ._fbbb ,_ffac ._beg ,ctx .PageHeight -_ffac ._gaga ).Add_S ().Add_Q ();
_adga :=_fbfbe .addContentsByString (_aga .String ());if _adga !=nil {return nil ,ctx ,_adga ;};return []*Block {_fbfbe },ctx ,nil ;};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
// - *Table
// - *Division
// - *List
func (_bbdg *Division )Add (d VectorDrawable )error {switch _ggfb :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division ,*List :case containerDrawable :_edbb ,_cgged :=_ggfb .ContainerComponent (_bbdg );
if _cgged !=nil {return _cgged ;};_gfgb ,_bgfe :=_edbb .(VectorDrawable );if !_bgfe {return _e .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_edbb );
};d =_gfgb ;default:return _d .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_bbdg ._dcdd =append (_bbdg ._dcdd ,d );return nil ;};func (_bgbcd *templateProcessor )renderNode (_eccbb *templateNode )error {_ddfb :=_eccbb ._cdegg ;
if _ddfb ==nil {return nil ;};_cfbe :=_eccbb ._cggg .Name .Local ;_cdca ,_dgba :=_fbbfc [_cfbe ];if !_dgba {_bgbcd .nodeLogDebug (_eccbb ,"I\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e \u0053\u006b\u0069p\u0070i\u006e\u0067\u002e",_cfbe );
return nil ;};var _bdedg interface{};if _eccbb ._cafd !=nil &&_eccbb ._cafd ._cdegg !=nil {_gdeaf :=_eccbb ._cafd ._cggg .Name .Local ;if _ ,_dgba =_cdca ._gdea [_gdeaf ];!_dgba {_bgbcd .nodeLogDebug (_eccbb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_gdeaf ,_cfbe );
return _bged ;};_bdedg =_eccbb ._cafd ._cdegg ;}else {_gcaf :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _bgbcd ._degea .(type ){case *Block :_gcaf ="\u0062\u006c\u006fc\u006b";};if _ ,_dgba =_cdca ._gdea [_gcaf ];!_dgba {_bgbcd .nodeLogDebug (_eccbb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_gcaf ,_cfbe );
return _bged ;};_bdedg =_bgbcd ._degea ;};switch _beeb :=_bdedg .(type ){case componentRenderer :_eedef ,_cabbg :=_ddfb .(Drawable );if !_cabbg {_bgbcd .nodeLogError (_eccbb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u002e",_cfbe ,_ddfb );
return _eccbe ;};_cebb :=_beeb .Draw (_eedef );if _cebb !=nil {return _bgbcd .nodeError (_eccbb ,"\u0043\u0061\u006en\u006f\u0074\u0020\u0064r\u0061\u0077\u0073\u0020\u0074\u0061\u0067 \u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u0073\u002e",_cfbe ,_ddfb ,_cebb );
};case *Division :switch _dfdd :=_ddfb .(type ){case *Background :_beeb .SetBackground (_dfdd );case VectorDrawable :_bdedge :=_beeb .Add (_dfdd );if _bdedge !=nil {return _bgbcd .nodeError (_eccbb ,"\u0043a\u006e\u006eo\u0074\u0020\u0061d\u0064\u0020\u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054)\u0020\u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0044\u0069\u0076i\u0073\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u002e",_cfbe ,_ddfb ,_bdedge );
};};case *TableCell :_bcfa ,_gfcge :=_ddfb .(VectorDrawable );if !_gfcge {_bgbcd .nodeLogError (_eccbb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074 \u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_cfbe ,_ddfb );
return _eccbe ;};_dadfda :=_beeb .SetContent (_bcfa );if _dadfda !=nil {return _bgbcd .nodeError (_eccbb ,"C\u0061\u006e\u006e\u006f\u0074\u0020\u0061\u0064\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073> \u0028\u0025\u0054\u0029 \u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0074\u0061bl\u0065\u0020c\u0065\u006c\u006c\u003a\u0020\u0025\u0073\u002e",_cfbe ,_ddfb ,_dadfda );
};case *StyledParagraph :_ccafb ,_cbcd :=_ddfb .(*TextChunk );if !_cbcd {_bgbcd .nodeLogError (_eccbb ,"\u0054\u0061\u0067 <\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020i\u0073 \u006eo\u0074 \u0061\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e",_cfbe ,_ddfb );
return _eccbe ;};_beeb .appendChunk (_ccafb );case *Chapter :switch _affged :=_ddfb .(type ){case *Chapter :return nil ;case *Paragraph :if _eccbb ._cggg .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};_bacc :=_beeb .Add (_affged );if _bacc !=nil {return _bgbcd .nodeError (_eccbb ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_cfbe ,_ddfb ,_bacc );
};case Drawable :_eddac :=_beeb .Add (_affged );if _eddac !=nil {return _bgbcd .nodeError (_eccbb ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_cfbe ,_ddfb ,_eddac );
};};case *List :switch _bccca :=_ddfb .(type ){case *TextChunk :case *listItem :_beeb ._eacg =append (_beeb ._eacg ,_bccca );default:_bgbcd .nodeLogError (_eccbb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073>\u0020\u0028\u0025T\u0029\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u0074\u0065\u006d\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_cfbe ,_ddfb );
};case *listItem :switch _bgdb :=_ddfb .(type ){case *TextChunk :case *StyledParagraph :_beeb ._bdbgb =_bgdb ;case *List :if _bgdb ._debeb {_bgdb ._ecfe =15;};_beeb ._bdbgb =_bgdb ;case *Image :_beeb ._bdbgb =_bgdb ;case *Division :_beeb ._bdbgb =_bgdb ;
case *Table :_beeb ._bdbgb =_bgdb ;default:_bgbcd .nodeLogError (_eccbb ,"\u0054\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u002e",_cfbe ,_ddfb );
return _eccbe ;};};return nil ;};func (_bgfb *RadialShading )shadingModel ()*_gec .PdfShadingType3 {_cedf ,_egfafc ,_fcfe :=_bgfb ._ddggc ._edaa .ToRGB ();var _bdadg _gg .Point ;switch _bgfb ._cgbdg {case AnchorBottomLeft :_bdadg =_gg .Point {X :_bgfb ._edbfe .Llx ,Y :_bgfb ._edbfe .Lly };
case AnchorBottomRight :_bdadg =_gg .Point {X :_bgfb ._edbfe .Urx ,Y :_bgfb ._edbfe .Ury -_bgfb ._edbfe .Height ()};case AnchorTopLeft :_bdadg =_gg .Point {X :_bgfb ._edbfe .Llx ,Y :_bgfb ._edbfe .Lly +_bgfb ._edbfe .Height ()};case AnchorTopRight :_bdadg =_gg .Point {X :_bgfb ._edbfe .Urx ,Y :_bgfb ._edbfe .Ury };
case AnchorLeft :_bdadg =_gg .Point {X :_bgfb ._edbfe .Llx ,Y :_bgfb ._edbfe .Lly +_bgfb ._edbfe .Height ()/2};case AnchorTop :_bdadg =_gg .Point {X :_bgfb ._edbfe .Llx +_bgfb ._edbfe .Width ()/2,Y :_bgfb ._edbfe .Ury };case AnchorRight :_bdadg =_gg .Point {X :_bgfb ._edbfe .Urx ,Y :_bgfb ._edbfe .Lly +_bgfb ._edbfe .Height ()/2};
case AnchorBottom :_bdadg =_gg .Point {X :_bgfb ._edbfe .Urx +_bgfb ._edbfe .Width ()/2,Y :_bgfb ._edbfe .Lly };default:_bdadg =_gg .NewPoint (_bgfb ._edbfe .Llx +_bgfb ._edbfe .Width ()/2,_bgfb ._edbfe .Lly +_bgfb ._edbfe .Height ()/2);};_dbff :=_bgfb ._dfca ;
_bcdbf :=_bgfb ._eegfe ;_gfagd :=_bdadg .X +_bgfb ._dbfa ;_afbf :=_bdadg .Y +_bgfb ._edcd ;if _dbff ==-1.0{_dbff =0.0;};if _bcdbf ==-1.0{var _dbeca []float64 ;_feac :=_ag .Pow (_gfagd -_bgfb ._edbfe .Llx ,2)+_ag .Pow (_afbf -_bgfb ._edbfe .Lly ,2);_dbeca =append (_dbeca ,_ag .Abs (_feac ));
_cddb :=_ag .Pow (_gfagd -_bgfb ._edbfe .Llx ,2)+_ag .Pow (_bgfb ._edbfe .Lly +_bgfb ._edbfe .Height ()-_afbf ,2);_dbeca =append (_dbeca ,_ag .Abs (_cddb ));_edad :=_ag .Pow (_bgfb ._edbfe .Urx -_gfagd ,2)+_ag .Pow (_afbf -_bgfb ._edbfe .Ury -_bgfb ._edbfe .Height (),2);
_dbeca =append (_dbeca ,_ag .Abs (_edad ));_ddca :=_ag .Pow (_bgfb ._edbfe .Urx -_gfagd ,2)+_ag .Pow (_bgfb ._edbfe .Ury -_afbf ,2);_dbeca =append (_dbeca ,_ag .Abs (_ddca ));_c .Slice (_dbeca ,func (_dffba ,_bgbdd int )bool {return _dffba > _bgbdd });
_bcdbf =_ag .Sqrt (_dbeca [0]);};_cbcef :=&_gec .PdfRectangle {Llx :_gfagd -_bcdbf ,Lly :_afbf -_bcdbf ,Urx :_gfagd +_bcdbf ,Ury :_afbf +_bcdbf };_cdda :=_gec .NewPdfShadingType3 ();_cdda .PdfShading .ShadingType =_dc .MakeInteger (3);_cdda .PdfShading .ColorSpace =_gec .NewPdfColorspaceDeviceRGB ();
_cdda .PdfShading .Background =_dc .MakeArrayFromFloats ([]float64 {_cedf ,_egfafc ,_fcfe });_cdda .PdfShading .BBox =_cbcef ;_cdda .PdfShading .AntiAlias =_dc .MakeBool (_bgfb ._ddggc ._gdegc );_cdda .Coords =_dc .MakeArrayFromFloats ([]float64 {_gfagd ,_afbf ,_dbff ,_gfagd ,_afbf ,_bcdbf });
_cdda .Domain =_dc .MakeArrayFromFloats ([]float64 {0.0,1.0});_cdda .Extend =_dc .MakeArray (_dc .MakeBool (_bgfb ._ddggc ._babg [0]),_dc .MakeBool (_bgfb ._ddggc ._babg [1]));_cdda .Function =_bgfb ._ddggc .generatePdfFunctions ();return _cdda ;};var _fbbfc =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_gdea :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_cfcg :_bbgbd },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_gdea :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_cfcg :_gfee },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_gdea :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_cfcg :_daea },"\u0074\u0061\u0062l\u0065":&templateTag {_gdea :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_cfcg :_gaed },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_gdea :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_cfcg :_ccba },"\u006c\u0069\u006e\u0065":&templateTag {_gdea :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_cfcg :_gbgac },"\u0072e\u0063\u0074\u0061\u006e\u0067\u006ce":&templateTag {_gdea :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_cfcg :_ggac },"\u0065l\u006c\u0069\u0070\u0073\u0065":&templateTag {_gdea :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_cfcg :_dbaaa },"\u0069\u006d\u0061g\u0065":&templateTag {_gdea :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_cfcg :_dcaef },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_gdea :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_cfcg :_daedb },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_gdea :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_cfcg :_ddcag },"\u0063\u0068\u0061r\u0074":&templateTag {_gdea :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_cfcg :_efefc },"\u0070\u0061\u0067\u0065\u002d\u0062\u0072\u0065\u0061\u006b":&templateTag {_gdea :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_cfcg :_bceed },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_gdea :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_cfcg :_bgfea },"\u006c\u0069\u0073\u0074":&templateTag {_gdea :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_cfcg :_agacg },"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":&templateTag {_gdea :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{}},_cfcg :_fdbde },"l\u0069\u0073\u0074\u002d\u006d\u0061\u0072\u006b\u0065\u0072":&templateTag {_gdea :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_cfcg :_ebgcg }};


// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_fcg *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fcg ._fgb .Left ,_fcg ._fgb .Right ,_fcg ._fgb .Top ,_fcg ._fgb .Bottom ;};

// TOC returns the table of contents component of the creator.
func (_bcf *Creator )TOC ()*TOC {return _bcf ._fed };

// SetLineWidth sets the line width.
func (_efab *Polyline )SetLineWidth (lineWidth float64 ){_efab ._bacgg .LineWidth =lineWidth };

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_bbga *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _ddgae (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_aede *Division )Height ()float64 {var _effa float64 ;for _ ,_egfd :=range _aede ._dcdd {switch _begf :=_egfd .(type ){case marginDrawable :_ ,_ ,_cdcg ,_dgcg :=_begf .GetMargins ();_effa +=_begf .Height ()+_cdcg +_dgcg ;default:_effa +=_begf .Height ();
};};return _effa ;};

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};func _cabdda (_bgaag ,_cgdbc interface{})(interface{},error ){_agba ,_bgec :=_aaegg (_bgaag );
if _bgec !=nil {return nil ,_bgec ;};switch _fded :=_agba .(type ){case int64 :_ggfgf ,_fdaae :=_aaegg (_cgdbc );if _fdaae !=nil {return nil ,_fdaae ;};switch _ebcfd :=_ggfgf .(type ){case int64 :return _fded +_ebcfd ,nil ;case float64 :return float64 (_fded )+_ebcfd ,nil ;
};case float64 :_dcagd ,_gebafe :=_aaegg (_cgdbc );if _gebafe !=nil {return nil ,_gebafe ;};switch _fged :=_dcagd .(type ){case int64 :return _fded +float64 (_fged ),nil ;case float64 :return _fded +_fged ,nil ;};};return nil ,_e .Errorf ("\u0066\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0025\u0076\u0020\u0061\u006e\u0064\u0020\u0025\u0076",_bgaag ,_cgdbc );
};

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_agbdc *Line )SetFitMode (fitMode FitMode ){_agbdc ._dabe =fitMode };func (_fegd *pageTransformations )transformPage (_gdebf *_gec .PdfPage )error {if _fde :=_fegd .applyFlip (_gdebf );_fde !=nil {return _fde ;};return nil ;};func (_fagaf *templateProcessor )parseFitModeAttr (_bbcd ,_ddbga string )FitMode {_bd .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_bbcd ,_ddbga );
_gbfb :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_ddbga ];return _gbfb ;};func (_dcdc *Chapter )headingText ()string {_gaee :=_dcdc ._ccf ;if _aadf :=_dcdc .headingNumber ();
_aadf !=""{_gaee =_e .Sprintf ("\u0025\u0073\u0020%\u0073",_aadf ,_gaee );};return _gaee ;};func (_dccb *templateProcessor )parseTableCell (_geeab *templateNode )(interface{},error ){if _geeab ._cafd ==nil {_dccb .nodeLogError (_geeab ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_bged ;};_abdff ,_fbfe :=_geeab ._cafd ._cdegg .(*Table );if !_fbfe {_dccb .nodeLogError (_geeab ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_geeab ._cafd ._cdegg );
return nil ,_bged ;};var _fbcf ,_gbcae int64 ;for _ ,_gade :=range _geeab ._cggg .Attr {_abcde :=_gade .Value ;switch _affge :=_gade .Name .Local ;_affge {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_fbcf =_dccb .parseInt64Attr (_affge ,_abcde );case "\u0072o\u0077\u0073\u0070\u0061\u006e":_gbcae =_dccb .parseInt64Attr (_affge ,_abcde );
};};if _fbcf <=0{_fbcf =1;};if _gbcae <=0{_gbcae =1;};_gdcg :=_abdff .MultiCell (int (_gbcae ),int (_fbcf ));for _ ,_fbbfb :=range _geeab ._cggg .Attr {_dgcdb :=_fbbfb .Value ;switch _edgb :=_fbbfb .Name .Local ;_edgb {case "\u0069\u006e\u0064\u0065\u006e\u0074":_gdcg .SetIndent (_dccb .parseFloatAttr (_edgb ,_dgcdb ));
case "\u0061\u006c\u0069g\u006e":_gdcg .SetHorizontalAlignment (_dccb .parseCellAlignmentAttr (_edgb ,_dgcdb ));case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_gdcg .SetVerticalAlignment (_dccb .parseCellVerticalAlignmentAttr (_edgb ,_dgcdb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_gdcg .SetSideBorderStyle (CellBorderSideAll ,_dccb .parseCellBorderStyleAttr (_edgb ,_dgcdb ));case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_gdcg .SetSideBorderStyle (CellBorderSideTop ,_dccb .parseCellBorderStyleAttr (_edgb ,_dgcdb ));
case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_gdcg .SetSideBorderStyle (CellBorderSideBottom ,_dccb .parseCellBorderStyleAttr (_edgb ,_dgcdb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_gdcg .SetSideBorderStyle (CellBorderSideLeft ,_dccb .parseCellBorderStyleAttr (_edgb ,_dgcdb ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_gdcg .SetSideBorderStyle (CellBorderSideRight ,_dccb .parseCellBorderStyleAttr (_edgb ,_dgcdb ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_gdcg .SetSideBorderWidth (CellBorderSideAll ,_dccb .parseFloatAttr (_edgb ,_dgcdb ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_gdcg .SetSideBorderWidth (CellBorderSideTop ,_dccb .parseFloatAttr (_edgb ,_dgcdb ));case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_gdcg .SetSideBorderWidth (CellBorderSideBottom ,_dccb .parseFloatAttr (_edgb ,_dgcdb ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_gdcg .SetSideBorderWidth (CellBorderSideLeft ,_dccb .parseFloatAttr (_edgb ,_dgcdb ));case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_gdcg .SetSideBorderWidth (CellBorderSideRight ,_dccb .parseFloatAttr (_edgb ,_dgcdb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_gdcg .SetSideBorderColor (CellBorderSideAll ,_dccb .parseColorAttr (_edgb ,_dgcdb ));case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_gdcg .SetSideBorderColor (CellBorderSideTop ,_dccb .parseColorAttr (_edgb ,_dgcdb ));
case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_gdcg .SetSideBorderColor (CellBorderSideBottom ,_dccb .parseColorAttr (_edgb ,_dgcdb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_gdcg .SetSideBorderColor (CellBorderSideLeft ,_dccb .parseColorAttr (_edgb ,_dgcdb ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_gdcg .SetSideBorderColor (CellBorderSideRight ,_dccb .parseColorAttr (_edgb ,_dgcdb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_gdcg .SetBorderLineStyle (_dccb .parseLineStyleAttr (_edgb ,_dgcdb ));
case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_gdcg .SetBackgroundColor (_dccb .parseColorAttr (_edgb ,_dgcdb ));case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;
default:_dccb .nodeLogDebug (_geeab ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_edgb );
};};return _gdcg ,nil ;};func (_fbcad *templateProcessor )parseFontAttr (_edag ,_ddcfc string )*_gec .PdfFont {_bd .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_edag ,_ddcfc );
_efeeg :=_fbcad .creator ._dgaf ;if _ddcfc ==""{return _efeeg ;};_aaag :=_bea .Split (_ddcfc ,"\u002c");for _ ,_fagg :=range _aaag {_fagg =_bea .TrimSpace (_fagg );if _fagg ==""{continue ;};_cded ,_cbgfb :=_fbcad ._bcaf .FontMap [_ddcfc ];if _cbgfb {return _cded ;
};_fcgbb ,_cbgfb :=map[string ]_gec .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_gec .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_gec .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_gec .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_gec .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_gec .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_gec .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_gec .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_gec .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_gec .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_gec .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_gec .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_gec .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_gec .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_gec .TimesBoldItalicName }[_ddcfc ];
if _cbgfb {if _bbacf ,_acgae :=_gec .NewStandard14Font (_fcgbb );_acgae ==nil {return _bbacf ;};};if _bceec :=_fbcad .parseAttrPropList (_fagg );len (_bceec )> 0{if _abfedb ,_geeabf :=_bceec ["\u0070\u0061\u0074\u0068"];_geeabf {_fcbbb :=_gec .NewPdfFontFromTTFFile ;
if _fcbbd ,_bebed :=_bceec ["\u0074\u0079\u0070\u0065"];_bebed &&_fcbbd =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_fcbbb =_gec .NewCompositePdfFontFromTTFFile ;};if _efcc ,_cedeg :=_fcbbb (_abfedb );_cedeg !=nil {_bd .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_abfedb ,_cedeg );
}else {return _efcc ;};};};};return _efeeg ;};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_bdce *Invoice )InfoLines ()[][2]*InvoiceCell {_gcfb :=[][2]*InvoiceCell {_bdce ._bebc ,_bdce ._gbdb ,_bdce ._gefg };return append (_gcfb ,_bdce ._effcg ...);};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_adbdf Color ;_dbgfb _gg .LineStyle ;_afggg CellBorderStyle ;_aeab Color ;_dceac float64 ;_bbefe CellBorderStyle ;_dgbdg Color ;_ecba float64 ;_ccdgd CellBorderStyle ;_ceff Color ;_degae float64 ;_defff CellBorderStyle ;_ageeb Color ;
_bbeee float64 ;_eddfg ,_dfdfe int ;_bcgc int ;_cebg int ;_cbbec VectorDrawable ;_faefa CellHorizontalAlignment ;_adgeg CellVerticalAlignment ;_dbafb float64 ;_cedbg *Table ;};func (_eabd *pageTransformations )applyFlip (_aadc *_gec .PdfPage )error {_dgcf ,_dgag :=_eabd ._fbac ,_eabd ._eeb ;
if !_dgcf &&!_dgag {return nil ;};if _aadc ==nil {return _d .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_dcae ,_afag :=_aadc .GetMediaBox ();if _afag !=nil {return _afag ;};_gecb ,_afeb :=_dcae .Width (),_dcae .Height ();
_bgac ,_afag :=_aadc .GetRotate ();if _afag !=nil {_bd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_afag .Error ());
};if _fefe :=_bgac %360!=0&&_bgac %90==0;_fefe {if _eece :=(360+_bgac %360)%360;_eece ==90||_eece ==270{_dgcf ,_dgag =_dgag ,_dgcf ;};};_dcb ,_aagd :=1.0,0.0;if _dgcf {_dcb ,_aagd =-1.0,-_gecb ;};_bgeb ,_dfc :=1.0,0.0;if _dgag {_bgeb ,_dfc =-1.0,-_afeb ;
};_ccbc :=_bee .NewContentCreator ().Scale (_dcb ,_bgeb ).Translate (_aagd ,_dfc );_ebae ,_afag :=_dc .MakeStream (_ccbc .Bytes (),_dc .NewFlateEncoder ());if _afag !=nil {return _afag ;};_bdgg :=_dc .MakeArray (_ebae );_bdgg .Append (_aadc .GetContentStreamObjs ()...);
_aadc .Contents =_bdgg ;return nil ;};func _egga (_cgade Color ,_aefa float64 )*ColorPoint {return &ColorPoint {_accee :_cgade ,_ccbcc :_aefa };};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_adegg *shading )SetBackgroundColor (backgroundColor Color ){_adegg ._edaa =backgroundColor };func (_ggccd *templateProcessor )parseCellAlignmentAttr (_geecd ,_efbc string )CellHorizontalAlignment {_bd .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_geecd ,_efbc );
_bacbf :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_efbc ];return _bacbf ;
};func _cged (_gfde *_gec .Image )(*Image ,error ){_defa :=float64 (_gfde .Width );_dfbd :=float64 (_gfde .Height );return &Image {_adgg :_gfde ,_cbfd :_defa ,_gegfd :_dfbd ,_bdebc :_defa ,_eaec :_dfbd ,_afcf :0,_abgdb :1.0,_acde :PositionRelative },nil ;
};func _gebgc (_bdae [][]_gg .Point )*Polygon {return &Polygon {_efae :&_gg .Polygon {Points :_bdae },_bafb :1.0,_cggc :1.0};};

// Style returns the style of the line.
func (_fgcab *Line )Style ()_gg .LineStyle {return _fgcab ._ddde };func _dacc (_bbaab string )(*Image ,error ){_abac ,_bfce :=_cg .Open (_bbaab );if _bfce !=nil {return nil ,_bfce ;};defer _abac .Close ();_gfgc ,_bfce :=_gec .ImageHandling .Read (_abac );
if _bfce !=nil {_bd .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bfce );return nil ,_bfce ;};return _cged (_gfgc );};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_fagge *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_egbec :=&_fagge ._gcgec ;_egbec .Left =left ;_egbec .Right =right ;_egbec .Top =top ;_egbec .Bottom =bottom ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_gaef *Table )SetPos (x ,y float64 ){_gaef ._cfcbe =PositionAbsolute ;_gaef ._dbdeb =x ;_gaef ._edde =y ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_cbed *Creator )DrawFooter (drawFooterFunc func (_cgad *Block ,_egg FooterFunctionArgs )){_cbed ._fgc =drawFooterFunc ;};func _ggac (_fdcd *templateProcessor ,_cbag *templateNode )(interface{},error ){return _fdcd .parseRectangle (_cbag );};func (_addc *Paragraph )getTextMetrics ()(_bfbd ,_bdec ,_addbc float64 ){_cfaa :=_baeef (_addc ._eged ,_addc ._dffb );
if _cfaa ._dgbdd > _bfbd {_bfbd =_cfaa ._dgbdd ;};if _cfaa ._fcef < _addbc {_addbc =_cfaa ._fcef ;};if _gbed :=_addc ._dffb ;_gbed > _bdec {_bdec =_gbed ;};return _bfbd ,_bdec ,_addbc ;};var PPI float64 =72;func (_geba *TemplateOptions )init (){if _geba .SubtemplateMap ==nil {_geba .SubtemplateMap =map[string ]_ef .Reader {};
};if _geba .FontMap ==nil {_geba .FontMap =map[string ]*_gec .PdfFont {};};if _geba .ImageMap ==nil {_geba .ImageMap =map[string ]*_gec .Image {};};if _geba .ColorMap ==nil {_geba .ColorMap =map[string ]Color {};};if _geba .ChartMap ==nil {_geba .ChartMap =map[string ]_de .ChartRenderable {};
};};

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_fbfg *Chart )Width ()float64 {return float64 (_fbfg ._gegc .Width ())};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_ggec *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _d .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _d .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _d .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_ggec ._ddagb =true ;_ggec ._dbbcc =startRow ;_ggec ._gdecd =endRow ;return nil ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType2 object.
func (_badg *LinearShading )ToPdfShadingPattern ()*_gec .PdfShadingPatternType2 {_cgbd ,_bgaee ,_fccaa :=_badg ._dece ._edaa .ToRGB ();_gbac :=_badg .shadingModel ();_gbac .PdfShading .Background =_dc .MakeArrayFromFloats ([]float64 {_cgbd ,_bgaee ,_fccaa });
_adcgd :=_gec .NewPdfShadingPatternType2 ();_adcgd .Shading =_gbac ;return _adcgd ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_adee string ;_eged *_gec .PdfFont ;_dffb float64 ;_cdeb float64 ;_fafd Color ;_abcc TextAlignment ;_bcab bool ;_abcd float64 ;_dfedg int ;_fffec bool ;_edef float64 ;_bgcd Margins ;_dfgb Positioning ;_fbeab float64 ;_dbec float64 ;
_aafbf ,_dabbdf float64 ;_bdad []string ;};func (_gfgd *List )ctxHeight (_cgee float64 )float64 {_cgee -=_gfgd ._ecfe ;var _cabg float64 ;for _ ,_cbge :=range _gfgd ._eacg {_cabg +=_cbge .ctxHeight (_cgee );};return _cabg ;};func (_adbg *Line )computeCoords (_eaga DrawContext )(_aafcd ,_cbeeg ,_fccb ,_gagg float64 ){_aafcd =_eaga .X ;
_fccb =_aafcd +_adbg ._ccfa -_adbg ._cfgae ;_abggf :=_adbg ._faaeb ;if _adbg ._cfgae ==_adbg ._ccfa {_abggf /=2;};if _adbg ._ebf < _adbg ._cfcbb {_cbeeg =_eaga .PageHeight -_eaga .Y -_abggf ;_gagg =_cbeeg -_adbg ._cfcbb +_adbg ._ebf ;}else {_gagg =_eaga .PageHeight -_eaga .Y -_abggf ;
_cbeeg =_gagg -_adbg ._ebf +_adbg ._cfcbb ;};switch _adbg ._dabe {case FitModeFillWidth :_fccb =_aafcd +_eaga .Width ;};return _aafcd ,_cbeeg ,_fccb ,_gagg ;};var PPMM =float64 (72*1.0/25.4);

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_ggggf *TOC )SetLineLevelOffset (levelOffset float64 ){_ggggf ._cacgf =levelOffset };

// NewGraphicSVGFromString creates a graphic SVG from a SVG string.
func NewGraphicSVGFromString (svgStr string )(*GraphicSVG ,error ){return _bgge (svgStr )};func _fcbca ()*PageBreak {return &PageBreak {}};

// SetMargins sets the margins of the graphic svg component.
func (_afdef *GraphicSVG )SetMargins (left ,right ,top ,bottom float64 ){_afdef ._fggef .Left =left ;_afdef ._fggef .Right =right ;_afdef ._fggef .Top =top ;_afdef ._fggef .Bottom =bottom ;};

// SetBorderOpacity sets the border opacity.
func (_eeaab *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_eeaab ._gggfc =opacity };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_gcea *Paragraph )SetWidth (width float64 ){_gcea ._abcd =width ;_gcea .wrapText ()};

// LinearShading holds data for rendering a linear shading gradient.
type LinearShading struct{_dece *shading ;_fadfd *_gec .PdfRectangle ;_cfbb float64 ;};

// FillOpacity returns the fill opacity of the ellipse (0-1).
func (_cae *Ellipse )FillOpacity ()float64 {return _cae ._gaddb };

// AnchorPoint defines anchor point where the center position of the radial gradient would be calculated.
type AnchorPoint int ;

// Height returns Image's document height.
func (_cdad *Image )Height ()float64 {return _cdad ._eaec };func (_fbffg *templateProcessor )parseAttrPropList (_dbfd string )map[string ]string {_adbdg :=_bea .Fields (_dbfd );if len (_adbdg )==0{return nil ;};_becgc :=map[string ]string {};for _ ,_cecd :=range _adbdg {_fadde :=_ggcce .FindStringSubmatch (_cecd );
if len (_fadde )< 3{continue ;};_cabda ,_gedcf :=_bea .TrimSpace (_fadde [1]),_fadde [2];if _cabda ==""{continue ;};_becgc [_cabda ]=_gedcf ;};return _becgc ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_ffee *Chapter )GetHeading ()*Paragraph {return _ffee ._aec };func (_caeg *Paragraph )getTextWidth ()float64 {_gebbf :=0.0;for _ ,_dfad :=range _caeg ._adee {if _dfad =='\u000A'{continue ;};_fdef ,_fegc :=_caeg ._eged .GetRuneMetrics (_dfad );if !_fegc {_bd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_dfad ,_dfad );
return -1;};_gebbf +=_caeg ._dffb *_fdef .Wx ;};return _gebbf ;};type templateTag struct{_gdea map[string ]struct{};_cfcg func (*templateProcessor ,*templateNode )(interface{},error );};func (_bdf *Block )setOpacity (_aeg float64 ,_db float64 )(string ,error ){if (_aeg < 0||_aeg >=1.0)&&(_db < 0||_db >=1.0){return "",nil ;
};_fbf :=0;_cad :=_e .Sprintf ("\u0047\u0053\u0025\u0064",_fbf );for _bdf ._fb .HasExtGState (_dc .PdfObjectName (_cad )){_fbf ++;_cad =_e .Sprintf ("\u0047\u0053\u0025\u0064",_fbf );};_ba :=_dc .MakeDict ();if _aeg >=0&&_aeg < 1.0{_ba .Set ("\u0063\u0061",_dc .MakeFloat (_aeg ));
};if _db >=0&&_db < 1.0{_ba .Set ("\u0043\u0041",_dc .MakeFloat (_db ));};_cadc :=_bdf ._fb .AddExtGState (_dc .PdfObjectName (_cad ),_ba );if _cadc !=nil {return "",_cadc ;};return _cad ,nil ;};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_ceab *Invoice )Sections ()[][2]string {return _ceab ._gede };type cmykColor struct{_cbe ,_aacg ,_cbb ,_fbcg float64 };

// Width returns Image's document width.
func (_ffbg *Image )Width ()float64 {return _ffbg ._bdebc };

// SetStyle sets the style of the line (solid or dashed).
func (_ffag *Line )SetStyle (style _gg .LineStyle ){_ffag ._ddde =style };func (_gfgf *templateProcessor )parseColorAttr (_bdbef ,_caaa string )Color {_bd .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_bdbef ,_caaa );
_caaa =_bea .TrimSpace (_caaa );if _bea .HasPrefix (_caaa ,"\u006c\u0069n\u0065\u0061\u0072-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_bea .HasSuffix (_caaa ,"\u0029")&&len (_caaa )> 17{return _gfgf .parseLinearGradientAttr (_gfgf .creator ,_caaa );
};if _bea .HasPrefix (_caaa ,"\u0072\u0061d\u0069\u0061\u006c-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_bea .HasSuffix (_caaa ,"\u0029")&&len (_caaa )> 17{return _gfgf .parseRadialGradientAttr (_gfgf .creator ,_caaa );};if _ffbc :=_gfgf .parseColor (_caaa );
_ffbc !=nil {return _ffbc ;};return ColorBlack ;};

// FitMode returns the fit mode of the image.
func (_bgdae *Image )FitMode ()FitMode {return _bgdae ._ade };

// SetBorderOpacity sets the border opacity of the rectangle.
func (_decae *Rectangle )SetBorderOpacity (opacity float64 ){_decae ._gcdb =opacity };func _baeef (_egdedb *_gec .PdfFont ,_fegg float64 )*fontMetrics {_fabfd :=&fontMetrics {};if _egdedb ==nil {_bd .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0066\u006f\u006e\u0074\u0020\u0069s\u0020\u006e\u0069\u006c");
return _fabfd ;};_cdecf ,_cdbdb :=_egdedb .GetFontDescriptor ();if _cdbdb !=nil {_bd .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063ri\u0070\u0074\u006fr\u003a \u0025\u0076",_cdbdb );
return _fabfd ;};if _fabfd ._dgbdd ,_cdbdb =_cdecf .GetCapHeight ();_cdbdb !=nil {_bd .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0067\u0065\u0074\u0020f\u006f\u006e\u0074\u0020\u0063\u0061\u0070\u0020\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_cdbdb );
};if int (_fabfd ._dgbdd )<=0{_bd .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_fabfd ._dgbdd =1000;};_fabfd ._dgbdd *=_fegg /1000.0;if _fabfd ._eceag ,_cdbdb =_cdecf .GetXHeight ();_cdbdb !=nil {_bd .Log .Trace ("\u0057\u0041R\u004e\u003a\u0020\u0055n\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0078\u002d\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_cdbdb );
};_fabfd ._eceag *=_fegg /1000.0;if _fabfd ._ggfea ,_cdbdb =_cdecf .GetAscent ();_cdbdb !=nil {_bd .Log .Trace ("W\u0041\u0052\u004e\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0066\u006fn\u0074\u0020\u0061\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_cdbdb );
};_fabfd ._ggfea *=_fegg /1000.0;if _fabfd ._fcef ,_cdbdb =_cdecf .GetDescent ();_cdbdb !=nil {_bd .Log .Trace ("\u0057\u0041RN\u003a\u0020\u0055n\u0061\u0062\u006c\u0065 to\u0020ge\u0074\u0020\u0066\u006f\u006e\u0074\u0020de\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_cdbdb );
};_fabfd ._fcef *=_fegg /1000.0;return _fabfd ;};func (_gdgef *List )markerWidth ()float64 {var _dffe float64 ;for _ ,_bege :=range _gdgef ._eacg {_eabca :=_bffb (_gdgef ._gfag );_eabca .SetEnableWrap (false );_eabca .SetTextAlignment (TextAlignmentRight );
_eabca .Append (_bege ._fddae .Text ).Style =_bege ._fddae .Style ;_geff :=_eabca .getTextWidth ()/1000.0;if _dffe < _geff {_dffe =_geff ;};};return _dffe ;};

// ScaleToWidth scales the rectangle to the specified width. The height of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_ccfgd *Rectangle )ScaleToWidth (w float64 ){_gadc :=_ccfgd ._gfef /_ccfgd ._dgdba ;_ccfgd ._dgdba =w ;_ccfgd ._gfef =w *_gadc ;};

// SetMargins sets the margins of the paragraph.
func (_affd *List )SetMargins (left ,right ,top ,bottom float64 ){_affd ._ebde .Left =left ;_affd ._ebde .Right =right ;_affd ._ebde .Top =top ;_affd ._ebde .Bottom =bottom ;};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style ,VerticalAlignment :TextVerticalAlignmentBaseline };};

// SetWidth sets the width of the rectangle.
func (_degc *Rectangle )SetWidth (width float64 ){_degc ._dgdba =width };func _fbcb (_faf ,_dec *_gec .PdfPageResources )error {_eab ,_ :=_faf .GetColorspaces ();if _eab !=nil &&len (_eab .Colorspaces )> 0{for _gdf ,_gce :=range _eab .Colorspaces {_gfa :=*_dc .MakeName (_gdf );
if _dec .HasColorspaceByName (_gfa ){continue ;};_adf :=_dec .SetColorspaceByName (_gfa ,_gce );if _adf !=nil {return _adf ;};};};return nil ;};func _dcdcd (_adfae *_bfg .GraphicSVG )(*GraphicSVG ,error ){return &GraphicSVG {_bbce :_adfae ,_aeag :PositionRelative ,_fggef :Margins {Top :10,Bottom :10}},nil ;
};func _bccbc (_bgeag *_a .Decoder )(int ,int ){return 0,0};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_egeeg *TOC )SetLineNumberStyle (style TextStyle ){_egeeg ._cgagb =style };func _gfee (_gcgf *templateProcessor ,_ggfafa *templateNode )(interface{},error ){return _gcgf .parseTextChunk (_ggfafa ,nil );};func _bffb (_cgedb TextStyle )*StyledParagraph {return &StyledParagraph {_acbg :[]*TextChunk {},_gfbba :_cgedb ,_dffcf :_fggf (_cgedb .Font ),_cdadd :1.0,_ebcg :TextAlignmentLeft ,_cafa :true ,_cfdd :true ,_gedfe :false ,_dafa :0,_eddbe :1,_ccdbc :1,_ebdeg :PositionRelative };
};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
//
// Note: Currently Styled Paragraph doesn't support TextVerticalAlignmentBottom
// as that option only used for aligning text chunks.
//
// In order to change the vertical alignment of individual text chunks, use TextChunk.VerticalAlignment.
func (_cdegc *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_cdegc ._ggdge =align ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_ad *Block )ScaleToHeight (h float64 ){_fcb :=h /_ad ._df ;_ad .Scale (_fcb ,_fcb )};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_bafc *Creator )SetPageLabels (pageLabels _dc .PdfObject ){_bafc ._babd =pageLabels };

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_cfeg *Creator )Draw (d Drawable )error {if _cfeg .getActivePage ()==nil {_cfeg .NewPage ();};_gedf ,_fcdf ,_deaa :=d .GeneratePageBlocks (_cfeg ._bdfae );if _deaa !=nil {return _deaa ;};if len (_fcdf ._ddgg )> 0{_cfeg .Errors =append (_cfeg .Errors ,_fcdf ._ddgg ...);
};for _befd ,_cafb :=range _gedf {if _befd > 0{_cfeg .NewPage ();};_fead :=_cfeg .getActivePage ();if _dead ,_fcbd :=_cfeg ._gggc [_fead ];_fcbd {if _cdfag :=_dead .mergeBlocks (_cafb );_cdfag !=nil {return _cdfag ;};if _acag :=_fbcb (_cafb ._fb ,_dead ._fb );
_acag !=nil {return _acag ;};}else {_cfeg ._gggc [_fead ]=_cafb ;};};_cfeg ._bdfae .X =_fcdf .X ;_cfeg ._bdfae .Y =_fcdf .Y ;_cfeg ._bdfae .Height =_fcdf .PageHeight -_fcdf .Y -_fcdf .Margins .Bottom ;return nil ;};

// SetFillColor sets the fill color of the ellipse.
func (_ccab *Ellipse )SetFillColor (col Color ){_ccab ._fddfa =col };type listItem struct{_bdbgb VectorDrawable ;_fddae TextChunk ;};

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_bbaa *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cgeb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_acaga ,_adfa :=_cgeb .setOpacity (_bbaa ._fegad ,_bbaa ._fecf );if _adfa !=nil {return nil ,ctx ,_adfa ;
};_adfb :=_bbaa ._cecf ;_adfb .FillEnabled =_adfb .FillColor !=nil ;_adfb .BorderEnabled =_adfb .BorderColor !=nil &&_adfb .BorderWidth > 0;var (_gcge =ctx .PageHeight ;_dfgd =_adfb .Rings ;_cbc =make ([][]_gg .CubicBezierCurve ,0,len (_adfb .Rings ));
);_gbca :=_gec .PdfRectangle {};if len (_dfgd )> 0&&len (_dfgd [0])> 0{_fffe :=_dfgd [0][0];_fffe .P0 .Y =_gcge -_fffe .P0 .Y ;_fffe .P1 .Y =_gcge -_fffe .P1 .Y ;_fffe .P2 .Y =_gcge -_fffe .P2 .Y ;_fffe .P3 .Y =_gcge -_fffe .P3 .Y ;_gbca =_fffe .GetBounds ();
};for _ ,_fcff :=range _dfgd {_cgef :=make ([]_gg .CubicBezierCurve ,0,len (_fcff ));for _ ,_bbca :=range _fcff {_ggc :=_bbca ;_ggc .P0 .Y =_gcge -_ggc .P0 .Y ;_ggc .P1 .Y =_gcge -_ggc .P1 .Y ;_ggc .P2 .Y =_gcge -_ggc .P2 .Y ;_ggc .P3 .Y =_gcge -_ggc .P3 .Y ;
_cgef =append (_cgef ,_ggc );_gafa :=_ggc .GetBounds ();_gbca .Llx =_ag .Min (_gbca .Llx ,_gafa .Llx );_gbca .Lly =_ag .Min (_gbca .Lly ,_gafa .Lly );_gbca .Urx =_ag .Max (_gbca .Urx ,_gafa .Urx );_gbca .Ury =_ag .Max (_gbca .Ury ,_gafa .Ury );};_cbc =append (_cbc ,_cgef );
};_adfb .Rings =_cbc ;defer func (){_adfb .Rings =_dfgd }();if _adfb .FillEnabled {_geaf :=_eecec (_cgeb ,_bbaa ._cecf .FillColor ,_bbaa ._cedb ,func ()Rectangle {return Rectangle {_edaf :_gbca .Llx ,_dgedd :_gbca .Lly ,_dgdba :_gbca .Width (),_gfef :_gbca .Height ()};
});if _geaf !=nil {return nil ,ctx ,_geaf ;};};_acce ,_ ,_adfa :=_adfb .Draw (_acaga );if _adfa !=nil {return nil ,ctx ,_adfa ;};if _adfa =_cgeb .addContentsByString (string (_acce ));_adfa !=nil {return nil ,ctx ,_adfa ;};return []*Block {_cgeb },ctx ,nil ;
};

// SetPos sets the position of the graphic svg to the specified coordinates.
// This method sets the graphic svg to use absolute positioning.
func (_cdaa *GraphicSVG )SetPos (x ,y float64 ){_cdaa ._aeag =PositionAbsolute ;_cdaa ._geaaa =x ;_cdaa ._gge =y ;};

// GeneratePageBlocks draws the ellipse on a new block representing the page.
func (_cgdg *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_cceg []*Block ;_fcab =NewBlock (ctx .PageWidth ,ctx .PageHeight );_dgfc =ctx ;);_dafe :=_cgdg ._ggfe .IsRelative ();if _dafe {_cgdg .applyFitMode (ctx .Width );
ctx .X +=_cgdg ._ddcf .Left ;ctx .Y +=_cgdg ._ddcf .Top ;ctx .Width -=_cgdg ._ddcf .Left +_cgdg ._ddcf .Right ;ctx .Height -=_cgdg ._ddcf .Top +_cgdg ._ddcf .Bottom ;if _cgdg ._gaeb > ctx .Height {_cceg =append (_cceg ,_fcab );_fcab =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_ddcg :=ctx ;_ddcg .Y =ctx .Margins .Top +_cgdg ._ddcf .Top ;_ddcg .X =ctx .Margins .Left +_cgdg ._ddcf .Left ;_ddcg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_cgdg ._ddcf .Top -_cgdg ._ddcf .Bottom ;_ddcg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_cgdg ._ddcf .Left -_cgdg ._ddcf .Right ;
ctx =_ddcg ;};}else {ctx .X =_cgdg ._gac -_cgdg ._eegf /2;ctx .Y =_cgdg ._dbcef -_cgdg ._gaeb /2;};_bggg :=_gg .Circle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_cgdg ._gaeb ,Width :_cgdg ._eegf ,Height :_cgdg ._gaeb ,BorderWidth :_cgdg ._eagd ,Opacity :1.0};
if _cgdg ._fddfa !=nil {_bggg .FillEnabled =true ;_fccf :=_dbceg (_cgdg ._fddfa );_dddf :=_eecec (_fcab ,_fccf ,_cgdg ._fddfa ,func ()Rectangle {return Rectangle {_edaf :_bggg .X ,_dgedd :_bggg .Y ,_dgdba :_bggg .Width ,_gfef :_bggg .Height };});if _dddf !=nil {return nil ,ctx ,_dddf ;
};_bggg .FillColor =_fccf ;};if _cgdg ._dgde !=nil {_bggg .BorderEnabled =false ;if _cgdg ._eagd > 0{_bggg .BorderEnabled =true ;};_bggg .BorderColor =_dbceg (_cgdg ._dgde );_bggg .BorderWidth =_cgdg ._eagd ;};_fecea ,_agfbe :=_fcab .setOpacity (_cgdg ._gaddb ,_cgdg ._fda );
if _agfbe !=nil {return nil ,ctx ,_agfbe ;};_fgag ,_ ,_agfbe :=_bggg .Draw (_fecea );if _agfbe !=nil {return nil ,ctx ,_agfbe ;};_agfbe =_fcab .addContentsByString (string (_fgag ));if _agfbe !=nil {return nil ,ctx ,_agfbe ;};if _dafe {ctx .X =_dgfc .X ;
ctx .Width =_dgfc .Width ;ctx .Y +=_cgdg ._gaeb +_cgdg ._ddcf .Bottom ;ctx .Height -=_cgdg ._gaeb ;}else {ctx =_dgfc ;};_cceg =append (_cceg ,_fcab );return _cceg ,ctx ,nil ;};func _ebgcg (_cdde *templateProcessor ,_dfbgg *templateNode )(interface{},error ){return _cdde .parseListMarker (_dfbgg );
};func (_eaef *shading )generatePdfFunctions ()[]_gec .PdfFunction {if len (_eaef ._cbgef )==0{return nil ;}else if len (_eaef ._cbgef )<=2{_fbda ,_egae ,_faaf :=_eaef ._cbgef [0]._accee .ToRGB ();_gaggb ,_dfdcf ,_daad :=_eaef ._cbgef [len (_eaef ._cbgef )-1]._accee .ToRGB ();
return []_gec .PdfFunction {&_gec .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_fbda ,_egae ,_faaf },C1 :[]float64 {_gaggb ,_dfdcf ,_daad }}};}else {_feged :=[]_gec .PdfFunction {};_ddbg :=[]float64 {};
for _dade :=0;_dade < len (_eaef ._cbgef )-1;_dade ++{_deecg ,_abba ,_aceb :=_eaef ._cbgef [_dade ]._accee .ToRGB ();_cadfb ,_eegg ,_ebda :=_eaef ._cbgef [_dade +1]._accee .ToRGB ();_bdeg :=&_gec .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_deecg ,_abba ,_aceb },C1 :[]float64 {_cadfb ,_eegg ,_ebda }};
_feged =append (_feged ,_bdeg );if _dade > 0{_ddbg =append (_ddbg ,_eaef ._cbgef [_dade ]._ccbcc );};};_dbebc :=[]float64 {};for range _feged {_dbebc =append (_dbebc ,[]float64 {0.0,1.0}...);};return []_gec .PdfFunction {&_gec .PdfFunctionType3 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},Functions :_feged ,Bounds :_ddbg ,Encode :_dbebc }};
};};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// FillOpacity returns the fill opacity of the rectangle (0-1).
func (_aaed *Rectangle )FillOpacity ()float64 {return _aaed ._bcag };

// NewColumn returns a new column for the line items invoice table.
func (_afda *Invoice )NewColumn (description string )*InvoiceCell {return _afda .newColumn (description ,CellHorizontalAlignmentLeft );};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func (_adcdb *templateProcessor )parseLinearGradientAttr (creator *Creator ,_afcfg string )Color {_begb :=ColorBlack ;if _afcfg ==""{return _begb ;};_feaf :=creator .NewLinearGradientColor ([]*ColorPoint {});_feaf .SetExtends (true ,true );
var (_ffgfd =_bea .Split (_afcfg [16:len (_afcfg )-1],"\u002c");_afede =_bea .TrimSpace (_ffgfd [0]););if _bea .HasSuffix (_afede ,"\u0064\u0065\u0067"){_fbbfbd ,_bggbe :=_fa .ParseFloat (_afede [:len (_afede )-3],64);if _bggbe !=nil {_bd .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0067\u0072\u0061\u0064\u0069e\u006e\u0074\u0020\u0061\u006e\u0067\u006ce\u003a\u0020\u0025\u0076",_bggbe );
}else {_feaf .SetAngle (_fbbfbd );};_ffgfd =_ffgfd [1:];};_ddbfa ,_bfdfd :=_adcdb .processGradientColorPair (_ffgfd );if _ddbfa ==nil ||_bfdfd ==nil {return _begb ;};for _cbfc :=0;_cbfc < len (_ddbfa );_cbfc ++{_feaf .AddColorStop (_ddbfa [_cbfc ],_bfdfd [_cbfc ]);
};return _feaf ;};func (_bcec *templateProcessor )parseTable (_egaag *templateNode )(interface{},error ){var _abfb int64 ;for _ ,_dfdgd :=range _egaag ._cggg .Attr {_aggbc :=_dfdgd .Value ;switch _cega :=_dfdgd .Name .Local ;_cega {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_abfb =_bcec .parseInt64Attr (_cega ,_aggbc );
};};if _abfb <=0{_bcec .nodeLogDebug (_egaag ,"\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_abfb );
_abfb =1;};_dccfb :=_bcec .creator .NewTable (int (_abfb ));for _ ,_befaf :=range _egaag ._cggg .Attr {_ccdad :=_befaf .Value ;switch _dcde :=_befaf .Name .Local ;_dcde {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_dccfb .SetColumnWidths (_bcec .parseFloatArray (_dcde ,_ccdad )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_cdfeg :=_bcec .parseMarginAttr (_dcde ,_ccdad );_dccfb .SetMargins (_cdfeg .Left ,_cdfeg .Right ,_cdfeg .Top ,_cdfeg .Bottom );case "\u0078":_dccfb .SetPos (_bcec .parseFloatAttr (_dcde ,_ccdad ),_dccfb ._edde );
case "\u0079":_dccfb .SetPos (_dccfb ._dbdeb ,_bcec .parseFloatAttr (_dcde ,_ccdad ));case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_dccfb ._dbbcc =int (_bcec .parseInt64Attr (_dcde ,_ccdad ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_dccfb ._gdecd =int (_bcec .parseInt64Attr (_dcde ,_ccdad ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_dccfb .EnableRowWrap (_bcec .parseBoolAttr (_dcde ,_ccdad ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_dccfb .EnablePageWrap (_bcec .parseBoolAttr (_dcde ,_ccdad ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_bcec .nodeLogDebug (_egaag ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_dcde );
};};if _dccfb ._dbbcc !=0&&_dccfb ._gdecd !=0{_cdcd :=_dccfb .SetHeaderRows (_dccfb ._dbbcc ,_dccfb ._gdecd );if _cdcd !=nil {_bcec .nodeLogDebug (_egaag ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_cdcd );
};}else {_dccfb ._dbbcc =0;_dccfb ._gdecd =0;};return _dccfb ,nil ;};

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_fbcc *Division )Width ()float64 {return 0};

// ScaleToHeight scales the rectangle to the specified height. The width of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_dcgfb *Rectangle )ScaleToHeight (h float64 ){_cdbbg :=_dcgfb ._dgdba /_dcgfb ._gfef ;_dcgfb ._gfef =h ;_dcgfb ._dgdba =h *_cdbbg ;};var (_ggcce =_bf .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");
_gfeda =_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");_bged =_d .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");
_eccbe =_d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");_cgfe =_d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e");
);

// BorderWidth returns the border width of the rectangle.
func (_aege *Rectangle )BorderWidth ()float64 {return _aege ._dacd };

// Text sets the text content of the Paragraph.
func (_faeb *Paragraph )Text ()string {return _faeb ._adee };func (_eefa *Image )makeXObject ()error {_ddce ,_bfed :=_gec .NewXObjectImageFromImageLazy (_eefa ._adgg ,nil ,_eefa ._faaad ,_eefa ._aeef );if _bfed !=nil {_bd .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bfed );
return _bfed ;};_eefa ._dccf =_ddce ;return nil ;};func (_aggbbb *Table )getLastCellFromCol (_cfgcb int )(int ,*TableCell ){for _cgdb :=len (_aggbbb ._dabec )-1;_cgdb >=0;_cgdb --{if _aggbbb ._dabec [_cgdb ]._dfdfe ==_cfgcb {return _cgdb ,_aggbbb ._dabec [_cgdb ];
};};return 0,nil ;};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_ebee *TOCLine )SetStyle (style TextStyle ){_ebee .Number .Style =style ;_ebee .Title .Style =style ;_ebee .Separator .Style =style ;_ebee .Page .Style =style ;};func (_cffcea *Paragraph )getMaxLineWidth ()float64 {if _cffcea ._bdad ==nil ||len (_cffcea ._bdad )==0{_cffcea .wrapText ();
};var _cbeb float64 ;for _ ,_fffb :=range _cffcea ._bdad {_ecad :=_cffcea .getTextLineWidth (_fffb );if _ecad > _cbeb {_cbeb =_ecad ;};};return _cbeb ;};

// SellerAddress returns the seller address used in the invoice template.
func (_efaa *Invoice )SellerAddress ()*InvoiceAddress {return _efaa ._bega };

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_gdfg float64 ;_cggd float64 ;_faba float64 ;_fbbb float64 ;_beg float64 ;_gaga float64 ;_aada Color ;_ddgb float64 ;};

// SetMargins sets the Paragraph's margins.
func (_bcbd *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_bcbd ._dfcfg .Left =left ;_bcbd ._dfcfg .Right =right ;_bcbd ._dfcfg .Top =top ;_bcbd ._dfcfg .Bottom =bottom ;};type componentRenderer interface{Draw (_ddagc Drawable )error ;
};

// FitMode returns the fit mode of the rectangle.
func (_acbb *Rectangle )FitMode ()FitMode {return _acbb ._ccef };

// FillColor returns the fill color of the ellipse.
func (_gcgef *Ellipse )FillColor ()Color {return _gcgef ._fddfa };

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_acfd *Invoice )Terms ()(string ,string ){return _acfd ._fcgg [0],_acfd ._fcgg [1]};

// Level returns the indentation level of the TOC line.
func (_fffea *TOCLine )Level ()uint {return _fffea ._aabgg };

// Width returns the width of the Paragraph.
func (_gdedc *StyledParagraph )Width ()float64 {if _gdedc ._cafa &&int (_gdedc ._dabc )> 0{return _gdedc ._dabc ;};return _gdedc .getTextWidth ()/1000.0;};

// AppendColumn appends a column to the line items table.
func (_agbe *Invoice )AppendColumn (description string )*InvoiceCell {_ggdae :=_agbe .NewColumn (description );_agbe ._bcdc =append (_agbe ._bcdc ,_ggdae );return _ggdae ;};func (_fcbag *templateProcessor )parseTextVerticalAlignmentAttr (_egdaad ,_ddcfd string )TextVerticalAlignment {_bd .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_egdaad ,_ddcfd );
_ffda :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_ddcfd ];return _ffda ;};

// SetCompactMode sets the compact mode flag for this table.
//
// By enabling compact mode, table cell that contains Paragraph/StyleParagraph
// would not add extra height when calculating it's height.
//
// The default value is false.
func (_fbdf *Table )SetCompactMode (enable bool ){_fbdf ._bbef =enable };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_gagaf *RadialShading )SetBackgroundColor (backgroundColor Color ){_gagaf ._ddggc .SetBackgroundColor (backgroundColor );};func (_agec *Image )rotatedSize ()(float64 ,float64 ){_cgbga :=_agec ._bdebc ;_gfcg :=_agec ._eaec ;_fbae :=_agec ._afcf ;if _fbae ==0{return _cgbga ,_gfcg ;
};_eeab :=_gg .Path {Points :[]_gg .Point {_gg .NewPoint (0,0).Rotate (_fbae ),_gg .NewPoint (_cgbga ,0).Rotate (_fbae ),_gg .NewPoint (0,_gfcg ).Rotate (_fbae ),_gg .NewPoint (_cgbga ,_gfcg ).Rotate (_fbae )}}.GetBoundingBox ();return _eeab .Width ,_eeab .Height ;
};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
/*
         [number] [title]      [separator] [page]
   e.g.: Chapter1 Introduction ........... 1
*/
type TOCLine struct{_ebebg *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_cbaed float64 ;_aabgg uint ;_debg float64 ;_gefbe Positioning ;_aecea float64 ;_fdbf float64 ;_ccbe int64 ;};

// Width returns the current page width.
func (_bbge *Creator )Width ()float64 {return _bbge ._bfe };func (_gacf *Invoice )newColumn (_cgce string ,_acccb CellHorizontalAlignment )*InvoiceCell {_eedcb :=&InvoiceCell {_gacf ._fbec ,_cgce };_eedcb .Alignment =_acccb ;return _eedcb ;};

// Logo returns the logo of the invoice.
func (_deaec *Invoice )Logo ()*Image {return _deaec ._ega };

// AddLine appends a new line to the invoice line items table.
func (_eebe *Invoice )AddLine (values ...string )[]*InvoiceCell {_fbfbc :=len (_eebe ._bcdc );var _ddcd []*InvoiceCell ;for _degf ,_abc :=range values {_edgdc :=_eebe .newCell (_abc ,_eebe ._fdeg );if _degf < _fbfbc {_edgdc .Alignment =_eebe ._bcdc [_degf ].Alignment ;
};_ddcd =append (_ddcd ,_edgdc );};_eebe ._cbcg =append (_eebe ._cbcg ,_ddcd );return _ddcd ;};func (_dfga *FilledCurve )draw (_adfc *Block ,_aeed string )([]byte ,*_gec .PdfRectangle ,error ){_ebgfe :=_gg .NewCubicBezierPath ();for _ ,_cbee :=range _dfga ._fcbf {_ebgfe =_ebgfe .AppendCurve (_cbee );
};creator :=_bee .NewContentCreator ();creator .Add_q ();if _dfga .FillEnabled &&_dfga ._dggd !=nil {_dfaf :=_dbceg (_dfga ._dggd );_accea :=_eecec (_adfc ,_dfaf ,_dfga ._dggd ,func ()Rectangle {_aadd :=_gg .NewCubicBezierPath ();for _ ,_gead :=range _dfga ._fcbf {_aadd =_aadd .AppendCurve (_gead );
};_efd :=_aadd .GetBoundingBox ();if _dfga .BorderEnabled {_efd .Height +=_dfga .BorderWidth ;_efd .Width +=_dfga .BorderWidth ;_efd .X -=_dfga .BorderWidth /2;_efd .Y -=_dfga .BorderWidth /2;};return Rectangle {_edaf :_efd .X ,_dgedd :_efd .Y ,_dgdba :_efd .Width ,_gfef :_efd .Height };
});if _accea !=nil {return nil ,nil ,_accea ;};creator .SetNonStrokingColor (_dfaf );};if _dfga .BorderEnabled {if _dfga ._ffcgd !=nil {creator .SetStrokingColor (_dbceg (_dfga ._ffcgd ));};creator .Add_w (_dfga .BorderWidth );};if len (_aeed )> 1{creator .Add_gs (_dc .PdfObjectName (_aeed ));
};_gg .DrawBezierPathWithCreator (_ebgfe ,creator );creator .Add_h ();if _dfga .FillEnabled &&_dfga .BorderEnabled {creator .Add_B ();}else if _dfga .FillEnabled {creator .Add_f ();}else if _dfga .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_aece :=_ebgfe .GetBoundingBox ();
if _dfga .BorderEnabled {_aece .Height +=_dfga .BorderWidth ;_aece .Width +=_dfga .BorderWidth ;_aece .X -=_dfga .BorderWidth /2;_aece .Y -=_dfga .BorderWidth /2;};_ddaf :=&_gec .PdfRectangle {};_ddaf .Llx =_aece .X ;_ddaf .Lly =_aece .Y ;_ddaf .Urx =_aece .X +_aece .Width ;
_ddaf .Ury =_aece .Y +_aece .Height ;return creator .Bytes (),_ddaf ,nil ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_cfa *Image )ScaleToHeight (h float64 ){_faae :=_cfa ._bdebc /_cfa ._eaec ;_cfa ._eaec =h ;_cfa ._bdebc =h *_faae ;};

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_dcdd []VectorDrawable ;_ccff Positioning ;_dedd Margins ;_gcag Margins ;_fffg bool ;_ecd bool ;_geaa *Background ;};func (_ceeg *Table )wrapContent (_eaaag DrawContext )error {if _ceeg ._bfec {return nil ;};_ceeg .sortCells ();_cffg :=func (_adfd *TableCell ,_fgbg int ,_fedeb int ,_ggegc int )(_ccag int ){if _ggegc < 1{return -1;
};_babf :=0;for _feeg :=_fedeb +1;_feeg < len (_ceeg ._dabec )-1;_feeg ++{_fefgd :=_ceeg ._dabec [_feeg ];if _fefgd ._eddfg ==_ggegc &&_babf !=_fedeb {_babf =_feeg ;if (_fefgd ._dfdfe < _adfd ._dfdfe &&_ceeg ._acgc > _fefgd ._dfdfe )||_adfd ._dfdfe < _ceeg ._acgc {continue ;
};break ;};};_bdffd :=float64 (0.0);for _bdeed :=0;_bdeed < _adfd ._bcgc ;_bdeed ++{_bdffd +=_ceeg ._faga [_adfd ._eddfg +_bdeed -1];};_ccaf :=_adfd .width (_ceeg ._fgdb ,_eaaag .Width );var (_gefbg VectorDrawable ;_dbace =false ;);switch _aaff :=_adfd ._cbbec .(type ){case *StyledParagraph :_fcdg :=_eaaag ;
_fcdg .Height =_ag .Floor (_bdffd -_aaff ._dfcfg .Top -_aaff ._dfcfg .Bottom -0.5*_aaff .getTextHeight ());_fcdg .Width =_ccaf ;_baae ,_ebge ,_acea :=_aaff .split (_fcdg );if _acea !=nil {_bd .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_acea .Error ());
};if _baae !=nil &&_ebge !=nil {_ceeg ._dabec [_fedeb ]._cbbec =_baae ;_gefbg =_ebge ;_dbace =true ;};};_ceeg ._dabec [_fedeb ]._bcgc =_adfd ._bcgc ;_eaaag .Height =_eaaag .PageHeight -_eaaag .Margins .Top -_eaaag .Margins .Bottom ;_egbf :=_adfd .cloneProps (nil );
if _dbace {_egbf ._cbbec =_gefbg ;};_egbf ._bcgc =_fgbg ;_egbf ._eddfg =_ggegc +1;_egbf ._dfdfe =_adfd ._dfdfe ;if _egbf ._eddfg +_egbf ._bcgc -1> _ceeg ._gebff {for _fbeb :=_ceeg ._gebff ;_fbeb < _egbf ._eddfg +_egbf ._bcgc -1;_fbeb ++{_ceeg ._gebff ++;
_ceeg ._faga =append (_ceeg ._faga ,_ceeg ._eagc );};};_ceeg ._dabec =append (_ceeg ._dabec [:_babf +1],append ([]*TableCell {_egbf },_ceeg ._dabec [_babf +1:]...)...);return _babf +1;};_gagfg :=func (_gggd *TableCell ,_cdef int ,_dfccab int ,_fbagf float64 )(_bbdc int ){_aeffd :=_gggd .width (_ceeg ._fgdb ,_eaaag .Width );
_cgac :=_fbagf ;_aacgg :=1;_acggc :=_eaaag .Height ;if _acggc > 0{for _cgac > _acggc {_cgac -=_eaaag .Height ;_acggc =_eaaag .PageHeight -_eaaag .Margins .Top -_eaaag .Margins .Bottom ;_aacgg ++;};};var (_ccbbc VectorDrawable ;_eacgf =false ;);switch _bcagb :=_gggd ._cbbec .(type ){case *StyledParagraph :_cagfd :=_eaaag ;
_cagfd .Height =_ag .Floor (_eaaag .Height -_bcagb ._dfcfg .Top -_bcagb ._dfcfg .Bottom -0.5*_bcagb .getTextHeight ());_cagfd .Width =_aeffd ;_beaad ,_cfgfce ,_bgdfc :=_bcagb .split (_cagfd );if _bgdfc !=nil {_bd .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_bgdfc .Error ());
};if _beaad !=nil &&_cfgfce !=nil {_ceeg ._dabec [_cdef ]._cbbec =_beaad ;_ccbbc =_cfgfce ;_eacgf =true ;};};if _aacgg < 2{return -1;};if _ceeg ._dabec [_cdef ]._eddfg +_aacgg -1> _ceeg ._gebff {for _fefd :=0;_fefd < _aacgg ;_fefd ++{_ceeg ._gebff ++;_ceeg ._faga =append (_ceeg ._faga ,_ceeg ._eagc );
};};_gbbe :=_fbagf /float64 (_aacgg );for _eeccaf :=0;_eeccaf < _aacgg ;_eeccaf ++{_ceeg ._faga [_dfccab +_eeccaf -1]=_gbbe ;};_eaaag .Height =_eaaag .PageHeight -_eaaag .Margins .Top -_eaaag .Margins .Bottom ;_cdgaa :=_gggd .cloneProps (nil );if _eacgf {_cdgaa ._cbbec =_ccbbc ;
};_cdgaa ._bcgc =1;_cdgaa ._eddfg =_dfccab +_aacgg -1;_cdgaa ._dfdfe =_gggd ._dfdfe ;_ceeg ._dabec =append (_ceeg ._dabec ,_cdgaa );return len (_ceeg ._dabec );};_bgacc :=1;_eggd :=-1;for _afabf :=0;_afabf < len (_ceeg ._dabec );_afabf ++{_dafc :=_ceeg ._dabec [_afabf ];
if _eggd ==_afabf {_bgacc =_dafc ._eddfg ;};if _dafc ._bcgc < 2{if _afbe :=_ceeg ._faga [_dafc ._eddfg -1];_afbe > _eaaag .Height {_eggd =_gagfg (_dafc ,_afabf ,_dafc ._eddfg ,_afbe );continue ;};continue ;};_afbc :=float64 (0);for _gbec :=0;_gbec < _dafc ._bcgc ;
_gbec ++{_afbc +=_ceeg ._faga [_dafc ._eddfg +_gbec -1];};_dgad :=float64 (0);for _dfgbg :=_bgacc -1;_dfgbg < _dafc ._eddfg -1;_dfgbg ++{_dgad +=_ceeg ._faga [_dfgbg ];};if _afbc <=(_eaaag .Height -_dgad ){continue ;};_eabga :=float64 (0.0);_dfeg :=_dafc ._bcgc ;
_geccd :=-1;_fdaf :=1;for _eddfd :=1;_eddfd <=_dafc ._bcgc ;_eddfd ++{if (_eabga +_ceeg ._faga [_dafc ._eddfg +_eddfd -2])> (_eaaag .Height -_dgad ){_fdaf --;break ;};_geccd =_dafc ._eddfg +_eddfd -1;_dfeg =_dafc ._bcgc -_eddfd ;_eabga +=_ceeg ._faga [_dafc ._eddfg +_eddfd -2];
_fdaf ++;};if _dafc ._bcgc ==_dfeg {_eaaag .Height =_eaaag .PageHeight -_eaaag .Margins .Top -_eaaag .Margins .Bottom ;_bgacc =_dafc ._eddfg ;_afabf --;continue ;};if _dfeg > 0&&_dafc ._bcgc > _fdaf {_dafc ._bcgc =_fdaf ;_eggd =_cffg (_dafc ,_dfeg ,_afabf ,_geccd );
if _afabf +1==_eggd {_afabf --;};};_bgacc =_dafc ._eddfg ;};_ceeg .sortCells ();return nil ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_eagb *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fadd :=ctx ;if _eagb ._ggfa .IsRelative (){ctx .X +=_eagb ._gebe .Left ;ctx .Y +=_eagb ._gebe .Top ;ctx .Width -=_eagb ._gebe .Left +_eagb ._gebe .Right ;ctx .Height -=_eagb ._gebe .Top ;
};_cag ,_fba ,_fcda :=_eagb ._aec .GeneratePageBlocks (ctx );if _fcda !=nil {return _cag ,ctx ,_fcda ;};ctx =_fba ;_gddb :=ctx .X ;_dab :=ctx .Y -_eagb ._aec .Height ();_cfe :=int64 (ctx .Page );_dcdf :=_eagb .headingNumber ();_cgfd :=_eagb .headingText ();
if _eagb ._ggbf {_bdeb :=_eagb ._egfa .Add (_dcdf ,_eagb ._ccf ,_fa .FormatInt (_cfe ,10),_eagb ._gdd );if _eagb ._egfa ._gfge {_bdeb .SetLink (_cfe ,_gddb ,_dab );};};if _eagb ._geg ==nil {_eagb ._geg =_gec .NewOutlineItem (_cgfd ,_gec .NewOutlineDest (_cfe -1,_gddb ,_dab ));
if _eagb ._fbea !=nil {_eagb ._fbea ._geg .Add (_eagb ._geg );}else {_eagb ._aed .Add (_eagb ._geg );};}else {_gaeec :=&_eagb ._geg .Dest ;_gaeec .Page =_cfe -1;_gaeec .X =_gddb ;_gaeec .Y =_dab ;};for _ ,_bca :=range _eagb ._dcea {_bba ,_eacf ,_gebga :=_bca .GeneratePageBlocks (ctx );
if _gebga !=nil {return _cag ,ctx ,_gebga ;};if len (_bba )< 1{continue ;};_cag [len (_cag )-1].mergeBlocks (_bba [0]);_cag =append (_cag ,_bba [1:]...);ctx =_eacf ;};if _eagb ._ggfa .IsRelative (){ctx .X =_fadd .X ;};if _eagb ._ggfa .IsAbsolute (){return _cag ,_fadd ,nil ;
};return _cag ,ctx ,nil ;};func (_bgbf *Paragraph )wrapText ()error {if !_bgbf ._bcab ||int (_bgbf ._abcd )<=0{_bgbf ._bdad =[]string {_bgbf ._adee };return nil ;};_fdac :=NewTextChunk (_bgbf ._adee ,TextStyle {Font :_bgbf ._eged ,FontSize :_bgbf ._dffb });
_cdga ,_dcgc :=_fdac .Wrap (_bgbf ._abcd );if _dcgc !=nil {return _dcgc ;};if _bgbf ._dfedg > 0&&len (_cdga )> _bgbf ._dfedg {_cdga =_cdga [:_bgbf ._dfedg ];};_bgbf ._bdad =_cdga ;return nil ;};type rgbColor struct{_dfgea ,_eee ,_ddab float64 };

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_gdb *Block )SetPos (x ,y float64 ){_gdb ._eec =PositionAbsolute ;_gdb ._bg =x ;_gdb ._fe =y };func _fdbde (_bgdg *templateProcessor ,_dfcb *templateNode )(interface{},error ){return _bgdg .parseListItem (_dfcb );};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_bgda *Creator )AddPage (page *_gec .PdfPage )error {_dgbf ,_cfec :=_bgda .wrapPageIfNeeded (page );if _cfec !=nil {return _cfec ;};if _dgbf !=nil {page =_dgbf ;};_bcaa ,_cfec :=page .GetMediaBox ();if _cfec !=nil {_bd .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_cfec );
return _cfec ;};_bcaa .Normalize ();_afad ,_ffde :=_bcaa .Llx ,_bcaa .Lly ;_bfb :=_bcaa ;if _cdg :=page .CropBox ;_cdg !=nil &&*_cdg !=*_bcaa {_cdg .Normalize ();_afad ,_ffde =_cdg .Llx ,_cdg .Lly ;_bfb =_cdg ;};_aecb :=_ea .IdentityMatrix ();_addb ,_cfec :=page .GetRotate ();
if _cfec !=nil {_bd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_cfec .Error ());
};_afg :=_addb %360!=0&&_addb %90==0;if _afg {_gdce :=float64 ((360+_addb %360)%360);if _gdce ==90{_aecb =_aecb .Translate (_bfb .Width (),0);}else if _gdce ==180{_aecb =_aecb .Translate (_bfb .Width (),_bfb .Height ());}else if _gdce ==270{_aecb =_aecb .Translate (0,_bfb .Height ());
};_aecb =_aecb .Mult (_ea .RotationMatrix (_gdce *_ag .Pi /180));_aecb =_aecb .Round (0.000001);_fgfd :=_afaeb (_bfb ,_aecb );_bfb =_fgfd ;_bfb .Normalize ();};if _afad !=0||_ffde !=0{_aecb =_ea .TranslationMatrix (_afad ,_ffde ).Mult (_aecb );};if !_aecb .Identity (){_aecb =_aecb .Round (0.000001);
_bgda ._eabc [page ]=&pageTransformations {_eabg :&_aecb };};_bgda ._bfe =_bfb .Width ();_bgda ._aae =_bfb .Height ();_bgda .initContext ();_bgda ._gage =append (_bgda ._gage ,page );_bgda ._bdfae .Page ++;return nil ;};func (_gcbf *StyledParagraph )wrapText ()error {return _gcbf .wrapChunks (true )};


// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_gcga *Image )ConvertToBinary ()error {return _gcga ._adgg .ConvertToBinary ()};func _dggga (_bbcg *Table ,_bebef DrawContext )([]*Block ,DrawContext ,error ){var _cacg []*Block ;_abgcf :=NewBlock (_bebef .PageWidth ,_bebef .PageHeight );_bbcg .updateRowHeights (_bebef .Width -_bbcg ._degb .Left -_bbcg ._degb .Right );
_ecbg :=_bbcg ._degb .Top ;if _bbcg ._cfcbe .IsRelative ()&&!_bbcg ._eddeg {_dgdbg :=_bbcg .Height ();if _dgdbg > _bebef .Height -_bbcg ._degb .Top &&_dgdbg <=_bebef .PageHeight -_bebef .Margins .Top -_bebef .Margins .Bottom {_cacg =[]*Block {NewBlock (_bebef .PageWidth ,_bebef .PageHeight -_bebef .Y )};
var _dgabd error ;if _ ,_bebef ,_dgabd =_fcbca ().GeneratePageBlocks (_bebef );_dgabd !=nil {return nil ,_bebef ,_dgabd ;};_ecbg =0;};};_ffeb :=_bebef ;if _bbcg ._cfcbe .IsAbsolute (){_bebef .X =_bbcg ._dbdeb ;_bebef .Y =_bbcg ._edde ;}else {_bebef .X +=_bbcg ._degb .Left ;
_bebef .Y +=_ecbg ;_bebef .Width -=_bbcg ._degb .Left +_bbcg ._degb .Right ;_bebef .Height -=_ecbg ;};_fdgcg :=_bebef .Width ;_egdg :=_bebef .X ;_feba :=_bebef .Y ;_gdbd :=_bebef .Height ;_bdafe :=0;_cacdd ,_dbccf :=-1,-1;if _bbcg ._ddagb {for _cfab ,_dagcc :=range _bbcg ._dabec {if _dagcc ._eddfg < _bbcg ._dbbcc {continue ;
};if _dagcc ._eddfg > _bbcg ._gdecd {break ;};if _cacdd < 0{_cacdd =_cfab ;};_dbccf =_cfab ;};};if _eced :=_bbcg .wrapContent (_bebef );_eced !=nil {return nil ,_bebef ,_eced ;};_bbcg .updateRowHeights (_bebef .Width -_bbcg ._degb .Left -_bbcg ._degb .Right );
var (_gaefe bool ;_dedf int ;_gdcea int ;_bcace bool ;_bfga int ;_gdgbd error ;);for _aedf :=0;_aedf < len (_bbcg ._dabec );_aedf ++{_dfef :=_bbcg ._dabec [_aedf ];if _beega ,_geeae :=_bbcg .getLastCellFromCol (_dfef ._dfdfe );_beega ==_aedf {if (_geeae ._eddfg +_geeae ._bcgc -1)< _bbcg ._gebff {for _bbbcd :=_dfef ._eddfg ;
_bbbcd < _bbcg ._gebff ;_bbbcd ++{_abgag :=&TableCell {};_abgag ._eddfg =_bbbcd +1;_abgag ._bcgc =1;_abgag ._dfdfe =_dfef ._dfdfe ;_bbcg ._dabec =append (_bbcg ._dabec ,_abgag );};};};_cbea :=_dfef .width (_bbcg ._fgdb ,_fdgcg );_bfdb :=float64 (0.0);for _bgaga :=0;
_bgaga < _dfef ._dfdfe -1;_bgaga ++{_bfdb +=_bbcg ._fgdb [_bgaga ]*_fdgcg ;};_beed :=float64 (0.0);for _edgdf :=_bdafe ;_edgdf < _dfef ._eddfg -1;_edgdf ++{_beed +=_bbcg ._faga [_edgdf ];};_bebef .Height =_gdbd -_beed ;_aafgc :=float64 (0.0);for _acga :=0;
_acga < _dfef ._bcgc ;_acga ++{_aafgc +=_bbcg ._faga [_dfef ._eddfg +_acga -1];};_dddbc :=_bcace &&_dfef ._eddfg !=_bfga ;_bfga =_dfef ._eddfg ;if _dddbc ||_aafgc > _bebef .Height {if _bbcg ._bfec &&!_bcace {_bcace ,_gdgbd =_bbcg .wrapRow (_aedf ,_bebef ,_fdgcg );
if _gdgbd !=nil {return nil ,_bebef ,_gdgbd ;};if _bcace {_aedf --;continue ;};};_cacg =append (_cacg ,_abgcf );_abgcf =NewBlock (_bebef .PageWidth ,_bebef .PageHeight );_egdg =_bebef .Margins .Left +_bbcg ._degb .Left ;_feba =_bebef .Margins .Top ;_bebef .Height =_bebef .PageHeight -_bebef .Margins .Top -_bebef .Margins .Bottom ;
_bebef .Page ++;_gdbd =_bebef .Height ;_bdafe =_dfef ._eddfg -1;_beed =0;_bcace =false ;if _bbcg ._ddagb &&_cacdd >=0{_dedf =_aedf ;_aedf =_cacdd -1;_gdcea =_bdafe ;_bdafe =_bbcg ._dbbcc -1;_gaefe =true ;if _dfef ._bcgc > (_bbcg ._gebff -_bfga )||(_dfef ._bcgc > 1&&_aedf < 0){_bd .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_gaefe =false ;_cacdd ,_dbccf =-1,-1;};continue ;};if _dddbc {_aedf --;continue ;};};_bebef .Width =_cbea ;_bebef .X =_egdg +_bfdb ;_bebef .Y =_feba +_beed ;if _aafgc > _bebef .PageHeight -_bebef .Margins .Top -_bebef .Margins .Bottom {_aafgc =_bebef .PageHeight -_bebef .Margins .Top -_bebef .Margins .Bottom ;
};_cgagg :=_dgg (_bebef .X ,_bebef .Y ,_cbea ,_aafgc );if _dfef ._adbdf !=nil {_cgagg .SetFillColor (_dfef ._adbdf );};_cgagg .LineStyle =_dfef ._dbgfb ;_cgagg ._ffcg =_dfef ._afggg ;_cgagg ._ebcd =_dfef ._ccdgd ;_cgagg ._eed =_dfef ._defff ;_cgagg ._ffe =_dfef ._bbefe ;
if _dfef ._aeab !=nil {_cgagg .SetColorLeft (_dfef ._aeab );};if _dfef ._dgbdg !=nil {_cgagg .SetColorBottom (_dfef ._dgbdg );};if _dfef ._ceff !=nil {_cgagg .SetColorRight (_dfef ._ceff );};if _dfef ._ageeb !=nil {_cgagg .SetColorTop (_dfef ._ageeb );
};_cgagg .SetWidthBottom (_dfef ._ecba );_cgagg .SetWidthLeft (_dfef ._dceac );_cgagg .SetWidthRight (_dfef ._degae );_cgagg .SetWidthTop (_dfef ._bbeee );_eaeg :=NewBlock (_abgcf ._bb ,_abgcf ._df );_cbfde :=_abgcf .Draw (_cgagg );if _cbfde !=nil {_bd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cbfde );
};if _dfef ._cbbec !=nil {_cbcebb :=_dfef ._cbbec .Width ();_eceb :=_dfef ._cbbec .Height ();_fggg :=0.0;switch _addac :=_dfef ._cbbec .(type ){case *Paragraph :if _addac ._bcab {_cbcebb =_addac .getMaxLineWidth ()/1000.0;};_gcfg ,_adbge ,_ :=_addac .getTextMetrics ();
_faeef ,_cfgcf :=_gcfg *_addac ._cdeb ,_adbge *_addac ._cdeb ;_eceb =_eceb -_cfgcf +_faeef ;_fggg +=_faeef -_cfgcf ;_fggdd :=0.5;if _bbcg ._bbef {_fggdd =0.3;};switch _dfef ._adgeg {case CellVerticalAlignmentTop :_fggg +=_faeef *_fggdd ;case CellVerticalAlignmentBottom :_fggg -=_faeef *_fggdd ;
};_cbcebb +=_addac ._bgcd .Left +_addac ._bgcd .Right ;_eceb +=_addac ._bgcd .Top +_addac ._bgcd .Bottom ;case *StyledParagraph :if _addac ._cafa {_cbcebb =_addac .getMaxLineWidth ()/1000.0;};_bfdebc ,_fgfgd ,_bcfg :=_addac .getLineMetrics (0);_ccada ,_ecbf :=_bfdebc *_addac ._cdadd ,_fgfgd *_addac ._cdadd ;
if _addac ._ggdge ==TextVerticalAlignmentCenter {_fggg =_ecbf -(_fgfgd +(_bfdebc +_bcfg -_fgfgd )/2+(_ecbf -_fgfgd )/2);};if len (_addac ._dbgba )==1{_eceb =_ccada ;}else {_eceb =_eceb -_ecbf +_ccada ;};_fggg +=_ccada -_ecbf ;switch _dfef ._adgeg {case CellVerticalAlignmentTop :_fggg +=_ccada *0.5;
case CellVerticalAlignmentBottom :_fggg -=_ccada *0.5;};_cbcebb +=_addac ._dfcfg .Left +_addac ._dfcfg .Right ;_eceb +=_addac ._dfcfg .Top +_addac ._dfcfg .Bottom ;case *Table :_cbcebb =_cbea ;case *List :_cbcebb =_cbea ;case *Division :_cbcebb =_cbea ;
case *Chart :_cbcebb =_cbea ;case *Line :_eceb +=_addac ._egbc .Top +_addac ._egbc .Bottom ;_fggg -=_addac .Height ()/2;case *Image :_cbcebb +=_addac ._afgf .Left +_addac ._afgf .Right ;_eceb +=_addac ._afgf .Top +_addac ._afgf .Bottom ;};switch _dfef ._faefa {case CellHorizontalAlignmentLeft :_bebef .X +=_dfef ._dbafb ;
_bebef .Width -=_dfef ._dbafb ;case CellHorizontalAlignmentCenter :if _efdbf :=_cbea -_cbcebb ;_efdbf > 0{_bebef .X +=_efdbf /2;_bebef .Width -=_efdbf /2;};case CellHorizontalAlignmentRight :if _cbea > _cbcebb {_bebef .X =_bebef .X +_cbea -_cbcebb -_dfef ._dbafb ;
_bebef .Width -=_dfef ._dbafb ;};};_afcdg :=_bebef .Y ;_agcg :=_bebef .Height ;_bebef .Y +=_fggg ;switch _dfef ._adgeg {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _gfgab :=_aafgc -_eceb ;_gfgab > 0{_bebef .Y +=_gfgab /2;_bebef .Height -=_gfgab /2;
};case CellVerticalAlignmentBottom :if _aafgc > _eceb {_bebef .Y =_bebef .Y +_aafgc -_eceb ;_bebef .Height =_aafgc ;};};_dacg :=_abgcf .DrawWithContext (_dfef ._cbbec ,_bebef );if _dacg !=nil {if _d .Is (_dacg ,ErrContentNotFit )&&!_dddbc {_abgcf =_eaeg ;
_dddbc =true ;_aedf --;continue ;};_bd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dacg );};_bebef .Y =_afcdg ;_bebef .Height =_agcg ;};_bebef .Y +=_aafgc ;_bebef .Height -=_aafgc ;if _gaefe &&_aedf +1> _dbccf {_feba +=_beed +_aafgc ;_gdbd -=_aafgc +_beed ;
_bdafe =_gdcea ;_aedf =_dedf -1;_gaefe =false ;};};_cacg =append (_cacg ,_abgcf );if _bbcg ._cfcbe .IsAbsolute (){return _cacg ,_ffeb ,nil ;};_bebef .X =_ffeb .X ;_bebef .Width =_ffeb .Width ;_bebef .Y +=_bbcg ._degb .Bottom ;_bebef .Height -=_bbcg ._degb .Bottom ;
return _cacg ,_bebef ,nil ;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_cge *Creator )NewChapter (title string )*Chapter {_cge ._daefc ++;_bbcf :=_cge .NewTextStyle ();_bbcf .FontSize =16;return _cgd (nil ,_cge ._fed ,_cge ._aggf ,title ,_cge ._daefc ,_bbcf );};

// LevelOffset returns the amount of space an indentation level occupies.
func (_fdaga *TOCLine )LevelOffset ()float64 {return _fdaga ._debg };func _gaade (_addbf _cc .Image )(*Image ,error ){_bcgf ,_gabc :=_gec .ImageHandling .NewImageFromGoImage (_addbf );if _gabc !=nil {return nil ,_gabc ;};return _cged (_bcgf );};

// SetPos sets absolute positioning with specified coordinates.
func (_aaca *StyledParagraph )SetPos (x ,y float64 ){_aaca ._ebdeg =PositionAbsolute ;_aaca ._fefbd =x ;_aaca ._ddfge =y ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_gage []*_gec .PdfPage ;_gggc map[*_gec .PdfPage ]*Block ;_eabc map[*_gec .PdfPage ]*pageTransformations ;_cgc *_gec .PdfPage ;_fff PageSize ;_bdfae DrawContext ;_bag Margins ;_bfe ,_aae float64 ;_daefc int ;_fgg func (_bbfg FrontpageFunctionArgs );
_dfed func (_eecc *TOC )error ;_acf func (_gbbb *Block ,_cgag HeaderFunctionArgs );_fgc func (_adgd *Block ,_cgaf FooterFunctionArgs );_ecgd func (_afa PageFinalizeFunctionArgs )error ;_dbbd func (_gfae *_gec .PdfWriter )error ;_bgd bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;

// CustomTOC specifies if the TOC is rendered by the user.
// When the `CustomTOC` field is set to `true`, the default TOC component is not rendered.
// Instead the TOC is drawn by the user, in the callback provided to
// the `Creator.CreateTableOfContents` method.
// If `CustomTOC` is set to `false`, the callback provided to
// `Creator.CreateTableOfContents` customizes the style of the automatically generated TOC component.
CustomTOC bool ;_fed *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_aggf *_gec .Outline ;_cdcc *_gec .PdfOutlineTreeNode ;_eeea *_gec .PdfAcroForm ;_babd _dc .PdfObject ;_cfbf _gec .Optimizer ;_gff []*_gec .PdfFont ;_dgaf *_gec .PdfFont ;_bccg *_gec .PdfFont ;};func (_gebaf *templateProcessor )parseChapter (_fgda *templateNode )(interface{},error ){_fcdgd :=_gebaf .creator .NewChapter ;
if _fgda ._cafd !=nil {if _gacfg ,_bbfc :=_fgda ._cafd ._cdegg .(*Chapter );_bbfc {_fcdgd =_gacfg .NewSubchapter ;};};_dbbcf :=_fcdgd ("");for _ ,_dgge :=range _fgda ._cggg .Attr {_cadfa :=_dgge .Value ;switch _dbbf :=_dgge .Name .Local ;_dbbf {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_dbbcf .SetShowNumbering (_gebaf .parseBoolAttr (_dbbf ,_cadfa ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_dbbcf .SetIncludeInTOC (_gebaf .parseBoolAttr (_dbbf ,_cadfa ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_fcaeg :=_gebaf .parseMarginAttr (_dbbf ,_cadfa );_dbbcf .SetMargins (_fcaeg .Left ,_fcaeg .Right ,_fcaeg .Top ,_fcaeg .Bottom );
default:_gebaf .nodeLogDebug (_fgda ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_dbbf );
};};return _dbbcf ,nil ;};

// NewRectangle creates a new rectangle with the left corner at (`x`, `y`),
// having the specified width and height.
// NOTE: In relative positioning mode, `x` and `y` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the rectangle is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_efag *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _fcdfa (x ,y ,width ,height );};func (_bcfcc *templateProcessor )parseStyledParagraph (_fdaa *templateNode )(interface{},error ){_fced :=_bcfcc .creator .NewStyledParagraph ();
for _ ,_adeeb :=range _fdaa ._cggg .Attr {_degcc :=_adeeb .Value ;switch _fgfed :=_adeeb .Name .Local ;_fgfed {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_fced .SetTextAlignment (_bcfcc .parseTextAlignmentAttr (_fgfed ,_degcc ));
case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_fced .SetTextVerticalAlignment (_bcfcc .parseTextVerticalAlignmentAttr (_fgfed ,_degcc ));case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_fced .SetLineHeight (_bcfcc .parseFloatAttr (_fgfed ,_degcc ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_ggeef :=_bcfcc .parseMarginAttr (_fgfed ,_degcc );_fced .SetMargins (_ggeef .Left ,_ggeef .Right ,_ggeef .Top ,_ggeef .Bottom );case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_fced .SetEnableWrap (_bcfcc .parseBoolAttr (_fgfed ,_degcc ));
case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_fced .EnableWordWrap (_bcfcc .parseBoolAttr (_fgfed ,_degcc ));case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_fced .SetTextOverflow (_bcfcc .parseTextOverflowAttr (_fgfed ,_degcc ));
case "\u0078":_fced .SetPos (_bcfcc .parseFloatAttr (_fgfed ,_degcc ),_fced ._ddfge );case "\u0079":_fced .SetPos (_fced ._fefbd ,_bcfcc .parseFloatAttr (_fgfed ,_degcc ));case "\u0061\u006e\u0067l\u0065":_fced .SetAngle (_bcfcc .parseFloatAttr (_fgfed ,_degcc ));
default:_bcfcc .nodeLogDebug (_fdaa ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0073\u0074\u0079l\u0065\u0064\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0060\u0025\u0073`.\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_fgfed );
};};return _fced ,nil ;};func (_fgcd *Table )moveToNextAvailableCell ()int {_feff :=(_fgcd ._faaef -1)%(_fgcd ._acgc )+1;for {if _feff -1>=len (_fgcd ._afabg ){if _fgcd ._afabg [0]==0{return _feff ;};_feff =1;}else if _fgcd ._afabg [_feff -1]==0{return _feff ;
};_fgcd ._faaef ++;_fgcd ._afabg [_feff -1]--;_feff ++;};};func _dac (_dea string ,_gefc _dc .PdfObject ,_add *_gec .PdfPageResources )_dc .PdfObjectName {_gea :=_bea .TrimRightFunc (_bea .TrimSpace (_dea ),func (_ffb rune )bool {return _ee .IsNumber (_ffb )});
if _gea ==""{_gea ="\u0046\u006f\u006e\u0074";};_gaaf :=0;_gaab :=_dc .PdfObjectName (_dea );for {_agg ,_bad :=_add .GetFontByName (_gaab );if !_bad ||_agg ==_gefc {break ;};_gaaf ++;_gaab =_dc .PdfObjectName (_e .Sprintf ("\u0025\u0073\u0025\u0064",_gea ,_gaaf ));
};return _gaab ;};

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{_cfgae float64 ;_ebf float64 ;_ccfa float64 ;_cfcbb float64 ;_bddae Color ;_ddde _gg .LineStyle ;_bceg float64 ;_cgdgd []int64 ;_cggede int64 ;_faaeb float64 ;_gecec Positioning ;_dabe FitMode ;_egbc Margins ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// SetShowLinks sets visibility of links for the TOC lines.
func (_cfgfcg *TOC )SetShowLinks (showLinks bool ){_cfgfcg ._gfge =showLinks };

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_ddaa *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_ecfb :=NewTextChunk (text ,_ddaa ._dffcf );_ecfb ._aacgc =_aebee (page -1,x ,y ,zoom );return _ddaa .appendChunk (_ecfb );};

// SetFillColor sets the fill color of the rectangle.
func (_eaeeb *Rectangle )SetFillColor (col Color ){_eaeeb ._gbbce =col };

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;func (_bbdgc *Paragraph )getTextLineWidth (_dfff string )float64 {var _deaab float64 ;for _ ,_afaddc :=range _dfff {if _afaddc =='\u000A'{continue ;};_fadfb ,_aabc :=_bbdgc ._eged .GetRuneMetrics (_afaddc );if !_aabc {_bd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_afaddc ,_afaddc );
return -1;};_deaab +=_bbdgc ._dffb *_fadfb .Wx ;};return _deaab ;};

// Width returns the width of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_ceee *Rectangle )Width ()float64 {return _ceee ._dgdba };func _bbgbd (_gbgg *templateProcessor ,_fdfgg *templateNode )(interface{},error ){return _gbgg .parseStyledParagraph (_fdfgg );};

// Width returns the width of the graphic svg.
func (_abgg *GraphicSVG )Width ()float64 {return _abgg ._bbce .Width };

// SetMargins sets the margins of the chart component.
func (_dgb *Chart )SetMargins (left ,right ,top ,bottom float64 ){_dgb ._fgb .Left =left ;_dgb ._fgb .Right =right ;_dgb ._fgb .Top =top ;_dgb ._fgb .Bottom =bottom ;};

// SetWidthTop sets border width for top.
func (_daf *border )SetWidthTop (bw float64 ){_daf ._dga =bw };

// SetTitle sets the title of the invoice.
func (_bbgb *Invoice )SetTitle (title string ){_bbgb ._gfeg =title };

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_abfe *Creator )MoveDown (dy float64 ){_abfe ._bdfae .Y +=dy };

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
func (_ebaf *Creator )SetPageSize (size PageSize ){_ebaf ._fff =size ;_ebaf ._bfe =size [0];_ebaf ._aae =size [1];_dfb :=0.1*_ebaf ._bfe ;_ebaf ._bag .Left =_dfb ;_ebaf ._bag .Right =_dfb ;_ebaf ._bag .Top =_dfb ;_ebaf ._bag .Bottom =_dfb ;};const (TextAlignmentLeft TextAlignment =iota ;
TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_baegg *Creator )NewPolyBezierCurve (curves []_gg .CubicBezierCurve )*PolyBezierCurve {return _efdb (curves );};

// ScaleToWidth sets the graphic svg scaling factor with the given width.
func (_abdba *GraphicSVG )ScaleToWidth (w float64 ){_cdge :=_abdba ._bbce .Height /_abdba ._bbce .Width ;_abdba ._bbce .Width =w ;_abdba ._bbce .Height =w *_cdge ;_abdba ._bbce .SetScaling (_cdge ,_cdge );};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_aebade *TOC )SetLinePageStyle (style TextStyle ){_aebade ._ebcc =style };

// SetWidthBottom sets border width for bottom.
func (_dfdc *border )SetWidthBottom (bw float64 ){_dfdc ._fga =bw };

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_ddd *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_afc []*Block ;_bfee bool ;_dbgfg error ;_cfcb =_ddd ._ccff .IsRelative ();_fafc =_ddd ._dedd .Top ;);if _cfcb &&!_ddd ._ecd &&!_ddd ._fffg {_dbae :=_ddd .ctxHeight (ctx .Width );
if _dbae > ctx .Height -_ddd ._dedd .Top &&_dbae <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _afc ,ctx ,_dbgfg =_fcbca ().GeneratePageBlocks (ctx );_dbgfg !=nil {return nil ,ctx ,_dbgfg ;};_bfee =true ;_fafc =0;};};_egeb :=ctx ;_eefd :=ctx ;
if _cfcb {ctx .X +=_ddd ._dedd .Left ;ctx .Y +=_fafc ;ctx .Width -=_ddd ._dedd .Left +_ddd ._dedd .Right ;ctx .Height -=_fafc ;_eefd =ctx ;ctx .X +=_ddd ._gcag .Left ;ctx .Y +=_ddd ._gcag .Top ;ctx .Width -=_ddd ._gcag .Left +_ddd ._gcag .Right ;ctx .Height -=_ddd ._gcag .Top ;
ctx .Margins .Top +=_ddd ._gcag .Top ;ctx .Margins .Bottom +=_ddd ._gcag .Bottom ;ctx .Margins .Left +=_ddd ._dedd .Left +_ddd ._gcag .Left ;ctx .Margins .Right +=_ddd ._dedd .Right +_ddd ._gcag .Right ;};ctx .Inline =_ddd ._fffg ;_gecf :=ctx ;_bda :=ctx ;
var _ebef float64 ;for _ ,_acgf :=range _ddd ._dcdd {if ctx .Inline {if (ctx .X -_gecf .X )+_acgf .Width ()<=ctx .Width {ctx .Y =_bda .Y ;ctx .Height =_bda .Height ;}else {ctx .X =_gecf .X ;ctx .Width =_gecf .Width ;_bda .Y +=_ebef ;_bda .Height -=_ebef ;
_ebef =0;};};_fdgc ,_ddeg ,_bdff :=_acgf .GeneratePageBlocks (ctx );if _bdff !=nil {_bd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_bdff );
return nil ,ctx ,_bdff ;};if len (_fdgc )< 1{continue ;};if len (_afc )> 0{_afc [len (_afc )-1].mergeBlocks (_fdgc [0]);_afc =append (_afc ,_fdgc [1:]...);}else {if _eegb :=_fdgc [0]._efc ;_eegb ==nil ||len (*_eegb )==0{_bfee =true ;};_afc =append (_afc ,_fdgc [0:]...);
};if ctx .Inline {if ctx .Page !=_ddeg .Page {_gecf .Y =ctx .Margins .Top ;_gecf .Height =ctx .PageHeight -ctx .Margins .Top ;_bda .Y =_gecf .Y ;_bda .Height =_gecf .Height ;_ebef =_ddeg .Height -_gecf .Height ;}else {if _cgff :=ctx .Height -_ddeg .Height ;
_cgff > _ebef {_ebef =_cgff ;};};}else {_ddeg .X =ctx .X ;};ctx =_ddeg ;};ctx .Inline =_egeb .Inline ;ctx .Margins =_egeb .Margins ;if _cfcb {ctx .X =_egeb .X ;ctx .Width =_egeb .Width ;ctx .Y +=_ddd ._gcag .Bottom ;ctx .Height -=_ddd ._gcag .Bottom ;};
if _ddd ._geaa !=nil {_afc ,_dbgfg =_ddd .drawBackground (_afc ,_eefd ,ctx ,_bfee );if _dbgfg !=nil {return nil ,ctx ,_dbgfg ;};};if _ddd ._ccff .IsAbsolute (){return _afc ,_egeb ,nil ;};ctx .Y +=_ddd ._dedd .Bottom ;ctx .Height -=_ddd ._dedd .Bottom ;
return _afc ,ctx ,nil ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_ggfg *RadialShading )SetExtends (start bool ,end bool ){_ggfg ._ddggc .SetExtends (start ,end )};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_ddda DrawContext )([]*Block ,DrawContext ,error );};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_bgbef *RadialShading )AddShadingResource (block *Block )(_dggg _dc .PdfObjectName ,_ggce error ){_gfdb :=1;_dggg =_dc .PdfObjectName ("\u0053\u0068"+_fa .Itoa (_gfdb ));for block ._fb .HasShadingByName (_dggg ){_gfdb ++;_dggg =_dc .PdfObjectName ("\u0053\u0068"+_fa .Itoa (_gfdb ));
};if _edgg :=block ._fb .SetShadingByName (_dggg ,_bgbef .shadingModel ().ToPdfObject ());_edgg !=nil {return "",_edgg ;};return _dggg ,nil ;};

// SetWidthRight sets border width for right.
func (_gee *border )SetWidthRight (bw float64 ){_gee ._aegf =bw };const (FitModeNone FitMode =iota ;FitModeFillWidth ;);

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// MultiFont represents an encoder that accepts multiple fonts and selects the correct font for encoding.
MultiFont *_gec .MultipleFontEncoder ;

// Font represents the font the text will use.
Font *_gec .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};func (_cabb *LinearShading )shadingModel ()*_gec .PdfShadingType2 {_facf :=_gg .NewPoint (_cabb ._fadfd .Llx +_cabb ._fadfd .Width ()/2,_cabb ._fadfd .Lly +_cabb ._fadfd .Height ()/2);_dcge :=_gg .NewPoint (_cabb ._fadfd .Llx ,_cabb ._fadfd .Lly +_cabb ._fadfd .Height ()/2).Add (-_facf .X ,-_facf .Y ).Rotate (_cabb ._cfbb ).Add (_facf .X ,_facf .Y );
_dcge =_gg .NewPoint (_ag .Max (_ag .Min (_dcge .X ,_cabb ._fadfd .Urx ),_cabb ._fadfd .Llx ),_ag .Max (_ag .Min (_dcge .Y ,_cabb ._fadfd .Ury ),_cabb ._fadfd .Lly ));_fggd :=_gg .NewPoint (_cabb ._fadfd .Urx ,_cabb ._fadfd .Lly +_cabb ._fadfd .Height ()/2).Add (-_facf .X ,-_facf .Y ).Rotate (_cabb ._cfbb ).Add (_facf .X ,_facf .Y );
_fggd =_gg .NewPoint (_ag .Min (_ag .Max (_fggd .X ,_cabb ._fadfd .Llx ),_cabb ._fadfd .Urx ),_ag .Min (_ag .Max (_fggd .Y ,_cabb ._fadfd .Lly ),_cabb ._fadfd .Ury ));_ebgfeg :=_gec .NewPdfShadingType2 ();_ebgfeg .PdfShading .ShadingType =_dc .MakeInteger (2);
_ebgfeg .PdfShading .ColorSpace =_gec .NewPdfColorspaceDeviceRGB ();_ebgfeg .PdfShading .AntiAlias =_dc .MakeBool (_cabb ._dece ._gdegc );_ebgfeg .Coords =_dc .MakeArrayFromFloats ([]float64 {_dcge .X ,_dcge .Y ,_fggd .X ,_fggd .Y });_ebgfeg .Extend =_dc .MakeArray (_dc .MakeBool (_cabb ._dece ._babg [0]),_dc .MakeBool (_cabb ._dece ._babg [1]));
_ebgfeg .Function =_cabb ._dece .generatePdfFunctions ();return _ebgfeg ;};

// Inline returns whether the inline mode of the division is active.
func (_acad *Division )Inline ()bool {return _acad ._fffg };func (_dgged *templateProcessor )parseInt64Attr (_gcfea ,_cdgb string )int64 {_bd .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_gcfea ,_cdgb );
_afdeb ,_ :=_fa .ParseInt (_cdgb ,10,64);return _afdeb ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType3 object.
func (_cgafb *RadialShading )ToPdfShadingPattern ()*_gec .PdfShadingPatternType3 {_deeg ,_cbbe ,_gaddff :=_cgafb ._ddggc ._edaa .ToRGB ();_cagb :=_cgafb .shadingModel ();_cagb .PdfShading .Background =_dc .MakeArrayFromFloats ([]float64 {_deeg ,_cbbe ,_gaddff });
_dgdad :=_gec .NewPdfShadingPatternType3 ();_dgdad .Shading =_cagb ;return _dgdad ;};